# TEST COMMIT
#test commit
#TEST
#testtt
#test1
#testingsept302025
#testcommitoctober120252
#TESTINGGGGGGGGGGGGGGGGGGGGGGGGG
#oct 13, 2025
#eeee
#kleinudeeeeeeeeeeee
#uddddd
#updated as of oct 17,2025 4:27pm
#t=hdhdh
#updated as of oct 21,2025 48:55am
#oct 21,2025 UDDDDDDDDDDDDDDD uppp
#hehehe
#ttestclea
#heue
library(tidyverse)
library(DT)
library(dplyr)
library(shiny)
library(shinydashboard)
library(bslib)
library(bsicons)
library(leaflet)
library(htmltools)
library(thematic)
library(arrow)
library(forcats)
library(fontawesome)
library(shinyjs)
library(shinyauthr)
library(httr)
library(scales)
library(tidytext)
library(ggplot2)
library(plotly)
library(readr)
library(geojsonio)
library(shinyWidgets)
library(later)
library(googlesheets4)
library(DBI)
library(RPostgres)
library(pool)
library(reactable)
library(reactablefmtr)


# HROD Data Upload
sheet_url <- "https://docs.google.com/spreadsheets/d/1e3ni50Jcv3sBAkG8TbwBt4v7kjjMRSVvf9gxtcMiqjU/edit?gid=0#gid=0"
SHEET_ID <- "https://docs.google.com/spreadsheets/d/1x9D8xfXtkT1Mbr4M4We7I9sUqoj42X4SFX9N9hu24wM/edit?gid=0#gid=0"
SHEET_NAME <- "Sheet1" # Assuming the data is on the first tab
school_data <- reactiveVal(NULL)
df <- read_parquet("School-Level-v2.parquet") # per Level Data
uni <- read_parquet("School-Unique-v2.parquet") # School-level Data
IndALL <- read_parquet("IndDistance.ALL2.parquet") # Industry Distances
ind <- read_parquet("SHS-Industry.parquet") # Industry Coordinates
# Clean Sector names
ind <- ind %>%
  mutate(
    Sector = case_when(
      is.na(Sector) | Sector == "#N/A" ~ NA_character_,
      str_detect(Sector, regex("Agri", ignore_case = TRUE)) ~ "Agriculture and Agri-business",
      str_detect(Sector, regex("Business", ignore_case = TRUE)) ~ "Business and Finance",
      str_detect(Sector, regex("Hospitality|Tourism", ignore_case = TRUE)) ~ "Hospitality and Tourism",
      str_detect(Sector, regex("Manufacturing|Engineeri", ignore_case = TRUE)) ~ "Manufacturing and Engineering",
      str_detect(Sector, regex("Professional|Service", ignore_case = TRUE)) ~ "Professional/Private Services",
      str_detect(Sector, regex("Public", ignore_case = TRUE)) ~ "Public Administration",
      TRUE ~ Sector  # leave unchanged if no match
    )
  )
SDO <- read_parquet("SDOFill.parquet") # SDO and Regional Filling-up Rate
DBMProp <- read.csv("DBM-Proposal.csv") # Teacher Shortage Data

# EFD Data Upload
EFDDB <- read.csv("EFD-DataBuilder-2025.csv")
EFDMP <- read_parquet("EFD-Masterlist.parquet")
EFD_Projects <- read.csv("EFD-ProgramsList-Aug2025.csv") %>% mutate(Allocation = as.numeric(Allocation)) %>% mutate(Completion = as.numeric(Completion)) %>% filter(FundingYear >= 2020)
LMS <- read_parquet("EFD-LMS-GIDCA-NSBI2023.parquet") %>%
  mutate(
    Region = case_when(Region == "Region IV-B" ~ "MIMAROPA", TRUE ~ Region),
    With_Shortage = case_when(Estimated_CL_Shortage > 0 ~ 1, TRUE ~ 0)
  ) %>%
  left_join(
    uni %>% select(
      SchoolID,
      Latitude,
      Longitude,
      Legislative.District,
      Municipality,
      Barangay
    ),
    by = c("School_ID" = "SchoolID")
  )


geojson_data <- geojson_read("gadm41_PHL_1.json", what = "sp")
geojson_table <- as.data.frame(geojson_data)
regprov <- read.csv("RegProv.Congestion.csv")
geojson_table <- left_join(geojson_table,regprov, by="NAME_1")
buildablecsv <- read.csv("Buildable_LatLong.csv")
# Clean column names: remove line breaks, extra spaces
names(buildablecsv) <- gsub("[\r\n]", " ", names(buildablecsv))
names(buildablecsv) <- trimws(names(buildablecsv))
# Ensure lat/long are numeric
buildablecsv$Latitude <- as.numeric(buildablecsv$Latitude)
buildablecsv$Longitude <- as.numeric(buildablecsv$Longitude)


# CLOUD Data Upload
cloud <- read_parquet("Cloud_Consolidated.parquet")
cloud_v2 <- read_parquet("Cloud_Consolidated_v2.parquet")
cloud_v3 <- read_parquet("Cloud_Consolidated_v3.parquet")

#Data Explorer 
ThirdLevel <- read.csv("2025-Third Level Officials DepEd-cleaned.csv", stringsAsFactors = FALSE)


user_base <- tibble::tibble(
  user = c("iamdeped", "depedadmin"),
  password = c("deped123", "stride123"), # In a real app, use hashed passwords
  password_hash = sapply(c("deped123", "stride123"), sodium::password_store), # Hashed passwords
  permissions = c("admin", "standard"),
  name = c("User One", "User Two")
)




SERVICE_ACCOUNT_FILE <- "service_account.json" 

# Check if the file exists before attempting to authenticate
print("Checking for service_account.json...")
print(file.exists(SERVICE_ACCOUNT_FILE))

if (file.exists(SERVICE_ACCOUNT_FILE)) {
  library(googlesheets4)
  gs4_auth(
    scopes = "https://www.googleapis.com/auth/spreadsheets",
    path = SERVICE_ACCOUNT_FILE
  )
  print("googlesheets4 authenticated successfully using Service Account.")
} else {
  warning(paste("âŒ Service account key not found at:", SERVICE_ACCOUNT_FILE))
}

# Define UI for application that draws a histogram
# --- 5. Run App (Fixed UI) ---

# Use bslib::page_fluid for the root UI, which is the standard bslib container
ui <- page_fluid(
  
  # Use shinyjs to easily show/hide elements
  shinyjs::useShinyjs(), 
  
  # Apply a clean theme (e.g., Bootstrap 5's "litera")
  theme = bs_theme(version = 5,
                   bootswatch = "litera",
                   font_scale = 0.9,
                   base_font = font_google("Alan Sans")),
  
  # Global Head elements
  tags$head(
    # Custom styling for btn-warning (if litera theme overrides it)
    tags$style(HTML("
    .btn-warning {
      background-color: #ffc107 !important; /* classic yellow */
      border-color: #ffc107 !important;
      color: #212529 !important; /* readable text */
      font-weight: 600;
    }

    .btn-warning:hover {
      background-color: #e0a800 !important; /* darker yellow hover */
      border-color: #d39e00 !important;
      color: #fff !important;
    }
    ")),
    
    # External files (ensure they are in the 'www' folder)
    includeCSS("www/style.css"),
    includeScript("www/script.js"),
    
    tags$link(rel = "icon", type = "image/png", href = "deped_logo.png"),
    
    # Leaflet smooth marker bouncing script
    tags$script(src = "https://unpkg.com/leaflet.smoothmarkerbouncing/leaflet.smoothmarkerbouncing.js"),
    
    # Viewport meta tag
    tags$meta(name = "viewport", content = "width=device-width, initial-scale=1.0, maximum-scale=3.0")
  ),
  
  # Header (always visible)
  # shinyjs::hidden(
  #   # --- Government-style Top Header ---
  #   tags$div(
  #     id = "app_header",
  #     class = "app-header",
  #     style = "display: flex; align-items: center; gap: 15px; justify-content: center;",
  #     
  #     # Left logo
  #     tags$img(src = "logo3.png", class = "header-logo-left"),
  #     
  #     # Center text
  #     tags$div(
  #       class = "header-title",
  #       h2("DepEd STRIDE"),
  #       p("Strategic Inventory for Deployment Efficiency")
  #     ),
  #     
  #     # Right logo
  #     tags$img(src = "HROD LOGO1.png", class = "header-logo-right")
  #   )
  # ),
  
  
  
  
  # ðŸ’¡ CRITICAL FIX: The dynamic container for login/main app UI
  uiOutput("page_ui"),
  
  shinyjs::hidden(
    div(
      id = "main_content",
      uiOutput("STRIDE1"))),
  
  shinyjs::hidden(
    div(
      id = "mgmt_content",
      uiOutput("STRIDE2"))),
  
  shinyjs::hidden(
    div(
      id = "data_input_content",
      uiOutput("STRIDE_data"))),
  
  
  tags$div(
    id = "loading-overlay",
    style = "
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: #ffffff;
    z-index: 99999;
    text-align: center;
  ",
    tags$div(
      style = "position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
             color: black; font-size: 1.3em;",
      tags$img(src = "LOAD.gif", height = "80px"),  # ðŸ‘ˆ replace with your GIF or logo
      tags$p(id = "loading-text", "Welcome to STRIDE...")
    )
  ),
  
  tags$head(
    tags$link(
      href = "https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap",
      rel = "stylesheet"
    ),
    tags$style(HTML("
    body, h1, h2, h3, h4, h5, h6, p, span, button {
      font-family: 'Poppins', sans-serif !important;
    }
  "))
  ),
  tags$link(rel = "preconnect", href = "https://fonts.gstatic.com", crossorigin = "anonymous"),
  
  
  
  
  
  
  
  # Footer (always visible)
  shinyjs::hidden(
    tags$footer(
      id = "app_footer",
      class = "app-footer",
      tags$p("Â© Based on GMIS (April 2025) and eBEIS (SY 2024â€“2025)")))
)






# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  # --- Logic for Feature 1 (Drilldown) ---
  
  current_drilldown <- reactiveVal(list(level = "region", filter = NULL))
  
  current_totals <- reactive({
    req(uni)
    state <- current_drilldown()
    
    data_to_sum <- uni
    
    if (state$level == "division") {
      data_to_sum <- uni %>% filter(Region == state$filter)
    } else if (state$level == "district") {
      data_to_sum <- uni %>% filter(Division == state$filter)
    }
    
    list(
      schools = nrow(data_to_sum), 
      enroll = sum(as.numeric(data_to_sum$TotalEnrolment), na.rm = TRUE),
      teach = sum(as.numeric(data_to_sum$TotalTeachers), na.rm = TRUE)
    )
  })
  
  output$card_enrollment <- renderUI({ 
    req(current_totals())
    card(
      card_header("Total Enrollment"),
      div(
        style="font-size: 2rem; font-weight: bold;", 
        class="text-primary text-center", 
        format(round(current_totals()$enroll), nsmall = 0, big.mark = ",")
      ),
      class = "mb-1" 
    )
  })
  
  output$card_teachers <- renderUI({ 
    req(current_totals())
    card(
      card_header("Total Teachers"),
      div(
        style="font-size: 2rem; font-weight: bold;", 
        class="text-primary text-center",
        format(round(current_totals()$teach), nsmall = 0, big.mark = ",")
      ),
      class = "mb-1"
    )
  })
  
  output$card_schools <- renderUI({ 
    req(current_totals())
    card(
      card_header("Total Schools"),
      div(
        style="font-size: 2rem; font-weight: bold;", 
        class="text-primary text-center",
        format(round(current_totals()$schools), nsmall = 0, big.mark = ",")
      ),
      class = "mb-1"
    )
  })
  
  drilldown_data <- reactive({
    req(uni)
    state <- current_drilldown()
    
    if (state$level == "region") {
      uni %>%
        group_by(Region) %>%
        summarise(
          Total_Enrollment = sum(as.numeric(TotalEnrolment), na.rm = TRUE),
          Total_Teachers = sum(as.numeric(TotalTeachers), na.rm = TRUE),
          Total_Schools = n() 
        ) %>%
        filter(!is.na(Region)) %>%
        rename(group_col = Region) 
    } else if (state$level == "division") {
      req(state$filter)
      uni %>%
        filter(Region == state$filter) %>%
        group_by(Division) %>%
        summarise(
          Total_Enrollment = sum(as.numeric(TotalEnrolment), na.rm = TRUE),
          Total_Teachers = sum(as.numeric(TotalTeachers), na.rm = TRUE),
          Total_Schools = n()
        ) %>%
        filter(!is.na(Division)) %>%
        rename(group_col = Division)
    } else if (state$level == "district") {
      req(state$filter)
      uni %>%
        filter(Division == state$filter) %>%
        group_by(District) %>%
        summarise(
          Total_Enrollment = sum(as.numeric(TotalEnrolment), na.rm = TRUE),
          Total_Teachers = sum(as.numeric(TotalTeachers), na.rm = TRUE),
          Total_Schools = n()
        ) %>%
        filter(!is.na(District)) %>%
        rename(group_col = District)
    }
  })
  
  output$plotly_enrollment <- renderPlotly({
    req(drilldown_data())
    plot_ly(
      drilldown_data(), 
      y = ~group_col, x = ~Total_Enrollment,
      type = 'bar', color = I("#0d6efd"), source = "drilldown_plot",
      text = ~Total_Enrollment,
      texttemplate = '%{text:,.0f}',
      textposition = 'outside',
      textfont = list(color = '#000000', size = 10)
    ) %>%
      layout(
        title = "Total Enrollment",
        xaxis = list(title = "Enrollment"), 
        yaxis = list(title = "", autorange = "reversed"),
        showlegend = FALSE,
        uniformtext_minsize=8, uniformtext_mode='show'
      )
  })
  
  output$plotly_teachers <- renderPlotly({
    req(drilldown_data())
    plot_ly(
      drilldown_data(), 
      y = ~group_col, x = ~Total_Teachers,
      type = 'bar', color = I("#3d8bfd"), source = "drilldown_plot",
      text = ~Total_Teachers,
      texttemplate = '%{text:,.0f}',
      textposition = 'outside',
      textfont = list(color = '#000000', size = 10)
    ) %>%
      layout(
        title = "Total Teachers",
        xaxis = list(title = "Teachers"), 
        yaxis = list(title = "", autorange = "reversed"),
        showlegend = FALSE,
        uniformtext_minsize=8, uniformtext_mode='show'
      )
  })
  
  output$plotly_schools <- renderPlotly({
    req(drilldown_data())
    plot_ly(
      drilldown_data(), 
      y = ~group_col, x = ~Total_Schools, 
      type = 'bar', color = I("#6caefd"), source = "drilldown_plot",
      text = ~Total_Schools, 
      texttemplate = '%{text:,.0f}',
      textposition = 'outside',
      textfont = list(color = '#000000', size = 10)
    ) %>%
      layout(
        title = "Total Schools", 
        xaxis = list(title = "Schools"), 
        yaxis = list(title = "", autorange = "reversed"),
        showlegend = FALSE,
        uniformtext_minsize=8, uniformtext_mode='show'
      )
  })
  
  observeEvent(event_data("plotly_click", source = "drilldown_plot"), {
    clicked_value <- event_data("plotly_click", source = "drilldown_plot")$y
    if (is.null(clicked_value)) return()
    state <- current_drilldown()
    if (state$level == "region") {
      current_drilldown(list(level = "division", filter = clicked_value))
    } else if (state$level == "division") {
      current_drilldown(list(level = "district", filter = clicked_value))
    }
    
    # --- MODIFIED: Hide school details when drilling down ---
    shinyjs::hide("school_details_card") 
    selected_school_data(NULL)
  })
  
  observeEvent(input$btn_back, {
    state <- current_drilldown()
    if (state$level == "district") {
      parent_region <- uni %>% 
        filter(Division == state$filter) %>% 
        slice(1) %>% 
        pull(Region)
      current_drilldown(list(level = "division", filter = parent_region))
    } else if (state$level == "division") {
      current_drilldown(list(level = "region", filter = NULL))
    }
    
    # --- MODIFIED: Hide school details when going back ---
    shinyjs::hide("school_details_card")
    selected_school_data(NULL)
  })
  
  observeEvent(current_drilldown(), {
    if (current_drilldown()$level == "region") {
      shinyjs::hide("btn_back")
    } else {
      shinyjs::show("btn_back")
    }
  })
  
  
  # --- Logic for Feature 2 ---
  feature_2_data <- reactiveVal(NULL)
  
  # --- NEW: ReactiveVal to store data for the clicked school ---
  selected_school_data <- reactiveVal(NULL) 
  
  # --- MODIFIED: Load *all* columns needed for the card ---
  observeEvent(uni, {
    if (is.null(feature_2_data())) {
      
      # Define all columns we *want* for the card, based on your image
      all_card_cols <- c(
        "Region", "Province", "Municipality", "Division", "District", "Barangay",
        "Street.Address", "SchoolID", "School.Name", "School.Head",
        "School.Head.Position", "Implementing.Unit", "Modified.Curricular.Offering",
        "Latitude", "Longitude",
        "ES.Excess", "ES.Shortage", "JHS.Excess", "JHS.Shortage", "SHS.Excess", "SHS.Shortage",
        "ES.Teachers", "JHS.Teachers", "SHS.Teachers", "ES.Enrolment", "JHS.Enrolment",
        "SHS.Enrolment", "School.Size.Typology", "AO.II.Deployment", "COS.Deployment",
        "TotalEnrolment" # Also used by map popup
      )
      
      # Filter for valid lat/long first
      valid_geo_data <- uni %>%
        filter(!is.na(Latitude) & !is.na(Longitude) & Latitude != 0 & Longitude != 0)
      
      # IMPORTANT: Check which of our desired columns *actually exist* in the loaded CSV
      # This prevents the app from crashing if "School.Head" or another column is missing
      available_cols <- all_card_cols[all_card_cols %in% names(valid_geo_data)]
      
      # Select only the columns that are available
      sample_data <- valid_geo_data %>%
        select(all_of(available_cols)) %>%
        sample_n(min(10, nrow(.))) # Sample 10 (or fewer if data is small)
      
      feature_2_data(sample_data) 
    }
  })
  
  output$demo_table_2 <- renderDT({
    req(feature_2_data()) 
    datatable(
      feature_2_data()[, c("Region", "Division", "School.Name")], 
      selection = 'single', 
      rownames = FALSE,
      options = list(
        dom = 't',
        # --- MODIFIED: Center all columns in the DT table ---
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ) 
    )
  })
  
  output$demo_map <- renderLeaflet({
    req(feature_2_data())
    data <- feature_2_data()
    
    schoolIcon <- awesomeIcons(
      icon = 'graduation-cap',
      library = 'fa',
      markerColor = 'blue'
    )
    
    leaflet(data) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addAwesomeMarkers(
        lng = ~Longitude, 
        lat = ~Latitude,
        popup = ~School.Name,
        label = ~paste( 
          "<strong>School:</strong>", `School.Name`, "<br>",
          "<strong>Region:</strong>", Region, "<br>",
          "<strong>Division:</strong>", Division, "<br>",
          "<strong>Enrollment:</strong>", TotalEnrolment
        ) %>% lapply(htmltools::HTML),
        icon = schoolIcon,
        labelOptions = labelOptions(noHide = FALSE)
      )
  })
  
  # --- MODIFIED: Observer for table row click ---
  observeEvent(input$demo_table_2_rows_selected, {
    req(input$demo_table_2_rows_selected) 
    
    selected_row_index <- input$demo_table_2_rows_selected
    data <- feature_2_data() 
    selected_school <- data[selected_row_index, ] 
    
    # --- NEW: Store data and show the card ---
    selected_school_data(selected_school) # Store the full data for the selected school
    shinyjs::show("school_details_card")   # Show the hidden div
    # --- END NEW ---
    
    leafletProxy("demo_map") %>%
      flyTo(lng = selected_school$Longitude, 
            lat = selected_school$Latitude, 
            zoom = 12,
            options = list(duration = 0.5))
  })
  
  # (This observer for map zoom is unchanged)
  observeEvent(list(feature_2_data(), input$demo_map_zoom), {
    
    proxy <- leafletProxy("demo_map") %>% clearGroup("zoomed_label")
    data <- feature_2_data()
    zoom <- input$demo_map_zoom
    
    if (!is.null(data) && !is.null(zoom) && zoom >= 12) {
      
      label_content <- paste( 
        "<strong>School:</strong>", data$School.Name, "<br>",
        "<strong>Region:</strong>", data$Region, "<br>",
        "<strong>Enrollment:</strong>", data$TotalEnrolment
      ) %>% lapply(htmltools::HTML)
      
      proxy %>% addLabelOnlyMarkers(
        lng = data$Longitude,
        lat = data$Latitude,
        label = label_content,
        group = "zoomed_label",
        labelOptions = labelOptions(
          noHide = TRUE,
          direction = 'auto',
          textOnly = TRUE,
          style = list(
            "background-color" = "white",
            "border-color" = "blue",
            "border-width" = "1px",
            "border-radius" = "3px",
            "padding" = "5px",
            "font-size" = "10px"
          )
        )
      )
    }
  })
  
  # --- NEW: Render the School Details Card UI ---
  output$school_details_ui <- renderUI({
    # This UI will only render if selected_school_data() is not NULL
    req(selected_school_data())
    school_data <- selected_school_data()
    
    # Helper function to safely get data from the school's record
    # This prevents the app from crashing if a column was missing from the CSV
    get_data <- function(col_name) {
      if (col_name %in% names(school_data)) {
        val <- school_data[[col_name]]
        # Return "N/A" if value is NA or an empty string
        if (is.na(val) || val == "") "N/A" else val
      } else {
        "N/A" # Return "N/A" if the column doesn't exist
      }
    }
    
    # 1. Create the data frame for "Basic Information"
    basic_info_df <- data.frame(
      `Basic Info` = c("Region", "Province", "Municipality", "Division", "District",
                       "Barangay", "Street Address", "School ID", "School Name", "School Head",
                       "School Head Position", "Implementing Unit", "Modified Curricular Offering",
                       "Latitude", "Longitude"),
      Data = c(
        get_data("Region"), get_data("Province"), get_data("Municipality"), get_data("Division"), get_data("District"),
        get_data("Barangay"), get_data("Street.Address"), get_data("SchoolID"), get_data("School.Name"), get_data("School.Head"),
        get_data("School.Head.Position"), get_data("Implementing.Unit"), get_data("Modified.Curricular.Offering"),
        get_data("Latitude"), get_data("Longitude")
      ),
      check.names = FALSE # Allows spaces in the column name "Basic Info"
    )
    
    # 2. Create the data frame for "HR Data"
    hr_data_df <- data.frame(
      `HR Data` = c("ES Excess", "ES Shortage", "JHS Excess", "JHS Shortage", "SHS Excess", "SHS Shortage",
                    "ES Teachers", "JHS Teachers", "SHS Teachers", "ES Enrolment", "JHS Enrolment",
                    "SHS Enrolment", "School Size Typology", "AO II Deployment", "COS Deployment"),
      Data = c(
        get_data("ES.Excess"), get_data("ES.Shortage"), get_data("JHS.Excess"), get_data("JHS.Shortage"), get_data("SHS.Excess"), get_data("SHS.Shortage"),
        get_data("ES.Teachers"), get_data("JHS.Teachers"), get_data("SHS.Teachers"), get_data("ES.Enrolment"), get_data("JHS.Enrolment"),
        get_data("SHS.Enrolment"), get_data("School.Size.Typology"), get_data("AO.II.Deployment"), get_data("COS.Deployment")
      ),
      check.names = FALSE
    )
    
    # 3. Build the UI using tagList, layout_columns, and reactable
    tagList(
      layout_columns(
        col_widths = c(6, 6), # Two equal-width columns
        
        # Card 1: Basic Information
        card(
          card_body(
            padding = 0, # Remove body padding so table fits edge-to-edge
            reactable(
              basic_info_df,
              columns = list(
                `Basic Info` = colDef(
                  # style = list(fontWeight = "bold"), # <-- REMOVED
                  minWidth = 180,
                  align = "center", 
                  headerStyle = list(textAlign = "center", fontWeight = "bold") # <-- MODIFIED
                ), 
                Data = colDef(
                  minWidth = 120, 
                  align = "center",
                  headerStyle = list(textAlign = "center", fontWeight = "bold") # <-- MODIFIED
                ) 
              ),
              striped = TRUE, compact = TRUE, bordered = TRUE,
              pagination = FALSE, # Remove pagination
              fullWidth = TRUE
            )
          )
        ),
        
        # Card 2: HR Data
        card(
          card_body(
            padding = 0,
            reactable(
              hr_data_df,
              columns = list(
                `HR Data` = colDef(
                  # style = list(fontWeight = "bold"), # <-- REMOVED
                  minWidth = 180,
                  align = "center", 
                  headerStyle = list(textAlign = "center", fontWeight = "bold") # <-- MODIFIED
                ),
                Data = colDef(
                  minWidth = 120, 
                  align = "center",
                  headerStyle = list(textAlign = "center", fontWeight = "bold") # <-- MODIFIED
                ) 
              ),
              striped = TRUE, compact = TRUE, bordered = TRUE,
              pagination = FALSE,
              fullWidth = TRUE
            )
          )
        )
      )
    )
  })
  
  
  # --- Logic for Feature 3 (MODIFIED) ---
  
  # Reactive to prepare the data for the reactable table
  feature_3_data <- reactive({
    req(uni)
    uni %>%
      select(
        Region, 
        Division, 
        District, 
        Legislative.District, # Make sure this column name is exact
        School.Name, 
        SchoolID, 
        TotalEnrolment, 
        TotalTeachers
      ) %>%
      mutate(
        TotalEnrolment = as.numeric(TotalEnrolment),
        TotalTeachers = as.numeric(TotalTeachers)
      ) %>%
      # Ensure data has rows before sampling
      { if(nrow(.) > 0) sample_n(., min(500, nrow(.))) else . } # Sample up to 500 rows
  })
  
  # Render the reactable table
  output$feature_3_table <- renderReactable({
    req(feature_3_data())
    reactable(
      feature_3_data(),
      filterable = TRUE, 
      searchable = TRUE, 
      bordered = TRUE,
      highlight = TRUE,
      striped = TRUE,
      compact = TRUE,
      defaultPageSize = 10, 
      defaultSorted = "Region",
      showPageSizeOptions = TRUE,
      pageSizeOptions = c(10, 25, 50, 100), # Allow up to 100 per page
      # --- Center all columns AND headers (This was already correct!) ---
      defaultColDef = colDef(
        align = "center",
        headerStyle = list(textAlign = "center") 
      ) 
    )
  })
  
  # Download handler
  output$download_feature3 <- downloadHandler(
    filename = function() {
      paste0("stride_sample_data_", Sys.Date(), ".csv")
    },
    content = function(file) {
      req(feature_3_data())
      write.csv(feature_3_data(), file, row.names = FALSE, na = "")
    }
  )
  
  
  # --- Logic for Navigation ---
  
  observeEvent(input$btn_to_dashboard, {
    nav_select(id = "main_nav", selected = "dashboard_tab")
  })
  
  
  current_region <- reactiveVal(NULL)
  current_division <- reactiveVal(NULL)
  
  output$backButtonUI <- renderUI({
    # Only show the button if a region is currently selected
    if (!is.null(current_region()) || !is.null(current_division())) {
      actionButton("go_back", "â¬…ï¸ Back")
    }
  })
  
  observeEvent(input$go_back, {
    
    # Step 1: If we are viewing a Division breakdown, go back to the Region breakdown
    if (!is.null(current_division())) {
      current_division(NULL)
      cat("State change: Returned to Region view.\n")
    } 
    
    # Step 2: Else, if we are viewing a Region breakdown, go back to the Overall view
    else if (!is.null(current_region())) {
      current_region(NULL)
      cat("State change: Returned to Overall view.\n")
    }
    
    # Note: You do not need an 'else' block, as the button won't be visible 
    # unless one of these reactive values is set (thanks to renderUI).
  })
  
  # Hide header/footer when not authenticated; show when authenticated
  observe({
    # user_status is defined earlier in your server (values: "unauthenticated", "login", "register", "authenticated")
    if (isTRUE(user_status() == "authenticated")) {
      shinyjs::show("app_header")
      shinyjs::show("app_footer")
    } else {
      shinyjs::hide("app_header")
      shinyjs::hide("app_footer")
    }
  })
  
  
  
  observe({
    mode <- if (user_status() == "authenticated") "app" else "login"
    session$sendCustomMessage("setLoginMode", ifelse(mode == "login", "login", "app"))
  })
  
  observe({
    if (user_status() == "authenticated") {
      shinyjs::show("app_header")
      shinyjs::show("app_footer")
    } else {
      shinyjs::hide("app_header")
      shinyjs::hide("app_footer")
    }
  })
  
  
  output$StrideLogo <- renderImage({
    image_path <- normalizePath(file.path('www', 'STRIDE logo.png'))
    list(
      src = image_path,  # Path relative to the www directory
      contentType = "image/png",
      alt = "STRIDE logo",
      width = "100%",
      height = "auto"
      # You can also set width and height here, e.g., width = 400,
      # or control them in the imageOutput in the UI.
    )
  }, deleteFile = FALSE)
  # deleteFile = FALSE is important for pre-existing static files
  
  
  # Call the shinyauthr::logoutServer module
  # logout_init <- shinyauthr::logoutServer(
  #   id = "logout",
  #   active = reactive(credentials()$user_auth) # Logout button active only when logged in
  # )
  
  ### DRILL DOWN SERVER ###
  # --- Reactive Value for Drill-down State ---
  # (This remains the same)
  # --- Reactive Value for Drill-down State ---
  # Add 'last_clicked_source' to track which plot was clicked
  drilldown_state <- reactiveVal(list(
    region = NULL, 
    division = NULL, 
    legislative_district = NULL,
    last_clicked_source = NULL  # <--- NEW FIELD
  ))
  
  # --- Plotly Source IDs ---
  # (This vector also remains the same)
  # --- Event Handling: CORRECTED APPROACH ---
  
  # This list maps your source IDs to the dataframe they use
  # We'll use this in the table logic later
  source_to_data_map <- list(
    "drilldown_source_1" = "uni",
    "drilldown_source_2" = "LMS",
    "drilldown_source_3" = "LMS",
    "drilldown_source_4" = "df",
    "drilldown_source_5" = "uni"
  )
  
  # Get the names of the sources from the map
  drilldown_sources <- names(source_to_data_map)
  
  # We use lapply to loop over our vector of source IDs.
  lapply(drilldown_sources, function(source_id) {
    
    # Each observer listens to ONE specific source_id
    observeEvent(event_data("plotly_click", source = source_id), {
      
      click_data <- event_data("plotly_click", source = source_id)
      
      if (is.null(click_data) || is.null(click_data$y)) {
        return()
      }
      
      current_state <- drilldown_state()
      
      # --- DRILL-DOWN LOGIC ---
      
      # Level 1: National -> Region
      if (is.null(current_state$region)) {
        drilldown_state(list(
          region = click_data$y,  
          division = NULL, 
          legislative_district = NULL,
          last_clicked_source = source_id  # <--- SET SOURCE
        ))
        
        # Level 2: Region -> Division
      } else if (is.null(current_state$division)) {
        drilldown_state(list(
          region = current_state$region, 
          division = click_data$y,     
          legislative_district = NULL,
          last_clicked_source = source_id  # <--- SET SOURCE
        ))
        
        # Level 3: Division -> Legislative District
      } else if (is.null(current_state$legislative_district)) { 
        drilldown_state(list(
          region = current_state$region,               
          division = current_state$division,           
          legislative_district = click_data$y,
          last_clicked_source = source_id  # <--- SET SOURCE
        ))
      }
      
    }) # End of observeEvent
  }) # End of lapply
  
  
  # --- !!! IMPORTANT: RESET BUTTON !!! ---
  # You must ALSO update your reset button (if you have one)
  # to clear this new state field.
  #
  # observeEvent(input$resetButton, {
  #   drilldown_state(list(
  #     region = NULL, 
  #     division = NULL, 
  #     legislative_district = NULL,
  #     last_clicked_source = NULL  # <--- RESET THIS FIELD
  #   ))
  # })
  
  #hr
  observeEvent(input$reset_hr, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  #basicinfo
  observeEvent(input$reset_basicinfo, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  #infra
  observeEvent(input$reset_infra, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  #financial
  observeEvent(input$reset_financial, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  #monitoring
  observeEvent(input$reset_monitoring, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  #ppas
  observeEvent(input$reset_ppas, {
    state <- drilldown_state()
    
    if (!is.null(state$district)) {
      drilldown_state(list(region = state$region, division = state$division, district = NULL))
    } else if (!is.null(state$division)) {
      drilldown_state(list(region = state$region, division = NULL, district = NULL))
    } else if (!is.null(state$region)) {
      drilldown_state(list(region = NULL, division = NULL, district = NULL))
    }
  })
  
  # --- Reactive Data Filtering ---
  filtered_data_uni_erdb <- reactive({
    state <- drilldown_state()
    data <- uni
    if (!is.null(state$region)) {
      data <- data %>% filter(Region == state$region)
    }
    if (!is.null(state$division)) {
      data <- data %>% filter(Division == state$division)
    }
    data
  })
  
  filtered_data_df_erdb <- reactive({
    state <- drilldown_state()
    data <- df
    if (!is.null(state$region)) {
      data <- data %>% filter(Region == state$region)
    }
    if (!is.null(state$division)) {
      data <- data %>% filter(Division == state$division)
    }
    data
  })
  
  filtered_data_LMS_erdb <- reactive({
    # 1. Access drilldown state and initial data
    state <- drilldown_state()
    data <- LMS 
    
    # 2. Apply filtering based on drilldown state
    if (!is.null(state$region)) {
      data <- data %>% filter(Region == state$region)
    }
    if (!is.null(state$division)) {
      data <- data %>% filter(Division == state$division)
    }
    data
  })
  
  # --- Value Box Rendering using shinydashboard::renderValueBox ---
  
  # Note: Ensure the 'comma' function (likely from the 'scales' package) is available.
  # library(shinydashboard) 
  # library(scales) 
  
  # Corrected and Enhanced renderInfoBox Functions (Server-Side)
  
  # Note: Ensure the 'comma' function (from the 'scales' package) is available.
  # library(shinydashboard) 
  # library(scales) 
  
  # 1. Total Schools
  # Corrected and Enhanced renderValueBox Functions (Server-Side)
  # Note: Requires the 'scales' package for comma()
  
  # Helper function to define the modern value_box without an icon
  make_value_box_no_icon <- function(title, value, color_class, text_color = "#212529") {
    bslib::value_box(
      title = title,
      
      # 1. Make the value significantly bigger and bold
      value = tags$span(value, style = "font-size: 2.5rem; font-weight: bold;"),
      
      # Showcase element (icon) is completely removed here â¬…ï¸
      
      # Use 'full_screen' for a nice aesthetic hover-to-expand feature
      full_screen = TRUE,
      
      # 2. Use 'theme' for the color scheme and text color
      theme = bslib::value_box_theme(bg = color_class, fg = text_color)
    )
  }
  
  # ---------------------------------------------------------------------------
  
  # 1. Total Schools (White box)
  # 1. Total Schools Count
  # 1. Total Schools
  output$total_schools_erdb <- renderUI({
    total <- nrow(filtered_data_uni_erdb())
    
    bslib::card(
      style = "background-color: #FFFFFF;",
      bslib::card_header("Total Schools Count", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(total), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 2. Total Enrolment
  output$total_enrolment_erdb <- renderUI({
    count <- sum(filtered_data_uni_erdb()$TotalEnrolment, na.rm = TRUE)
    
    bslib::card(
      style = "background-color: #FFFFFF;",
      bslib::card_header("Total Student Enrolment", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(count), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 3. Total Classrooms
  output$total_classrooms_erdb <- renderUI({
    count <- sum(filtered_data_LMS_erdb()$Instructional_Rooms, na.rm = TRUE)
    
    bslib::card(
      style = "background-color: #FFFFFF;",
      bslib::card_header("Available Classrooms", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(count), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 4. Total Classroom Shortage (Light Orange Warning)
  output$total_classroom_shortage_erdb <- renderUI({
    shortage <- sum(filtered_data_LMS_erdb()$Estimated_CL_Shortage, na.rm = TRUE)
    
    bslib::card(
      style = "background-color: #FFE5CC;",
      bslib::card_header("Classroom Shortage", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(shortage), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 5. Total Last Mile Schools
  output$total_LMS_erdb <- renderUI({
    count <- filtered_data_LMS_erdb() %>%
      filter(LMS == 1) %>%
      nrow()
    
    bslib::card(
      style = "background-color: #FFFFFF;",
      bslib::card_header("Total Last Mile Schools", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(count), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 6. Total Teacher Shortage (Light Red Critical Warning)
  output$total_teacher_shortage_erdb <- renderUI({
    shortage <- sum(filtered_data_df_erdb()$TeacherShortage, na.rm = TRUE)
    
    bslib::card(
      style = "background-color: #F8D7DA;",
      bslib::card_header("Teacher Shortage", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(shortage), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # 7. School Principal Shortage
  output$SP_Shortage_erdb <- renderUI({
    data_uni <- filtered_data_uni_erdb()
    # Assuming the logic for 'count' remains correct for your purpose
    count <- sum(data_uni$Designation != "School Principal", na.rm = TRUE)
    
    bslib::card(
      # The style here correctly applies to the whole card, including text
      style = "background-color: #FFF3CD; color: #664D03;", 
      bslib::card_header("School Principal Shortage", class = "text-center"),
      bslib::card_body(
        tags$h3(scales::comma(count), style = "text-align: center; font-weight: 700;")
      )
    )
  })
  
  # --- Plot Rendering ---
  
  # Total Schools Plot (Drilldown)
  output$totalschools_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    if (is.null(state$region)) {
      # National View -> Group by Region
      plot_data <- uni %>%
        group_by(Region) %>%
        summarise(TotalSchools = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalSchools, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Region,                # Flipped: Category on Y-axis
        x = ~TotalSchools,          # Flipped: Value on X-axis
        type = 'bar', 
        source = "drilldown_source_1",
        text = ~TotalSchools,       # Added: Text label value
        texttemplate = '%{x:,.0f}', # Added: Format text (comma, 0 decimals)
        textposition = 'outside'    # Added: Place text outside bar
      ) %>%
        layout(
          title = "Total Schools by Region", 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped to xaxis
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped to yaxis, removed tickangle, added autorange
        )
      
    } else if (is.null(state$division)) {
      # Regional View -> Group by Division
      plot_data <- uni %>%
        filter(Region == state$region) %>%
        group_by(Division) %>%
        summarise(TotalSchools = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalSchools, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Division,              # Flipped: Category on Y-axis
        x = ~TotalSchools,          # Flipped: Value on X-axis
        type = 'bar', 
        source = "drilldown_source_1",
        text = ~TotalSchools,       # Added
        texttemplate = '%{x:,.0f}', # Added
        textposition = 'outside'    # Added
      ) %>%
        layout(
          title = paste("Schools in", state$region), 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else {
      # Divisional View -> Group by Legislative District
      plot_data <- uni %>%
        filter(Region == state$region, Division == state$division) %>%
        group_by(Legislative.District) %>%
        summarise(TotalSchools = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalSchools, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Legislative.District,  # Flipped: Category on Y-axis
        x = ~TotalSchools,          # Flipped: Value on X-axis
        type = 'bar',
        text = ~TotalSchools,       # Added
        texttemplate = '%{x:,.0f}', # Added
        textposition = 'outside'    # Added
      ) %>% 
        layout(
          title = paste("Schools in", state$division), 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
    }
    p
  })
  
  # By Curricular Offering (Pie Chart) - No changes
  output$curricular_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    # 1. Filter data based on drill-down state
    plot_data <- if (is.null(state$region)) {
      uni # National view: use all data
    } else if (is.null(state$division)) {
      uni %>% filter(Region == state$region) # Regional view
    } else {
      uni %>% filter(Region == state$region, Division == state$division) # Divisional view
    }
    
    # 2. Generate pie chart data from the (potentially filtered) data
    pie_data <- plot_data %>%
      group_by(Modified.COC) %>%
      summarise(Count = n(), .groups = 'drop')
    
    # 3. Define title based on state
    title_text <- if (is.null(state$region)) {
      "By Curricular Offering (National)"
    } else if (is.null(state$division)) {
      paste("By Curricular Offering (", state$region, ")")
    } else {
      paste("By Curricular Offering (", state$division, ")")
    }
    
    plot_ly(data = pie_data, labels = ~Modified.COC, values = ~Count, type = 'pie', textinfo = 'percent', insidetextorientation = 'radial') %>%
      layout(title = title_text, showlegend = TRUE, xaxis = list(title = "", tickangle = -45))
  })
  
  # By School Size Typology (Bar Chart)
  output$typology_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    # 1. Filter data based on drill-down state (UNCHANGED)
    plot_data <- if (is.null(state$region)) {
      uni # National view
    } else if (is.null(state$division)) {
      uni %>% filter(Region == state$region) # Regional view
    } else {
      uni %>% filter(Region == state$region, Division == state$division) # Divisional view
    }
    
    # 2. Generate bar chart data (UNCHANGED)
    typology_data <- plot_data %>%
      group_by(School.Size.Typology) %>%
      summarise(Count = n(), .groups = 'drop')
    
    max_schools <- max(typology_data$Count, na.rm = TRUE)
    
    # 3. Define title based on state (UNCHANGED)
    title_text <- if (is.null(state$region)) {
      "By School Size (National)"
    } else if (is.null(state$division)) {
      paste("By School Size (", state$region, ")")
    } else {
      paste("By School Size (", state$division, ")")
    }
    
    # 4. Create and customize the plot (MODIFIED)
    plot_ly(
      data = typology_data,
      y = ~School.Size.Typology,  # Flipped: Category on Y-axis
      x = ~Count,                 # Flipped: Value on X-axis
      type = 'bar',
      text = ~Count,              # Added: Use Count for text
      texttemplate = '%{x:,.0f}',  # Added: Format text
      textposition = 'outside',   # Added: Place text outside
      hovertemplate = paste(
        "%{y}, %{x:,}", # Flipped: Use y for category, x for value
        "<extra></extra>" 
      )
    ) %>%
      layout(
        title = title_text,
        yaxis = list(              # Swapped to yaxis
          title = "", categoryorder = "total descending", autorange = "reversed"),
        xaxis = list(              # Swapped to xaxis
          title = "Number of Schools",
          tickformat = ",",
          range = c(0, max_schools *1.15)
        )
      )
  })
  
  # Classroom Shortage Plot
  output$classroomshortage_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    if (is.null(state$region)) {
      # National View -> Group by Region
      plot_data <- LMS %>% # Using base LMS data
        group_by(Region) %>%
        summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Region,                # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar', 
        source = "drilldown_source_2",
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = "Classroom Shortage by Region", 
          xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else if (is.null(state$division)) {
      # Regional View -> Group by Division
      plot_data <- LMS %>% # Using base LMS data
        filter(Region == state$region) %>%
        group_by(Division) %>%
        summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Division,              # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar', 
        source = "drilldown_source_2",
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = paste("Classroom Shortage in", state$region), 
          xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else {
      # Divisional View -> Group by Legislative District
      plot_data <- LMS %>% # Using base LMS data
        filter(Region == state$region, Division == state$division) %>%
        group_by(Legislative.District) %>%
        summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Legislative.District,  # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar',
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>% 
        layout(
          title = paste("Classroom Shortage in", state$division), 
          xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
    }
    p
  })
  
  # LMS Plot
  output$LMS_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    if (is.null(state$region)) {
      # National View -> Group by Region
      plot_data <- LMS %>% # Using base LMS data
        filter(LMS == 1) %>% # Applying original filter
        group_by(Region) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Region,                # Flipped
        x = ~Count,                 # Flipped
        type = 'bar', 
        source = "drilldown_source_3",
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = "LMS by Region", 
          xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else if (is.null(state$division)) {
      # Regional View -> Group by Division
      plot_data <- LMS %>% # Using base LMS data
        filter(LMS == 1, Region == state$region) %>% # Applying filters
        group_by(Division) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Division,              # Flipped
        x = ~Count,                 # Flipped
        type = 'bar', 
        source = "drilldown_source_3",
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = paste("LMS in", state$region), 
          xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else {
      # Divisional View -> Group by Legislative District
      plot_data <- LMS %>% # Using base LMS data
        filter(LMS == 1, Region == state$region, Division == state$division) %>% # Applying filters
        group_by(Legislative.District) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Legislative.District,  # Flipped
        x = ~Count,                 # Flipped
        type = 'bar',
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>% 
        layout(
          title = paste("LMS in", state$division), 
          xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
    }
    p
  })
  
  # Teacher Shortage Plot
  output$teachershortage_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    if (is.null(state$region)) {
      # National View -> Group by Region
      plot_data <- df %>% # Using base df data
        group_by(Region) %>%
        summarise(TotalShortage = sum(TeacherShortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Region,                # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar', 
        source = "drilldown_source_4",
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = "Teacher Shortage by Region", 
          xaxis = list(title = "Total Teacher Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else if (is.null(state$division)) {
      # Regional View -> Group by Division
      plot_data <- df %>% # Using base df data
        filter(Region == state$region) %>%
        group_by(Division) %>%
        summarise(TotalShortage = sum(TeacherShortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Division,              # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar', 
        source = "drilldown_source_4",
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = paste("Teacher Shortage in", state$region), 
          xaxis = list(title = "Total Teacher Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else {
      # Divisional View -> Group by Legislative District
      plot_data <- df %>% # Using base df data
        filter(Region == state$region, Division == state$division) %>%
        group_by(Legislative.District) %>%
        summarise(TotalShortage = sum(TeacherShortage, na.rm = TRUE), .groups = 'drop')
      
      max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Legislative.District,  # Flipped
        x = ~TotalShortage,         # Flipped
        type = 'bar',
        text = ~TotalShortage,      # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>% 
        layout(
          title = paste("Teacher Shortage in", state$division), 
          xaxis = list(title = "Total Teacher Shortage", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
    }
    p
  })
  
  # Principal Shortage Plot
  output$principalshortage_plot_erdb <- renderPlotly({
    state <- drilldown_state()
    
    if (is.null(state$region)) {
      # National View -> Group by Region
      plot_data <- uni %>% # Using base uni data
        filter(Designation != "School Principal") %>% # Applying original filter
        group_by(Region) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Region,                # Flipped
        x = ~Count,                 # Flipped
        type = 'bar', 
        source = "drilldown_source_5",
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = "Schools w/o Principal by Region", 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else if (is.null(state$division)) {
      # Regional View -> Group by Division
      plot_data <- uni %>% # Using base uni data
        filter(Designation != "School Principal", Region == state$region) %>% # Applying filters
        group_by(Division) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Division,              # Flipped
        x = ~Count,                 # Flipped
        type = 'bar', 
        source = "drilldown_source_5",
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>%
        layout(
          title = paste("Schools w/o Principal in", state$region), 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
      
    } else {
      # Divisional View -> Group by Legislative District
      plot_data <- uni %>% # Using base uni data
        filter(Designation != "School Principal", Region == state$region, Division == state$division) %>% # Applying filters
        group_by(Legislative.District) %>%
        summarise(Count = n(), .groups = 'drop')
      
      max_schools <- max(plot_data$Count, na.rm = TRUE)
      
      p <- plot_ly(
        data = plot_data, 
        y = ~Legislative.District,  # Flipped
        x = ~Count,                 # Flipped
        type = 'bar',
        text = ~Count,              # Added
        texttemplate = '%{x:,.0f}',# Added
        textposition = 'outside'   # Added
      ) %>% 
        layout(
          title = paste("Schools w/o Principal in", state$division), 
          xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15)), # Swapped
          yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed") # Swapped
        )
    }
    p
  })
  
  # --- New Reactive Expression ---
  # This reactive holds the data that BOTH the table and map will use.
  # It re-runs whenever the drilldown_state() changes.
  
  filtered_data_for_map_and_table <- reactive({
    
    # 1. Get the current drilldown state
    state <- drilldown_state()
    
    # Get the click source, but provide a default if it's NULL
    click_source <- state$last_clicked_source
    if (is.null(click_source)) {
      click_source <- "default" # Use a default string
    }
    
    # 2. Conditionally select the base dataframe
    data_to_display <- switch(
      click_source,
      "drilldown_source_1" = uni,
      "drilldown_source_2" = LMS,
      "drilldown_source_3" = LMS,
      "drillkey_source_4" = df,
      "drilldown_source_5" = uni,
      uni # Default
    )
    
    # 3. Apply geographic filters (same as before)
    if (!is.null(state$region)) {
      data_to_display <- data_to_display %>%
        filter(Region == state$region)
      
      if (!is.null(state$division)) {
        data_to_display <- data_to_display %>%
          filter(Division == state$division)
        
        if (!is.null(state$legislative_district)) {
          if ("Legislative.District" %in% names(data_to_display)) {
            data_to_display <- data_to_display %>%
              filter(Legislative.District == state$legislative_district)
          } # <--- ADDED: Closing brace for 'if ("Legislative.District" %in% names(data_to_display))'
        } # <--- ADDED: Closing brace for 'if (!is.null(state$legislative_district))'
      } # <--- ADDED: Closing brace for 'if (!is.null(state$division))'
    } # <--- ADDED: Closing brace for 'if (!is.null(state$region))'
    
    # 4. Return the filtered data
    return(data_to_display)
    
  })
  
  # 1. A reactive expression to hold the data filtered by map bounds
  data_within_bounds <- reactive({
    
    # Get the data from your main filters
    full_filtered_data <- filtered_data_for_map_and_table()
    
    # Get the map bounds
    bounds <- input$mapping_erdb_bounds
    
    # Start with the full set
    data_to_display <- full_filtered_data
    
    # Apply the spatial filter IF bounds exist
    if (!is.null(bounds) && nrow(full_filtered_data) > 0) {
      latRng <- range(bounds$north, bounds$south)
      lngRng <- range(bounds$east, bounds$west)
      
      data_to_display <- full_filtered_data %>%
        filter(
          Longitude >= lngRng[1] & Longitude <= lngRng[2],
          Latitude >= latRng[1] & Latitude <= latRng[2]
        )
    }
    
    # Return the filtered data
    return(data_to_display)
    
  })
  
  # --- Updated Data Table ---
  # This now just renders the data from our new reactive
  # 2. Render the data table using the reactive data
  # (This replaces "PART B" from your old observer)
  output$dashboarddt_erdb <- DT::renderDT({
    
    # â­ï¸ Use the reactive expression here!
    data_within_bounds() 
    
  },
  selection = 'single',  
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-left', targets ="_all"))
  ))
  
  output$mapping_erdb <- renderLeaflet({
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 5) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
      addMeasure(position = "topright",
                 primaryLengthUnit = "kilometers",
                 primaryAreaUnit = "sqmeters") %>%
      addLayersControl(baseGroups = c("Satellite", "Road Map"))
  })
  
  # --- New Leaflet Proxy Observer ---
  # This listens for changes to our reactive data and updates the map
  
  # observeEvent(filtered_data_for_map_and_table(), {
  #   
  #   # 1. Get the filtered data
  #   map_data <- filtered_data_for_map_and_table()
  #   
  #   # 2. Check if the data has any rows before trying to plot
  #   if (nrow(map_data) > 0) {
  #     
  #     # Use the first row's coordinates to set the initial view
  #     leafletProxy("mapping_erdb") %>%
  #       clearMarkers() %>%
  #       clearMarkerClusters() %>% # Keep this to ensure old clusters are removed
  #       setView(
  #         lng = map_data$Longitude[1],
  #         lat = map_data$Latitude[1],
  #         zoom = 4.5
  #       ) %>%
  #       addAwesomeMarkers(
  #         lng = map_data$Longitude,
  #         lat = map_data$Latitude,
  #         icon = makeAwesomeIcon(
  #           icon = "education",
  #           library = "glyphicon",
  #           markerColor = "blue"
  #         ),
  #         # â­ï¸ ADDED: This line enables marker clustering
  #         clusterOptions = markerClusterOptions()
  #         # ,
  #         # label = values.comp,
  #         # labelOptions = labelOptions(...)
  #       )
  #     
  #   } else {
  #     # If there's no data, clear the markers and clusters
  #     leafletProxy("mapping_erdb") %>%
  #       clearMarkers() %>%
  #       clearMarkerClusters()
  #   }
  # })
  
  # 3. Observe the reactive data to update map markers
  # (This replaces "PART A" from your old observer)
  # NEW: Observe the MAIN filter reactive to set the "general view"
  observe({
    
    # 1. Get the data from your MAIN filters
    #    (NOT data_within_bounds())
    full_data <- filtered_data_for_map_and_table()
    
    # 2. If there is data, zoom the map to show all of it
    if (nrow(full_data) > 0) {
      leafletProxy("mapping_erdb") %>%
        
        # 3. fitBounds() is better than setView() for this.
        #    It automatically finds the best zoom to show all points.
        fitBounds(
          lng1 = min(full_data$Longitude),
          lat1 = min(full_data$Latitude),
          lng2 = max(full_data$Longitude),
          lat2 = max(full_data$Latitude)
        )
    } else {
      # Optional: If no data, you could clear the bounds
      # or zoom to a default location.
      leafletProxy("mapping_erdb") %>%
        clearBounds()
    }
    
  }) # End of new observe
  
  # REVISED: Observe data_within_bounds to update the MARKERS
  observe({
    
    # Get the data to display from our reactive
    data_to_display <- data_within_bounds()
    
    # Get a proxy for the map
    proxy <- leafletProxy("mapping_erdb", data = data_to_display) %>%
      clearMarkers() %>%
      clearMarkerClusters()
    # âŒ NO setView() or fitBounds() here!
    values.comp <- paste(
      strong("SCHOOL INFORMATION"),
      "<br>School Name:", data_to_display$School.Name,
      "<br>School ID:", data_to_display$SchoolID) %>% lapply(htmltools::HTML)
    # Add markers if we have any data
    if (nrow(data_to_display) > 0) {
      proxy %>%
        addAwesomeMarkers(
          lng = ~Longitude,
          lat = ~Latitude,
          icon = makeAwesomeIcon(
            icon = "education",
            library = "glyphicon",
            markerColor = "blue"
          ),
          label = values.comp,
          clusterOptions = markerClusterOptions()
        )
    }
  }) # End of markers observe
  
  # --- Create reactive values to store the table data ---
  # This goes in your server, but OUTSIDE any observe() or render()
  details_table_1 <- reactiveVal(NULL)
  details_table_2 <- reactiveVal(NULL)
  details_table_3 <- reactiveVal(NULL)
  details_table_4 <- reactiveVal(NULL)
  details_table_5 <- reactiveVal(NULL)
  
  # 4. NEW: Observe a row click to zoom the map
  observeEvent(input$dashboarddt_erdb_rows_selected, {
    
    # 1. Get the selected row index
    selected_row_index <- input$dashboarddt_erdb_rows_selected
    
    # 2. Check if a row is selected
    if (is.null(selected_row_index)) {
      # If deselected, clear all the tables
      details_table_1(NULL)
      details_table_2(NULL)
      details_table_3(NULL)
      details_table_4(NULL)
      details_table_5(NULL)
      return() # Stop here
    }
    
    # 3. Get the data *currently* in the table
    # (which is our reactive data)
    current_table_data <- data_within_bounds()
    
    # 4. Get the specific row that was clicked
    clicked_point <- current_table_data[selected_row_index, ]
    
    # 5. Zoom the map to that point
    if(nrow(clicked_point) > 0) {
      leafletProxy("mapping_erdb") %>%
        setView(
          lng = clicked_point$Longitude,
          lat = clicked_point$Latitude,
          zoom = 15 # â­ï¸ You can adjust this zoom level!
        )
    }
    
    rowselected_table1 <- clicked_point %>% select(Region,Province,Municipality,Division,District,Barangay,Street.Address,SchoolID,School.Name,School.Head.Name,SH.Position,Implementing.Unit,Modified.COC,Latitude,Longitude) %>% rename("Modified Curricular Offering" = Modified.COC, "School ID" = SchoolID, "School Name" = School.Name, "Street Address" = Street.Address, "Implementing Unit" = Implementing.Unit, "School Head" = School.Head.Name,"School Head Position" = SH.Position) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Basic Info",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table2 <- clicked_point %>% select(ES.Excess,ES.Shortage,JHS.Excess,JHS.Shortage,SHS.Excess,SHS.Shortage,ES.Teachers,JHS.Teachers,SHS.Teachers,ES.Enrolment,JHS.Enrolment,SHS.Enrolment,School.Size.Typology,Clustering.Status,Outlier.Status) %>% rename("ES Teachers"=ES.Teachers,"JHS Teachers"=JHS.Teachers,"SHS Teachers"=SHS.Teachers, "ES Enrolment" = ES.Enrolment, "JHS Enrolment" = JHS.Enrolment, "SHS Enrolment" = SHS.Enrolment, "School Size Typology" = School.Size.Typology, "AO II Deployment" = Clustering.Status,"COS Deployment" = Outlier.Status, "ES Shortage" = ES.Shortage,"ES Excess" = ES.Excess,"JHS Shortage" = JHS.Shortage,"JHS Excess" = JHS.Excess,"SHS Shortage" = SHS.Shortage,"SHS Excess" = SHS.Excess) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "HR Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table3 <- clicked_point %>% select(Buildings,Instructional.Rooms.2023.2024,Classroom.Requirement,Est.CS,Buidable_space,Major.Repair.2023.2024,SBPI,Shifting,OwnershipType,ElectricitySource,WaterSource,Total.Seats.2023.2024,Total.Seats.Shortage.2023.2024) %>% rename("With Buildable Space" = Buidable_space,"Number of Instructional Rooms" = Instructional.Rooms.2023.2024,"Classroom Requirement" = Classroom.Requirement,"Ownership Type" = OwnershipType,"Source of Electricity" = ElectricitySource,"Source of Water" = WaterSource,"Estimated Classroom Shortage"= Est.CS,"School Building Priority Index" = SBPI,"For Major Repairs"= Major.Repair.2023.2024,"Total Seats"=Total.Seats.2023.2024,"Total Seats Shortage"=Total.Seats.Shortage.2023.2024, "Number of Buildings"=Buildings) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Classroom Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    
    rowselected_table4 <- clicked_point %>% select(SHA.2021.Index,Travel..Cost,Travel.Time,No.Piped.Water,No.Grid.Electricity,No.Internet,Conflict,TLS) %>% rename("HI 2021" = SHA.2021.Index,"Travel Cost" = Travel..Cost,"Travel Time" = Travel.Time,"No Access to Piped Water" = No.Piped.Water,"No Access to Grid Electricity"= No.Grid.Electricity,"No Access to Internet" = No.Internet,"Incidence of Conflict" = Conflict,"Existence of Temporary Learning Spaces"= TLS) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Other Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table5 <- clicked_point %>% select(English,Mathematics,Science,Biological.Sciences,Physical.Sciences,General.Ed,Araling.Panlipunan,TLE,MAPEH,Filipino,ESP,Agriculture,ECE,SPED) %>% rename("Biological Sciences" = Biological.Sciences,"Physical Sciences" = Physical.Sciences,"General Education" = General.Ed,"Araling Panlipunan" = Araling.Panlipunan,"Early Chilhood Education" = ECE) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Other Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    
    output$schooldetails_erdb <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table1
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails2_erdb <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table2
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails3_erdb <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table3
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails4_erdb <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table4
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails5_erdb <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table5
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
  }) # End of observeEvent
  
  
  
  
  output$Teaching_Deployment_Division_Graph1 <- renderPlotly({
    # --- Use the full dataset ---
    current_filtered_data <- df
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(plotly_empty() %>% 
               layout(title = "No data for selected regions/divisions"))
    }
    
    # --- Prepare data for plotting ---
    plot_data <- current_filtered_data %>%
      group_by(Division) %>%
      summarise(Count = sum(as.numeric(TeacherShortage), na.rm = TRUE), .groups = 'drop') %>%
      arrange(desc(Count)) %>%
      slice_head(n = 20)
    
    # --- Create native Plotly chart ---
    max_count <- max(plot_data$Count, na.rm = TRUE)
    
    p <- plot_ly(
      data = plot_data,
      y = ~reorder(Division, Count), # Division on Y-axis, sorted ascending (plotly reverses)
      x = ~Count,                    # Count on X-axis
      type = 'bar',
      source = "teachingDeploymentDivisionPlot",
      name = "Teacher Shortage",
      # Use Plotly attributes for text labels
      text = ~scales::comma(Count),
      texttemplate = '%{text}',
      textposition = 'outside',
      # Custom hovertext
      hovertemplate = paste(
        "Division: %{y}<br>",
        "Teacher Shortage: %{x:,0f}<extra></extra>"
      )
    ) %>%
      layout(
        title = list(text = "Top 20 Divisions by Teacher Shortage (Teaching Deployment)", 
                     x = 0.5, font = list(size = 14, family = "sans-serif")),
        xaxis = list(title = "Teacher Shortage", tickformat = ",", 
                     range = c(0, max_count * 1.15)),
        yaxis = list(title = "", categoryorder = "total ascending"), # Plotly reverses the order by default
        hoverlabel = list(bgcolor = "white"),
        margin = list(l = 100) # Left margin for division names
      )
    
    return(p)
  })
  
  output$Classroom_Shortage_Division_Graph2 <- renderPlotly({
    # Use the reactive filtered data
    current_filtered_data <- LMS
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(plotly_empty() %>% 
               layout(title = "No data for selected regions/divisions"))
    }
    
    # Prepare the data for plotting
    plot_data <- current_filtered_data %>%
      group_by(Division) %>%
      summarise(Count = sum(as.numeric(Estimated_CL_Shortage), na.rm = TRUE), .groups = 'drop') %>%
      arrange(desc(Count)) %>%
      slice_head(n = 20)
    
    # --- Create native Plotly chart ---
    max_count <- max(plot_data$Count, na.rm = TRUE)
    
    p <- plot_ly(
      data = plot_data,
      y = ~reorder(Division, Count), # Division on Y-axis, sorted ascending
      x = ~Count,                    # Count on X-axis
      type = 'bar',
      source = "classroomShortageRegionPlot",
      name = "Classroom Shortage",
      # Use Plotly attributes for text labels
      text = ~scales::comma(Count),
      texttemplate = '%{text}',
      textposition = 'outside',
      # Custom hovertext
      hovertemplate = paste(
        "Division: %{y}<br>",
        "Classroom Shortage: %{x:,0f}<extra></extra>"
      )
    ) %>%
      layout(
        title = list(text = "Top 20 Divisions by Classroom Shortage", 
                     x = 0.5, font = list(size = 14, family = "sans-serif")),
        xaxis = list(title = "Classroom Shortage", tickformat = ",", 
                     range = c(0, max_count * 1.15)),
        yaxis = list(title = "", categoryorder = "total ascending"),
        hoverlabel = list(bgcolor = "white"),
        margin = list(l = 100)
      )
    
    return(p)
  })
  
  output$LMS_Division_Graph2 <- renderPlotly({
    full_data <- LMS %>%
      rename(
        "With Buildable Space" = Buildable_space,
        "With Excess Classrooms" = With_Excess,
        "Without Classroom Shortage" = Without_Shortage,
        "Last Mile Schools" = LMS,
        "GIDCA" = GIDCA,
        "With Shortage" = With_Shortage
      ) %>%
      pivot_longer(13:18, names_to = "Type", values_to = "Count")
    
    # --- Keep only "Last Mile Schools" and aggregate all regions ---
    plot_data <- full_data %>%
      filter(Type == "Last Mile Schools") %>%
      group_by(Division) %>%
      summarise(
        Count = sum(as.numeric(Count), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      arrange(desc(Count)) %>%
      slice_head(n = 20)
    
    # --- Create native Plotly chart ---
    max_count <- max(plot_data$Count, na.rm = TRUE)
    
    p <- plot_ly(
      data = plot_data,
      y = ~reorder(Division, Count), # Division on Y-axis, sorted ascending
      x = ~Count,                    # Count on X-axis
      type = 'bar',
      source = "LMSDivisionPlot", # Changed source for uniqueness
      name = "Last Mile Schools",
      # Use Plotly attributes for text labels
      text = ~scales::comma(Count),
      texttemplate = '%{text}',
      textposition = 'outside',
      # Custom hovertext
      hovertemplate = paste(
        "Division: %{y}<br>",
        "Count: %{x:,0f}<extra></extra>"
      )
    ) %>%
      layout(
        title = list(text = "Top 20 Divisions by Last Mile Schools", 
                     x = 0.5, font = list(size = 14, family = "sans-serif")),
        xaxis = list(title = "Number of Last Mile Schools", tickformat = ",", 
                     range = c(0, max_count * 1.15)),
        yaxis = list(title = "", categoryorder = "total ascending"),
        hoverlabel = list(bgcolor = "white"),
        margin = list(l = 100)
      ) %>%
      style(hoverinfo = "text")
    
    return(p)
  })
  
  # In your server.R or server function
  
  # --- A. NEW: Create a Reactive Expression for Your Data ---
  # All your data prep logic now lives here.
  # This is efficient because the data is prepped only ONCE
  # and shared by the table and the download button.
  
  priority_data_reactive <- reactive({
    
    # --- Data Preparation (Your existing code) ---
    priority_df <- df %>%
      group_by(Division) %>%
      summarise(Count_TeacherShortage = sum(as.numeric(TeacherShortage), na.rm = TRUE), .groups = 'drop') %>%
      arrange(desc(Count_TeacherShortage)) %>%
      mutate(Rank_TeacherShortage = row_number())
    
    priority_classroom <- LMS %>%
      group_by(Division) %>%
      summarise(Count_ClassroomShortage = sum(as.numeric(Estimated_CL_Shortage), na.rm = TRUE), .groups = 'drop') %>%
      arrange(desc(Count_ClassroomShortage)) %>%
      mutate(Rank_ClassroomShortage = row_number())
    
    priority_SP <- uni %>% 
      filter(Designation != "School Principal") %>% 
      group_by(Division) %>%
      summarise(Count_SPShortage = n(), .groups = 'drop') %>%
      arrange(desc(Count_SPShortage)) %>%
      mutate(Rank_SPShortage = row_number())
    
    priority_LMS <- LMS %>%
      rename(
        "With Buildable Space" = Buildable_space,
        "With Excess Classrooms" = With_Excess,
        "Without Classroom Shortage" = Without_Shortage,
        "Last Mile Schools" = LMS,
        "GIDCA" = GIDCA,
        "With Shortage" = With_Shortage
      ) %>%
      pivot_longer(starts_with(c("With_", "Without_", "Last Mile", "GIDCA")), names_to = "Type", values_to = "Count") %>%
      filter(Type == "Last Mile Schools") %>%
      group_by(Division) %>%
      summarise(
        Count_LastMileSchools = sum(as.numeric(Count), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      arrange(desc(Count_LastMileSchools)) %>%
      mutate(Rank_LastMileSchools = row_number())
    
    combined_df <- full_join(
      priority_df,
      priority_classroom,
      by = "Division"
    )
    
    full_priority_div <- full_join(
      combined_df,
      priority_LMS,
      by = "Division"
    )
    
    data_to_display <- full_join(
      full_priority_div,
      priority_SP,
      by = "Division"
    ) %>%
      left_join(uni %>% select(Region,Division), by = "Division") %>%
      distinct() %>%
      
      # Handle blank/NA Regions
      mutate(Region = if_else(is.na(Region) | Region == "", "BARMM", Region)) %>%
      
      rename(
        "Teacher Shortage" = Count_TeacherShortage,
        "Teacher Shortage Rank" = Rank_TeacherShortage,
        "Classroom Shortage" = Count_ClassroomShortage,
        "Classroom Shortage Rank" = Rank_ClassroomShortage,
        "Last Mile Schools" = Count_LastMileSchools,
        "Last Mile Schools Rank" = Rank_LastMileSchools,
        "School Principal Shortage" = Count_SPShortage,
        "School Principal Shortage Rank" = Rank_SPShortage
      ) %>%
      select(
        Region,
        Division,
        "Teacher Shortage",
        "School Principal Shortage",
        "Classroom Shortage",
        "Last Mile Schools",
        "Teacher Shortage Rank",
        "School Principal Shortage Rank",
        "Classroom Shortage Rank",
        "Last Mile Schools Rank"
      ) %>%
      arrange(Division)
    
    # Return the final data frame
    return(data_to_display)
  })
  
  
  # --- B. MODIFIED: Your renderReactable ---
  # This is now much simpler. It just GETS the data
  # from the reactive expression above.
  
  output$priority_division_erdb <- reactable::renderReactable({
    
    # Get the data from our new reactive expression
    data_to_display <- priority_data_reactive()
    
    # --- Custom Rank Formatting Function (Stays here) ---
    add_rank_suffix <- function(rank) {
      if (is.null(rank) || is.na(rank)) {
        return("-")
      }
      rank_int <- as.integer(rank)
      formatted_rank <- paste0(
        rank_int,
        case_when(
          rank_int %in% c(11, 12, 13) ~ "th",
          rank_int %% 10 == 1 ~ "st",
          rank_int %% 10 == 2 ~ "nd",
          rank_int %% 10 == 3 ~ "rd",
          TRUE ~ "th"
        )
      )
      return(formatted_rank)
    }
    
    # --- reactable Output ---
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(
        reactable::reactable(
          data.frame("Message" = "No data available based on current selection."),
          filterable = FALSE, 
          searchable = FALSE
        )
      )
    }
    
    reactable::reactable(
      data_to_display,
      filterable = TRUE,
      searchable = TRUE,
      defaultPageSize = 15,
      
      # MODIFICATION: Removed 'downloadable = TRUE'
      showPageSizeOptions = TRUE,
      pageSizeOptions = c(15, 25, 50, 100),
      
      sortable = TRUE,
      wrap = TRUE,
      columns = list(
        "Teacher Shortage" = reactable::colDef(na = "-", sortNALast = TRUE, align = "center"),
        "School Principal Shortage" = reactable::colDef(na = "-", sortNALast = TRUE, align = "center"),
        "Classroom Shortage" = reactable::colDef(na = "-", sortNALast = TRUE, align = "center"),
        "Last Mile Schools" = reactable::colDef(na = "-", sortNALast = TRUE, align = "center"),
        "Teacher Shortage Rank" = reactable::colDef(cell = function(value, index) { add_rank_suffix(value) }, sortNALast = TRUE, align = "center", width = 120),
        "School Principal Shortage Rank" = reactable::colDef(cell = function(value, index) { add_rank_suffix(value) }, sortNALast = TRUE, align = "center", width = 120),
        "Classroom Shortage Rank" = reactable::colDef(cell = function(value, index) { add_rank_suffix(value) }, sortNALast = TRUE, align = "center", width = 120),
        "Last Mile Schools Rank" = reactable::colDef(cell = function(value, index) { add_rank_suffix(value) }, sortNALast = TRUE, align = "center", width = 120),
        Region = reactable::colDef(sticky = "left"),
        Division = reactable::colDef(sticky = "left")
      )
    )
  })
  
  # --- C. NEW: Add the downloadHandler ---
  # This powers the button you made in the UI.
  # It uses the SAME reactive data.
  
  output$download_priority_data <- downloadHandler(
    
    # This sets the name of the file the user will download
    filename = function() {
      paste0("priority-division-data-", Sys.Date(), ".csv")
    },
    
    # This function writes the data to the file
    content = function(file) {
      # Get the data from our reactive expression
      data_for_csv <- priority_data_reactive()
      
      # Write the data to the 'file' path
      # NOTE: The downloaded CSV will have the raw data
      # (e.g., numeric ranks "1", "2", not "1st", "2nd")
      # which is usually what users want for export.
      readr::write_csv(data_for_csv, file)
    }
  )
  
  
  output$StrideLogo <- renderImage({
    image_path <- normalizePath(file.path('www', 'STRIDE logo.png'))
    list(
      src = image_path,  # Path relative to the www directory
      contentType = "image/png",
      alt = "STRIDE logo",
      width = "100%",
      height = "auto"
      # You can also set width and height here, e.g., width = 400,
      # or control them in the imageOutput in the UI.
    )
  }, deleteFile = FALSE)
  # deleteFile = FALSE is important for pre-existing static files
  
  
  # Call the shinyauthr::logoutServer module
  # logout_init <- shinyauthr::logoutServer(
  #   id = "logout",
  #   active = reactive(credentials()$user_auth) # Logout button active only when logged in
  # )
  
  
  # # --- Curricular Offering Bar Chart ---
  # output$Curricular_Offering_Bar <- renderPlotly({
  #   data <- data.frame(
  #     Category = c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
  #                  "Purely JHS", "All Offering (K to 12)", "Purely SHS"),
  #     Count = c(35036, 6598, 1690, 1367, 832, 262),
  #     marker = list(color = "#0072B2")
  #   )
  #   
  #   plot_ly(
  #     data,
  #     y = ~Category,  # Flipped
  #     x = ~Count,     # Flipped
  #     type = "bar", 
  #     marker = list(color = "#002D62"),
  #     text = ~Count,              # Added
  #     texttemplate = '%{x:,.0f}',# Added
  #     textposition = 'outside'   # Added
  #   ) |>
  #     layout(
  #       title = list(text = "Curricular Offering Distribution", x = 0.5),
  #       yaxis = list(title = "", autorange = "reversed"), # Swapped, added autorange
  #       xaxis = list(title = "Number of Schools") # Swapped
  #     )
  # })
  # 
  # # --- Curricular Offering Pie Chart --- (No changes)
  # output$Curricular_Offering_Pie <- renderPlotly({
  #   data <- data.frame(
  #     Category = c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
  #                  "Purely JHS", "All Offering (K to 12)", "Purely SHS"),
  #     Count = c(35036, 6598, 1690, 1367, 832, 262),
  #     marker = list(color = "#D9534F")
  #   )
  #   
  #   plot_ly(
  #     data,
  #     labels = ~Category, values = ~Count, type = "pie",
  #     textinfo = "label+percent", insidetextorientation = "radial"
  #   ) |> layout(title = list(text = "Curricular Offering (Pie)", x = 0.5))
  # })
  # 
  # # --- Toggle visibility for Curricular Offering graphs --- (No changes)
  # observeEvent(input$show_curricular_graphs, {
  #   if (input$show_curricular_graphs %% 2 == 1) {
  #     shinyjs::show("curricular_graphs")
  #     updateActionButton(session, "show_curricular_graphs", label = "Hide Graphs")
  #   } else {
  #     shinyjs::hide("curricular_graphs")
  #     updateActionButton(session, "show_curricular_graphs", label = "Show Graphs")
  #   }
  # })
  # 
  # # --- School Size Typology Bar Chart ---
  # output$School_Size_Typology_Bar <- renderPlotly({
  #   data <- data.frame(
  #     Size = c("Very Small", "Small", "Medium", "Large",
  #              "Very Large", "Extremely Large", "Mega"),
  #     Count = c(24976, 10105, 5726, 4210, 727, 38, 3)
  #   )
  #   
  #   plot_ly(
  #     data,
  #     y = ~Size,  # Flipped
  #     x = ~Count, # Flipped
  #     type = "bar", 
  #     marker = list(color = "#0074D9"),
  #     text = ~Count,              # Added
  #     texttemplate = '%{x:,.0f}',# Added
  #     textposition = 'outside'   # Added
  #   ) |>
  #     layout(
  #       title = list(text = "School Size Typology Distribution", x = 0.5),
  #       yaxis = list(            # Swapped
  #         title = "", categoryorder = "total descending", autorange = "reversed"
  #       ), 
  #       xaxis = list(title = "Number of Schools") # Swapped
  #     )
  # })
  # 
  # # --- School Size Typology Pie Chart --- (No changes)
  # output$School_Size_Typology_Pie <- renderPlotly({
  #   data <- data.frame(
  #     Size = c("Very Small", "Small", "Medium", "Large",
  #              "Very Large", "Extremely Large", "Mega"),
  #     Count = c(24976, 10105, 5726, 4210, 727, 38, 3)
  #   )
  #   
  #   plot_ly(
  #     data,
  #     labels = ~Size, values = ~Count,
  #     type = "pie", textinfo = "label+percent",
  #     insidetextorientation = "radial"
  #   ) |> layout(title = list(text = "School Size Typology (Pie)", x = 0.5))
  # })
  # 
  # # --- Curricular Offering Bar Chart ---
  # output$Curricular_Offering_Bar <- renderPlotly({
  #   data <- data.frame(
  #     Category = c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
  #                  "Purely JHS", "All Offering (K to 12)", "Purely SHS"),
  #     Count = c(35036, 6598, 1690, 1367, 832, 262),
  #     marker = list(color = "#0072B2")
  #   )
  #   
  #   plot_ly(
  #     data,
  #     x = ~Category, y = ~Count,
  #     type = "bar", marker = list(color = "#002D62")
  #   ) |>
  #     layout(title = list(text = "Curricular Offering Distribution", x = 0.5),
  #            xaxis = list(title = ""), yaxis = list(title = "Number of Schools"))
  # })
  # 
  # # --- Curricular Offering Pie Chart ---
  # output$Curricular_Offering_Pie <- renderPlotly({
  #   data <- data.frame(
  #     Category = c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
  #                  "Purely JHS", "All Offering (K to 12)", "Purely SHS"),
  #     Count = c(35036, 6598, 1690, 1367, 832, 262),
  #     marker = list(color = "#D9534F")
  #   )
  #   
  #   plot_ly(
  #     data,
  #     labels = ~Category, values = ~Count, type = "pie",
  #     textinfo = "label+percent", insidetextorientation = "radial"
  #   ) |> layout(title = list(text = "Curricular Offering (Pie)", x = 0.5))
  # })
  # 
  # # --- Toggle visibility for Curricular Offering graphs ---
  # observeEvent(input$show_curricular_graphs, {
  #   if (input$show_curricular_graphs %% 2 == 1) {
  #     shinyjs::show("curricular_graphs")
  #     updateActionButton(session, "show_curricular_graphs", label = "Hide Graphs")
  #   } else {
  #     shinyjs::hide("curricular_graphs")
  #     updateActionButton(session, "show_curricular_graphs", label = "Show Graphs")
  #   }
  # })
  # 
  # # --- School Size Typology Bar Chart ---
  # output$School_Size_Typology_Bar <- renderPlotly({
  #   data <- data.frame(
  #     Size = c("Very Small", "Small", "Medium", "Large",
  #              "Very Large", "Extremely Large", "Mega"),
  #     Count = c(24976, 10105, 5726, 4210, 727, 38, 3)
  #   )
  #   
  #   plot_ly(
  #     data,
  #     x = ~Size, y = ~Count,
  #     type = "bar", marker = list(color = "#0074D9")
  #   ) |>
  #     layout(title = list(text = "School Size Typology Distribution", x = 0.5),
  #            xaxis = list(title = ""), yaxis = list(title = "Number of Schools"))
  # })
  # 
  # # --- School Size Typology Pie Chart ---
  # output$School_Size_Typology_Pie <- renderPlotly({
  #   data <- data.frame(
  #     Size = c("Very Small", "Small", "Medium", "Large",
  #              "Very Large", "Extremely Large", "Mega"),
  #     Count = c(24976, 10105, 5726, 4210, 727, 38, 3)
  #   )
  #   
  #   plot_ly(
  #     data,
  #     labels = ~Size, values = ~Count,
  #     type = "pie", textinfo = "label+percent",
  #     insidetextorientation = "radial"
  #   ) |> layout(title = list(text = "School Size Typology (Pie)", x = 0.5))
  # })# --- Authentication ---
  # Call the shinyauthr::loginServer module
  # credentials() will be a reactive returning a tibble with user_auth, info, and additional columns from user_base
  # credentials <- shinyauthr::loginServer(
  #   id = "login",
  #   data = user_base,
  #   user_col = user,
  #   pwd_col = password_hash, # Use the hashed password column
  #   sodium_hashed = TRUE,    # Important: tell shinyauthr we are using sodium hashes
  #   log_out = reactive(logout_init()) # Link to the logout button
  # )
  # 
  # 
  # 
  # # --- Reactive Values & Observers ---
  # # Observe the authentication status
  # observe({
  #   auth_status <- credentials()$user_auth
  #   if (auth_status) {
  #     # User is authenticated. Let's get their details.
  #     user_info <- credentials()$info
  #     # This is a tibble with the user's row
  #     
  #     # Ensure user_info is available and has the username
  #     # (It should if auth_status is TRUE and your user_base is set up correctly)
  #     if (!is.null(user_info) && "user" %in% names(user_info)) {
  #       current_username <- user_info$user # Get the username
  #       
  #       # --- Always hide the login panel when authenticated ---
  #       shinyjs::hide(selector = "#login") # Or shinyjs::hide(id = "login-login_ui")
  #       shinyjs::hide("StrideLogo")
  #       # --- Conditional logic based on username ---
  #       if (current_username == "iamdeped") { # <<<< Your specific username condition
  #         # Authenticated AND username is "user1"
  #         shinyjs::show("main_content")
  #         shinyjs::hide("mgmt_content")
  #       } else {
  #         
  #         if (current_username == "depedadmin") {
  #           # Authenticated BUT username is NOT "user1"
  #           # This could be user2, user3, etc.
  #           shinyjs::show("mgmt_content")
  #           shinyjs::hide("main_content")
  #           # output$generic_secure_data <- renderPrint({"Generic secure data for other users..."})
  #         }}}
  #   } else {
  #     # User is NOT authenticated (e.g., after logout or initially)
  #     shinyjs::show(selector = "#login")
  #     shinyjs::show("StrideLogo")
  #     shinyjs::hide("main_content")
  #     shinyjs::hide("mgmt_content")
  #   }
  #   
  #   if (auth_status) {
  #     shinyjs::runjs('
  #   $("#loading-overlay").fadeIn(200);
  #   document.body.classList.remove("login-bg");
  #   document.body.classList.add("dashboard-bg");
  # ')
  #   } else {
  #     shinyjs::runjs('$("#loading-overlay").hide();')
  #     shinyjs::runjs('document.body.classList.remove("dashboard-bg");')
  #     shinyjs::runjs('document.body.classList.add("login-bg");')
  #   }})
  
  output$STRIDE_data <- renderUI({
    fluidPage(
      theme = bs_theme(
        version = 5,
        base_font = font_google("Poppins")
      ),
      
      # --- CUSTOM CSS FOR FLOATING SIDEBAR ---
      tags$head(
        tags$style(HTML("
     
      #submit:disabled {
        background-color: #cccccc; /* Light gray background */
        border-color: #cccccc;    /* Matching border color */
        color: #666666;          /* Dark gray text for readability */
        cursor: not-allowed;      /* Show a 'not-allowed' mouse cursor */
      }
      .input-error {
        border: 1px solid #dc3545; /* A standard red color */
        box-shadow: 0 0 0.2rem #dc3545; /* Adds a subtle glow */
      }
    "))
      ),
      
      useShinyjs(),
      br(),
      tags$div(
        id = "form_title_bar", # Unique ID for potential custom CSS
        style = "
    background-color: #f0ad4e; /* Deep Blue, matching a professional theme */
    color: white; /* White text for contrast */
    padding: 15px 20px; /* Padding inside the bar */
    margin-bottom: 20px; /* Space below the bar */
    border-radius: 5px; /* Slightly rounded corners for a modern look */
    text-align: center; /* Center the text */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow for depth */
  ",
        h1(
          strong("STRIDE Data Entry Form"),
          style = "
      margin: 0; 
      font-size: 2.5rem;
      /* ðŸ’¡ NEW: Add the text-shadow property here */
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4); 
    "  # Ensure no default margin and use a large font
        )
      ),
      
      div(
        id = "form_container",
        
        sidebarLayout(
          
          # The sidebar panel now contains Step 1
          sidebarPanel(
            id = "sidebar", # ID for the CSS to target
            width = 3,      # Adjust width (out of 12)
            h3(strong("School Profile")),
            hr(),
            textInput("school_id", "School ID", placeholder = "e.g. 193849"),
            textInput("school_name", "School Name:", placeholder = "e.g. Juan Dela Cruz Elementary School"),
            selectInput("stride_region", "Region:",
                        choices = c("--- Select a Region ---" = "", "Region I", "Region II", "Region III", "Region IV-A", "MIMAROPA", "Region V", "Region VI", "NIR", "Region VII", "Region VIII", "Region IX", "Region X", "Region XI", "Region XII", "CARAGA", "CAR", "NCR"),
                        selected = NULL),
            uiOutput("stride_division"),
            selectInput("curricular_offering", "Filter Curricular Offering:",
                        choices = c("--- Select a Curricular Offering ---" = "","Purely ES", "Purely JHS", "Purely SHS", "JHS and SHS", "ES and JHS", "All Offering"),
                        selected = NULL)
          ),
          
          # The main panel contains the rest of the form
          mainPanel(
            width = 9, # Adjusted width to complement sidebar
            accordion(
              id = "form_accordion",
              multiple = FALSE,
              
              accordion_panel(
                title = strong("School Information"),
                value = "step1",
                fluidRow(
                  textInput("school_head_gn", "Given Name (School Head):", placeholder = "Enter Given Name"),
                  textInput("school_head_mn", "Middle Name (School Head):", placeholder = "Enter Middle Name"),
                  textInput("school_head_ln", "Last Name (School Head):", placeholder = "Enter Last Name"),
                  selectInput("school_head_position", "Plantilla Position:",
                              choices = c("School Principal I","School Principal II","School Principal III")),
                  textInput("school_head_contact", "Contact Number", placeholder = "e.g. 09129382923"),
                  textInput("school_head_contact_alt", "Alternative Contact Number", placeholder = "e.g. 09122314424"),
                  textInput("school_head_email", "DepEd Email Address:", placeholder = "e.g. juan.delacruz@deped.gov.ph"),
                  textInput("school_head_email_alt", "Alternative Email Address:", placeholder = "e.g. juan.delacruz@gmail.com")
                )
              ),
              
              accordion_panel(
                title = strong("Enrolment per Grade Level"),
                value = "step2",
                fluidRow(
                  column(4, numericInput("g1","Grade 1", value = "")),
                  column(4, numericInput("g2","Grade 2", value = "")),
                  column(4, numericInput("g3","Grade 3", value = "")),
                  column(4, numericInput("g4","Grade 4", value = "")),
                  column(4, numericInput("g5","Grade 5", value = "")),
                  column(4, numericInput("g6","Grade 6", value = "")),
                  column(4, numericInput("g7","Grade 7", value = "")),
                  column(4, numericInput("g8","Grade 8", value = "")),
                  column(4, numericInput("g9","Grade 9", value = "")),
                  column(4, numericInput("g10","Grade 10", value = "")),
                  column(4, numericInput("g11","Grade 11", value = "")),
                  column(4, numericInput("g12","Grade 12", value = ""))
                )
              ),
              
              accordion_panel(
                title = strong("Organized Classes per Grade Level"),
                value = "step3",
                fluidRow(
                  column(4, numericInput("org_g1","Grade 1", value = "")),
                  column(4, numericInput("org_g2","Grade 2", value = "")),
                  column(4, numericInput("org_g3","Grade 3", value = "")),
                  column(4, numericInput("org_g4","Grade 4", value = "")),
                  column(4, numericInput("org_g5","Grade 5", value = "")),
                  column(4, numericInput("org_g6","Grade 6", value = "")),
                  column(4, numericInput("org_g7","Grade 7", value = "")),
                  column(4, numericInput("org_g8","Grade 8", value = "")),
                  column(4, numericInput("org_g9","Grade 9", value = "")),
                  column(4, numericInput("org_g10","Grade 10", value = "")),
                  column(4, numericInput("org_g11","Grade 11", value = "")),
                  column(4, numericInput("org_g12","Grade 12", value = ""))
                )
              ),
              
              accordion_panel(
                title = strong("Number of Teaching Personnel"),
                value = "step4",
                fluidRow(
                  column(4, numericInput("teaching_elem","Total ES Teachers", value = "")),
                  column(4, numericInput("teaching_jhs","Total JHS Teachers", value = "")),
                  column(4, numericInput("teaching_shs","Total SHS Teachers", value = ""))
                )
              ),
              
              accordion_panel(
                title = strong("School Infrastructure"),
                value = "step5",
                fluidRow(
                  column(4, numericInput("instructional_rooms_es","Number of Classrooms for ES", value = "")),
                  column(4, numericInput("instructional_rooms_jhs","Number of Classrooms for JHS", value = "")),
                  column(4, numericInput("instructional_rooms_shs","Number of Classrooms for SHS", value = "")),
                  column(4, numericInput("instructional_rooms_repair","Number of Classrooms for Repair", value = "")),
                  column(4, numericInput("buildings","Number of Buildings", value = "")),
                  column(4, numericInput("buildings_repair","Number of Buildings for Repair", value = ""))
                )
              ),
              
              accordion_panel(
                title = strong("School Resources"),
                value = "step6",
                fluidRow(
                  column(3, numericInput("laptops","Number of Laptops", value = "")),
                  column(3, numericInput("laptops_repair","Number of Laptops for Repair", value = "")),
                  column(3, numericInput("chairs","Number of Chairs", value = "")),
                  column(3, numericInput("chairs_repair","Number of Chairs for Repair", value = "")),
                  column(3, numericInput("desk","Number of Desks", value = "")),
                  column(3, numericInput("desk_repair","Number of Desks for Repair", value = "")),
                  column(3, numericInput("ecart","Number of e-carts", value = "")),
                  column(3, numericInput("ecart_repair","Number of e-carts for Repair", value = "")),
                  column(3, numericInput("toilet","Number of Toilets", value = "")),
                  column(3, numericInput("toilet_repair","Number of Toilets for Repair", value = "")),
                  column(3, numericInput("printer","Number of Printers", value = "")),
                  column(3, numericInput("printer_repair","Number of Printers for Repair", value = "")),
                  column(3, numericInput("tv","Number of TV", value = "")),
                  column(3, numericInput("tv_repair","Number of TV for Repair", value = "")),
                  column(3, numericInput("science_lab","Number of Science Labs", value = "")),
                  column(3, numericInput("computer_lab","Number of Computer Labs", value = "")),
                  column(3, numericInput("tvl_lab","Number of TVL Labs", value = ""))
                )
              ),
              
              accordion_panel(
                title = strong("Teacher Specialization"),
                value = "step7",
                fluidRow(
                  column(4, numericInput("english","English", value = "")),
                  column(4, numericInput("math","Math", value = "")),
                  column(4, numericInput("science","Science", value = "")),
                  column(4, numericInput("biological_science","Biological Science", value = "")),
                  column(4, numericInput("physical_science","Physical Science", value = "")),
                  column(4, numericInput("general_education","General Education", value = "")),
                  column(4, numericInput("araling_panlipunan","Araling Panlipunan", value = "")),
                  column(4, numericInput("tle","TLE", value = "")),
                  column(4, numericInput("mapeh","MAPEH", value = "")),
                  column(4, numericInput("filipino","Filipino", value = "")),
                  column(4, numericInput("esp","ESP", value = "")),
                  column(4, numericInput("agriculture","Agriculture", value = "")),
                  column(4, numericInput("ece","Early Childhood Education", value = "")),
                  column(4, numericInput("sped","SPED", value = ""))
                )
                # REMOVED: Duplicate submit button was here.
              )
            )
          )
        ),
        
        hr(), # Adds a visual separator
        fluidRow(
          column(
            12,
            align = "center",
            # This is the single, centralized submit button. It's disabled initially.
            actionButton("submit", "Submit Form", class = "btn-success btn-lg", icon = icon("check"), disabled = TRUE)
          )
        ),
        br() # Adds some space at the bottom
      ),
      
      # --- Thank You / Confirmation Section (Hidden by default) ---
      hidden(
        div(
          id = "thank_you_section",
          h3("Thank You! ðŸ‘‹"),
          p("Your submission has been recorded successfully."),
          actionButton("start_over", "Submit Another Response")
        )
      )
    )
  })
  
  output$stride_division <- renderUI({
    filtered_division <- c(df[df$Region==input$stride_region,"Division"])
    
    selectInput(
      inputId = "stride_divisio2",
      label = "Division:",
      choices = c("--- Select Division ---" = "", filtered_division),
      selected = NULL
    )
  })
  
  # Inside server function in Stride1.txt
  
  # Inside server function in Stride1.txt
  
  # Inside server function in Stride1.txt
  
  # Inside server function in Stride1.txt
  
  output$STRIDE2 <- renderUI({
    
    # --- Define the Title/Brand UI Element ---
    navbar_title_ui <- tags$a(
      class = "navbar-brand d-flex align-items-center me-auto",
      href = "#",
      tags$img(src = "logo3.png", height = "87px", style = "margin-right: 9px;
    margin-left: 20px;
    margin-top: 20px;"),
      tags$div(
        tags$img(src = "Stridelogo1.png", height = "74px", style = "margin-right: 9px; padding-top: 9px;"),
        tags$small("Strategic Inventory for Deployment Efficiency", style = "font-size: 17px; color: ##ffb81c; display: block; line-height: 1;")
      )
    ) # End of navbar_title_ui tags$a
    
    # --- Build the page_navbar ---
    page_navbar(
      id = "STRIDE2_navbar",
      title = navbar_title_ui,
      
      theme = bs_theme(
        version = 5,
        bootswatch = "sandstone",
        font_scale = 0.9,
        base_font = font_google("Poppins")
      ) |> bs_add_rules(
        "
      /* --- Make Navbar Sticky at the Top --- */
      .bslib-navbar,
      .navbar {
        position: sticky !important;
        position: -webkit-sticky !important; /* Safari */
        top: 0px !important;                 /* Stick to the very top */
        z-index: 4 !important;
        background-color: #ffffff !important; /* White background */
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important; /* Shadow */
        padding-top: 0.5rem !important;
        padding-bottom: 0.5rem !important;
        border-bottom: 2px solid #dee2e6 !important; /* Add a subtle gray line */
      }

      /* --- Style the Brand/Title Area --- */
      .navbar-brand { padding-top: 0; padding-bottom: 0; }
      .navbar-brand span { color: #003366 !important; text-shadow: 1px 1px 1px rgba(0,0,0,0.1); }
      .navbar-brand small { color: #495057 !important; }

      /* --- Style Navigation Links --- */
      .navbar-nav .nav-link {
        color: #003366 !important; font-weight: 500;
        padding-left: 1rem !important; padding-right: 1rem !important;
        transition: color 0.2s ease, background-color 0.2s ease;
      }
      .navbar-nav .nav-link:hover,
      .navbar-nav .nav-link:focus {
        color: #0056b3 !important; background-color: rgba(0, 51, 102, 0.05); border-radius: 4px;
      }

      /* --- Style Active Navigation Link --- */
      .navbar-nav .nav-link.active {
        color: #D62828 !important; font-weight: 700;
        border-bottom: 3px solid #D62828; background-color: transparent !important;
      }

      /* --- Style Dropdown Menus --- */
      .dropdown-menu { border: none !important; box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important; border-radius: 0 0 8px 8px !important; }
      .dropdown-item { color: #003366 !important; font-weight: 500; }
      .dropdown-item:hover, .dropdown-item:focus { background-color: rgba(0, 51, 102, 0.08) !important; color: #0056b3 !important; }

      /* --- Ensure Right Alignment of Nav Items --- */
      .navbar-collapse { justify-content: flex-end !important; }
      .navbar-nav { margin-left: auto; }

      /* Include other specific rules if needed */
      .nav-tabs .nav-link, .nav-pills .nav-link, .accordion-button { font-weight: bold; }
      .sidebar-title { color: #002D62; font-weight: bold; }
      .sidebar h4 { color: #002D62; font-weight: bold; }

      " # End of CSS string
      ), # End of bs_add_rules
      nav_spacer(),
      
      # --- Navigation Panels and Menus ---
      nav_panel(
        title = tags$b("Home"),
        icon = bs_icon("house-door-fill"),
        value = "home_tab",
        # <<<--- PASTE YOUR HOME PAGE UI CODE (tagList) HERE --->>>
        tagList(
          useShinyjs(),  # Still needed here for this panel's interactivity
          tags$head(
            tags$style(HTML("
    /* =====================================================
       DEPED COLOR THEME
       ===================================================== */
    :root {
      --deped-blue: #003366;
      --deped-gold: #FFB81C;
      --deped-light: #f4f6fa;
      --deped-white: #ffffff;
    }



    /* =====================================================
       SIDEBAR
       ===================================================== */
    .sidebar_erdb {
      width: 260px;
      background: var(--deped-blue);
      color: var(--deped-white);
      padding: 20px;
      border-radius: 0 12px 12px 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      position: sticky;
      top: 60px; /* Adjust top based on navbar height */
      height: calc(100vh - 60px); /* Adjust height based on navbar height */
      flex-shrink: 0;
      overflow-y: auto;
    }

    .sidebar_erdb h4 {
      color: var(--deped-gold);
      font-weight: 700;
      text-align: center;
      margin-bottom: 20px;
    }

    /* =====================================================
       SIDEBAR BUTTONS
       ===================================================== */
    .btn-card {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--deped-white);
      border-radius: 10px;
      text-align: left;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      width: 100%;
      transition: all 0.2s ease-in-out;
    }

    .btn-card:hover,
    .btn-card:focus {
      background: var(--deped-gold) !important;
      color: var(--deped-blue) !important;
      transform: scale(1.02);
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    .btn-card h5 {
      display: inline-block;
      margin-left: 8px;
      font-size: 1.05rem;
      font-weight: 600;
    }



    /* =====================================================
       GLOBAL SCROLLBAR
       ===================================================== */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background:  #003366;
      border-radius: 10px;
    }


  "))
          ),
          # --- MAIN LAYOUT Div ---
          div(
            class = "layout_erdb",
            # --- SIDEBAR Div ---
            div(
              class = "sidebar_erdb",
              h4("Select Category"),
              actionButton("erdb_hr", label = tagList(bs_icon("people-fill", size = 24), tags$h5("Human Resource")), class = "btn-card mb-2"), # source: 187
              actionButton("erdb_school", label = tagList(bs_icon("building", size = 24), tags$h5("Basic Info")), class = "btn-card mb-2"), # source: 187
              actionButton("erdb_infra", label = tagList(bs_icon("tools", size = 24), tags$h5("Infrastructure")), class = "btn-card mb-2"), # source: 188
              actionButton("erdb_financial", label = tagList(bs_icon("currency-dollar", size = 24), tags$h5("Financial")), class = "btn-card mb-2"), # source: 188
              actionButton("erdb_monitoring", label = tagList(bs_icon("graph-up", size = 24), tags$h5("Monitoring")), class = "btn-card mb-2"), # source: 188
              actionButton("erdb_ppas", label = tagList(bs_icon("clipboard-data", size = 24), tags$h5("PPAs")), class = "btn-card mb-2") # source: 188
            ), # End Sidebar Div
            # --- MAIN CONTENT Div ---
            div(
              id = "main_erdb_content",
              uiOutput("dynamic_erdb_panel"), # This will render the content based on sidebar clicks
              class = "main-content-erdb"
            ) # End Main Content Div
          ) # End Main Layout Div
        ) # End tagList for Home content
      ), # End of Home nav_panel - COMMA is correct here
      
      nav_menu(
        title = tagList(bs_icon("speedometer"), tags$b("Dashboard")),
        value = "dashboard_menu",
        nav_panel(
          title = "Education Resource Dashboard",
          
          # --- SIDEBAR + MAIN CONTENT LAYOUT ---
          layout_columns(
            col_widths = c(3, 9),  # Sidebar = 3 cols, Main Content = 9 cols
            
            # --- SIDEBAR SECTION ---
            div(
              class = "sidebar_erdb",
              
              h4("Select Category", class = "text-center mb-3"),
              
              # Sidebar Buttons (Cards)
              div(
                class = "d-grid gap-3",  # Bootstrap spacing for stacked layout
                
                actionButton(
                  "erdb_hr",
                  label = tagList(bs_icon("people", size = 24), tags$h5("Human Resource")),
                  class = "w-100 btn-card"
                ),
                
                actionButton(
                  "erdb_basic",
                  label = tagList(bs_icon("info-circle", size = 24), tags$h5("Basic Information")),
                  class = "w-100 btn-card"
                ),
                
                actionButton(
                  "erdb_infra",
                  label = tagList(bs_icon("building", size = 24), tags$h5("Infrastructure")),
                  class = "w-100 btn-card"
                ),
                
                actionButton(
                  "erdb_fin",
                  label = tagList(bs_icon("currency-exchange", size = 24), tags$h5("Financial")),
                  class = "w-100 btn-card"
                ),
                
                actionButton(
                  "erdb_monitoring",
                  label = tagList(bs_icon("bar-chart-line", size = 24), tags$h5("Monitoring")),
                  class = "w-100 btn-card"
                ),
                
                actionButton(
                  "erdb_ppas",
                  label = tagList(bs_icon("clipboard-check", size = 24), tags$h5("PPAs")),
                  class = "w-100 btn-card"
                )
              )
            ),
            
            # --- MAIN CONTENT AREA (Dynamic) ---
            div(
              class = "main_content_erdb",
              uiOutput("erdb_content")  # Dynamic area that changes based on button clicks
            )
          )
        ),
        
        nav_panel("Plantilla Positions",  #GMIS
                  layout_sidebar(
                    sidebar = sidebar(
                      width = 450,
                      class = "bg-secondary",
                      h6("Data Toggles:"),
                      pickerInput(
                        inputId = "RegionGMIS",
                        label = "Select one or more Regions:",
                        choices = c(
                          "Region I" = "Region I - Ilocos",
                          "Region II" = "Region II - Cagayan Valley",
                          "Region III" = "Region III - Central Luzon",
                          "Region IV-A" = "Region IVA - CALABARZON",
                          "Region IV-B" = "Region IVB - MIMAROPA",
                          "Region V" = "Region V - Bicol",
                          "Region VI" = "Region VI - Western Visayas",
                          "Region VII" = "Region VII - Central Visayas",
                          "Region VIII" = "Region VIII - Eastern Visayas",
                          "Region IX" = "Region IX - Zamboanga Peninsula",
                          "Region X" = "Region X - Northern Mindanao",
                          "Region XI" = "Region XI - Davao",
                          "Region XII" = "Region XII - SOCCSKSARGEN",
                          "CARAGA" = "Region XIII - CARAGA",
                          "CAR" = "Cordillera Administrative Region (CAR)",
                          "NCR" = "National Capital Region (NCR)"
                        ),
                        selected = c(
                          "Region I" = "Region I - Ilocos",
                          "Region II" = "Region II - Cagayan Valley",
                          "Region III" = "Region III - Central Luzon",
                          "Region IV-A" = "Region IVA - CALABARZON",
                          "Region IV-B" = "Region IVB - MIMAROPA",
                          "Region V" = "Region V - Bicol",
                          "Region VI" = "Region VI - Western Visayas",
                          "Region VII" = "Region VII - Central Visayas",
                          "Region VIII" = "Region VIII - Eastern Visayas",
                          "Region IX" = "Region IX - Zamboanga Peninsula",
                          "Region X" = "Region X - Northern Mindanao",
                          "Region XI" = "Region XI - Davao",
                          "Region XII" = "Region XII - SOCCSKSARGEN",
                          "CARAGA" = "Region XIII - CARAGA",
                          "CAR" = "Cordillera Administrative Region (CAR)",
                          "NCR" = "National Capital Region (NCR)"
                        ), # You can set default selected values here
                        multiple = TRUE, # CRITICAL CHANGE: Must be TRUE to enable Select All/Deselect All
                        options = pickerOptions(
                          actionsBox = TRUE, # Already correct
                          liveSearch = TRUE,
                          header = "Select Regions",
                          title = "No Regions Selected",
                          selectedTextFormat = "count > 3",
                          dropupAuto = FALSE,
                          dropup = FALSE
                        ),
                        choicesOpt = list()
                      ),
                      uiOutput("SDOSelectionGMIS"),
                      # pickerInput(
                      #   inputId = "PosCatGMIS",
                      #   label = "Select a Position Category:",
                      #   choices = c(
                      #     "General Civil Servant" = "General Civil Servant",
                      #     "Teaching Related" = "Teaching Related",
                      #     "Allied Medical" = "Allied Medical",
                      #     "Medical" = "Medical",
                      #     "Teaching" = "Teaching"
                      #   ),
                      #   selected = c(
                      #     "Teaching" = "Teaching"
                      #   ),
                      #   multiple = TRUE,
                      #   options = pickerOptions(
                      #     liveSearch = TRUE,
                      #     actionsBox = TRUE, # This adds the "Select All" and "Deselect All" buttons
                      #     title = "No Category Selected",
                      #     header = "Select a Category"
                      #   )
                      # ),
                      uiOutput("PosSelectionGMIS")),
                    # input_task_button("GMISRun", icon_busy = fontawesome::fa_i("refresh", class = "fa-spin", "aria-hidden" = "true"), strong("Show Selection"), class = "btn-danger")),
                    layout_columns(
                      card(
                        card_header(strong("GMIS Data")),
                        plotlyOutput("GMISTable")),
                      card(
                        card_header(strong("GMIS Data")),
                        dataTableOutput("GMISTable1")),
                      col_widths = c(12,12)))), # End of Plantilla nav_panel - COMMA is correct
        nav_panel(
          title = "Infrastructure and Education Facilities",
          layout_sidebar(
            sidebar = sidebar(
              width = 350,
              div( # This div acts as a container for the right-hand filter cards
                card( # Filter by Category
                  card_header("Filter by Category"),
                  height = 400,
                  card_body(
                    pickerInput(
                      inputId = "selected_category",
                      label = NULL,
                      choices = all_categories,
                      selected = all_categories,
                      multiple = TRUE,
                      options = pickerOptions(
                        actionsBox = TRUE,
                        liveSearch = TRUE,
                        header = "Select Categories",
                        title = "No Category Selected",
                        selectedTextFormat = "count > 3",
                        dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                        dropup = FALSE
                      ),
                      choicesOpt = list()
                    )
                  )
                ),
                card( # Filter by Region
                  card_header("Filter by Region"),
                  height = 400,
                  card_body(
                    pickerInput(
                      inputId = "selected_region",
                      label = NULL,
                      choices = all_regions,
                      selected = all_regions,
                      multiple = TRUE,
                      options = pickerOptions(
                        actionsBox = TRUE,
                        liveSearch = TRUE,
                        header = "Select Regions",
                        title = "No Region Selected",
                        selectedTextFormat = "count > 3",
                        dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                        dropup = FALSE
                      ),
                      choicesOpt = list()
                    )
                  )
                ),
                card( # Filter by Division
                  card_header("Filter by Division"),
                  height = 400,
                  card_body(
                    pickerInput(
                      inputId = "selected_division",
                      label = NULL,
                      choices = NULL,
                      selected = NULL,
                      multiple = TRUE,
                      options = pickerOptions(
                        actionsBox = TRUE,
                        liveSearch = TRUE,
                        header = "Select Divisions",
                        title = "No Division Selected",
                        selectedTextFormat = "count > 3",
                        dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                        dropup = FALSE
                      ),
                      choicesOpt = list()
                    )
                  )
                )
              )
            ),
            tagList( # Start of tagList for EFD
              h3("Allocation and Completion Overview"),
              layout_columns( # Start of layout_columns for main content and filters
                col_widths = c(12,12,12,12), # Main content on left (10), Filters on right (2)
                
                # --- LEFT COLUMN: Main Dashboard Content (Value Boxes + Tabs) ---
                # div(
                #   # Value Boxes Section
                #   card(
                #     card_header("Total Allocation per Funding Year"),
                #     layout_columns(
                #       col_widths = 12 / length(unique_funding_years), # Distribute columns evenly
                #       row_heights = 1, # Forces them into a single row
                #       !!!lapply(unique_funding_years, function(year) {
                #         value_box(
                #           title = paste("Total in", year),
                #           value = tags$span(textOutput(paste0("vb_total_alloc_", year)), style = "font-size: 1.5em;"),
                #           showcase = bsicons::bs_icon("cash-coin"),
                #           theme = "primary",
                #           full_screen = TRUE
                #         )
                #       })
                #     )
                #   )),
                
                # Main Content Area (Tabs) - Below Value Boxes
                navset_card_tab(
                  nav_panel("Allocation Overview",
                            layout_columns(
                              card(full_screen = TRUE,
                                   plotlyOutput("allocationStackedBar", height = "100%"),
                                   fill = TRUE, fillable = TRUE, max_height = "auto", height = 500
                              ))),
                  nav_panel("Completion Overview",
                            card(full_screen = TRUE,
                                 plotlyOutput("completionByCategoryPlot", height = "100%"),
                                 fill = TRUE, fillable = TRUE, max_height = "auto", height = 500
                            )))
                , # Added comma to separate navset_card_tab from the next card
                card( # This card contains both the data table and the line graph
                  layout_columns(
                    col_widths = 12,
                    card(
                      card_header("Detailed Project Data for Selected Bar Segment"),
                      DT::dataTableOutput("projectDetailTable", height = "100%"),
                      fill = TRUE, fillable = TRUE, max_height = "auto", height = 700)
                  ),
                  layout_columns(col_widths = 12,
                                 row_heights = "fill",
                                 card(
                                   card_header("Allocation Trend per Category per Funding Year (Line Graph)"),
                                   plotlyOutput("allocationTrendLine", height = "100%"),
                                   fill = TRUE, fillable = TRUE, max_height = "auto", height = 600, full_screen = TRUE
                                 )
                  )
                )
              )
            ) # End of layout_columns for main content and filters
          ) # End of tagList for EFD
        )), # End of Dashboard nav_menu - COMMA is correct here
      
      nav_menu(
        title = tags$b("Data Explorer"),  # Dropdown menu
        icon = bs_icon("table"),
        
        # --- Nav Panel 1: Human Resource Database ---
        nav_panel(
          title = tags$b("Human Resource Database"),
          layout_sidebar(
            sidebar = sidebar(
              width = 350,
              h6("Data Toggles:"),
              
              pickerInput(
                inputId = "DataBuilder_HROD_Region",
                label = "Select a Region:",
                choices = sort(unique(uni$Region)),
                selected = sort(unique(uni$Region)),
                multiple = FALSE,
                options = pickerOptions(
                  actionsBox = TRUE,
                  liveSearch = TRUE,
                  header = "Select Categories",
                  title = "No Category Selected",
                  selectedTextFormat = "count > 3",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              uiOutput("DataBuilder_HROD_SDO"),
              
              pickerInput("School_Data_Toggles", strong("School Information Data Toggles"), 
                          choices = c("School Size Typology" = "School.Size.Typology", 
                                      "Curricular Offering" = "Modified.COC"),
                          multiple = TRUE,
                          options = pickerOptions(
                            `actions-box` = TRUE,
                            dropupAuto = FALSE,
                            dropup = FALSE
                          )
              ),
              
              pickerInput("Teaching_Data_Toggles", strong("Teaching Data Toggles"), 
                          choices = c("Total Teachers" = "TotalTeachers", 
                                      "Teacher Excess" = "Total.Excess", 
                                      "Teacher Shortage" = "Total.Shortage"),
                          multiple = TRUE,
                          options = pickerOptions(
                            `actions-box` = TRUE,
                            dropupAuto = FALSE,
                            dropup = FALSE
                          )
              ),
              
              pickerInput("NTP_Data_Toggles", strong("Non-teaching Data Toggles"), 
                          choices = c("COS" = "Outlier.Status", 
                                      "AOII Clustering Status" = "Clustering.Status"),
                          multiple = TRUE,
                          options = pickerOptions(
                            `actions-box` = TRUE,
                            dropupAuto = FALSE,
                            dropup = FALSE
                          )
              ),
              
              pickerInput("Enrolment_Data_Toggles", strong("Enrolment Data Toggles"), 
                          choices = c("Total Enrolment" = "TotalEnrolment", "Kinder" = "Kinder", 
                                      "Grade 1" = "G1", "Grade 2" = "G2", "Grade 3" = "G3", 
                                      "Grade 4" = "G4", "Grade 5" = "G5", "Grade 6" = "G6", 
                                      "Grade 7" = "G7", "Grade 8" = "G8", 
                                      "Grade 9" = "G9", "Grade 10" = "G10", 
                                      "Grade 11" = "G11", "Grade 12" = "G12"),
                          multiple = TRUE,
                          options = pickerOptions(
                            `actions-box` = TRUE,
                            dropupAuto = FALSE,
                            dropup = FALSE
                          )
              ),
              
              pickerInput("Specialization_Data_Toggles", strong("Specialization Data Toggles"), 
                          choices = c("English" = "English", "Mathematics" = "Mathematics", 
                                      "Science" = "Science", 
                                      "Biological Sciences" = "Biological.Sciences", 
                                      "Physical Sciences" = "Physical.Sciences"),
                          multiple = TRUE,
                          options = pickerOptions(
                            `actions-box` = TRUE,
                            dropupAuto = FALSE,
                            dropup = FALSE
                          )
              )
            ),
            
            layout_columns(
              card(
                card_header(strong("HROD Data Panel")),
                dataTableOutput("HROD_Table")
              ),
              col_widths = c(12, 12)
            )
          )
        ), # End of Human Resource DB nav_panel
        
        
        # --- Nav Panel 2: Infrastructure Database ---
        nav_panel(
          title = tags$b("Infrastructure Database"),
          layout_sidebar(
            sidebar = sidebar(
              width = 350,
              h6("EFD Database Filters:"),
              
              # Region (single select)
              pickerInput(
                inputId = "EFD_Region",
                label = "Select Region:",
                choices = sort(unique(EFDDB$Region)),
                selected = sort(unique(EFDDB$Region))[1],
                multiple = FALSE,
                options = pickerOptions(
                  liveSearch = TRUE,
                  header = "Select Region",
                  title = "No Region Selected",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              # Division (multi-select)
              pickerInput(
                inputId = "EFD_Division",
                label = "Select Division:",
                choices = sort(unique(EFDDB$Division)),
                multiple = TRUE,
                options = pickerOptions(
                  `actions-box` = TRUE,
                  liveSearch = TRUE,
                  header = "Select Division(s)",
                  title = "No Division Selected",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              # Legislative District (multi-select)
              pickerInput(
                inputId = "EFD_LD",
                label = "Select Legislative District:",
                choices = sort(unique(EFDDB$Legislative.District)),
                multiple = TRUE,
                options = pickerOptions(
                  `actions-box` = TRUE,
                  liveSearch = TRUE,
                  header = "Select Legislative District(s)",
                  title = "No Legislative District Selected",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              # EFD Toggles
              pickerInput(
                inputId = "EFD_Toggles",
                label = strong("EFD Data Toggles"),
                choices = names(EFDDB)[!names(EFDDB) %in% c(
                  "Region", "Old.Region", "Division", "SchoolID", "School.Name",
                  "District", "Legislative.District", "Barangay"
                )],
                multiple = TRUE,
                options = pickerOptions(
                  `actions-box` = TRUE,
                  liveSearch = TRUE,
                  header = "Select Data Columns",
                  title = "No Data Column Selected",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              )
            ),
            
            layout_columns(
              card(
                full_screen = TRUE,
                style = "
          width: 100%;
          max-height: 85vh;
          overflow-y: auto;
          margin-bottom: 20px;
        ",
                card_header(
                  strong("EFD Database Panel"),
                  style = "
            font-size: 22px;
            padding: 15px 20px;
            text-align: center;
            background-color: #00234d;
            color: white;
            border-bottom: 2px solid #dee2e6;
          "
                ),
                card_body(
                  div(
                    style = "
              padding: 10px;
              overflow-x: auto;
              height: calc(85vh - 80px);
            ",
                    dataTableOutput("EFD_Table")
                  )
                )
              ),
              col_widths = c(12)
            )
          )
        ),
        nav_panel(
          title = tags$b("DepEd Officials"),
          layout_sidebar(
            sidebar = sidebar(
              width = 350,
              h6("Strand Filter:"),
              pickerInput(
                inputId = "ThirdLevel_Strands",
                label = "Select Strand(s):",
                choices = c(
                  "Administration",
                  "Deped Attached Agencies",
                  "Finance",
                  "Human Resource And Organizational Development",
                  "Learning System",
                  "Legal And Legislative Affairs",
                  "Office Of The Secretary",
                  "Operations",
                  "Procurement",
                  "Strategic Management",
                  "Teachers And Education Council Secretariat"
                ),
                selected = c(
                  "Administration",
                  "Deped Attached Agencies",
                  "Finance",
                  "Human Resource And Organizational Development",
                  "Learning System",
                  "Legal And Legislative Affairs",
                  "Office Of The Secretary",
                  "Operations",
                  "Procurement",
                  "Strategic Management",
                  "Teachers And Education Council Secretariat"
                ),
                multiple = TRUE,
                options = pickerOptions(
                  actionsBox = TRUE,
                  liveSearch = TRUE,
                  header = "Select Strand(s)",
                  title = "No Strand Selected",
                  selectedTextFormat = "count > 3",
                  dropupAuto = FALSE,
                  dropup = FALSE
                ),
                choicesOpt = list(
                  style = "white-space: normal; word-break: break-word; overflow-wrap: break-word;"
                )
              )
            ),
            
            layout_columns(
              card(
                full_screen = TRUE,
                style = "
          width: 100%;
          max-height: 85vh;
          overflow-y: auto;
          margin-bottom: 20px;
        ",
                card_header(
                  strong("HROD Data Panel"),
                  style = "
            font-size: 22px;
            padding: 15px 20px;
            text-align: center;
            background-color: #00234d;
            border-bottom: 2px solid #dee2e6;
          "
                ),
                card_body(
                  div(
                    style = "
              padding: 10px;
              overflow-x: auto;
              height: calc(85vh - 80px);
            ",
                    dataTableOutput("ThirdLevel_Table")
                  )
                )
              ),
              col_widths = c(12)
            )
          )
        )
      ), # End of Data Explorer nav_menu - COMMA is correct here
      
      nav_panel(
        title = tags$b("Quick School Search"),
        icon = bs_icon("search"),
        layout_sidebar(
          sidebar = sidebar(
            textInput("text","Enter School Name"),
            input_task_button("TextRun", icon_busy = fontawesome::fa_i("refresh", class = "fa-spin", "aria-hidden" = "true"), strong("Show Selection"), class = "btn-warning")),
          layout_columns(
            card(
              card_header(strong("Search Output")),
              dataTableOutput("TextTable")),
            card(full_screen = TRUE,
                 card_header(strong("School Mapping")),
                 leafletOutput("TextMapping", height = 500, width = "100%")),
            card(full_screen = TRUE,
                 card_header(div(strong("School Details"),
                                 tags$span(em("(Select a school from the table above)"),
                                           style = "font-size: 0.7em; color: grey;"
                                 ))),
                 layout_columns(
                   card(full_screen = TRUE,
                        card_header(strong("Basic Information")),
                        tableOutput("schooldetails")),
                   card(full_screen = TRUE,
                        card_header(strong("HR Data")),
                        tableOutput("schooldetails2")),
                   card(full_screen = TRUE,
                        card_header(strong("Classroom Data")),
                        tableOutput("schooldetails3")),
                   card(full_screen = TRUE,
                        card_header(div(strong("Specialization Data"),
                                        tags$span(em("(based on eSF7 for SY 2023-2024)"),
                                                  style = "font-size: 0.7em; color: grey;"
                                        ))),
                        tableOutput("schooldetails5")),
                   col_widths = c(6,6,6,6))),
            col_widths = c(6,6,12)))), # End of Quick Search nav_panel - COMMA is correct here
      
      nav_panel(
        title = tags$b("Resource Mapping"),
        icon = bs_icon("map"),
        layout_sidebar(
          sidebar = sidebar(
            width = 375,
            title = "Resource Mapping Filters",
            
            # --- Data Filters Card for Resource Mapping ---
            card(
              height = 400,
              card_header(tags$b("Data Filters")),
              
              # Region Picker
              pickerInput(
                inputId = "resource_map_region",
                label = "Region:",
                choices = c(
                  "Region I" = "Region I","Region II" = "Region II","Region III" = "Region III",
                  "Region IV-A" = "Region IV-A","MIMAROPA" = "MIMAROPA","Region V" = "Region V",
                  "Region VI" = "Region VI","NIR" = "NIR","Region VII" = "Region VII",
                  "Region VIII" = "Region VIII","Region IX" = "Region IX","Region X" = "Region X",
                  "Region XI" = "Region XI","Region XII" = "Region XII","CARAGA" = "CARAGA",
                  "CAR" = "CAR","NCR" = "NCR"
                ),
                selected = "Region I",
                multiple = FALSE,
                options = list(
                  `actions-box` = FALSE,
                  `none-selected-text` = "Select a region",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              # Division Picker
              pickerInput(
                inputId = "Resource_SDO",
                label = "Select a Division:",
                choices = NULL,
                selected = NULL,
                multiple = FALSE,
                options = list(
                  `actions-box` = FALSE,
                  `none-selected-text` = "Select a division",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              # District Picker
              pickerInput(
                inputId = "Resource_LegDist",
                label = "Select Legislative District(s):",
                choices = NULL,
                selected = NULL,
                multiple = TRUE,
                options = list(
                  `actions-box` = TRUE,
                  `none-selected-text` = "Select one or more districts",
                  dropupAuto = FALSE,
                  dropup = FALSE
                )
              ),
              
              input_task_button("Mapping_Run", strong("Show Selection"), class = "btn-warning")
            ),
            
            hr(),
            
            # Resource Types
            card(
              card_header(tags$b("Resource Types")),
              radioButtons(
                inputId = "resource_type_selection",
                label = NULL,
                choices = c(
                  "Teaching Deployment",
                  "Non-teaching Deployment",
                  "Classroom Inventory",
                  "Learner Congestion",
                  "Industries",
                  "Facilities",
                  "Last Mile School"
                ),
                selected = "Teaching Deployment"
              )
            )
          ),
          
          # Main Panel
          mainPanel(
            width = 12,
            uiOutput("dynamic_resource_panel")
          )
        )
      ), # End of Mapping nav_panel - COMMA is correct here
      
      nav_menu(
        title = tagList(bs_icon("cloud"),
                        tags$b("CLOUD")),
        
        nav_panel(
          title = "CLOUD (Regional Profile)", # Your existing HROD content
          layout_columns( # Main sidebar title
            # Card for Main Category Picker (combining General Info, Resource Shortage, Other)
            # Assuming this UI code is part of your sidebar or main UI definition
            # Region Filter
            card(height = 300, # Adjusted height
                 card_header(tags$b("Region Filter")),
                 card_body( # Added card_body
                   pickerInput(
                     inputId = "cloud_region_profile_filter", # Keep the same inputId for server compatibility
                     label = NULL,
                     choices = c("Region II" = "Region II", "MIMAROPA" = "MIMAROPA", "Region XII" = "Region XII", "CAR" = "CAR"),
                     selected = "Region II", # Keep the same default selected value
                     multiple = FALSE,
                     options = pickerOptions(
                       actionsBox = TRUE, # Changed to TRUE
                       liveSearch = TRUE,
                       header = "Select Regions", # Changed header text
                       title = "No Region Selected", # Changed title text
                       selectedTextFormat = "count > 3",
                       dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                       dropup = FALSE # Added this option
                     ),
                     choicesOpt = list() # Added choicesOpt
                   )
                 )
            )
            # 
            # # Division Filter
            # card(height = 400, # Adjusted height
            #      card_header(tags$b("Division Filter")),
            #      card_body( # Added card_body
            #        pickerInput(
            #          inputId = "cloud_dashboard_division_filter", # Keep the same inputId for server compatibility
            #          label = NULL,
            #          choices = NULL, # Choices will be updated dynamically by the server
            #          selected = NULL,
            #          multiple = FALSE,
            #          options = pickerOptions(
            #            actionsBox = TRUE, # Changed to TRUE
            #            liveSearch = TRUE,
            #            header = "Select Divisions", # Changed header text
            #            title = "No Division Selected", # Changed title text
            #            selectedTextFormat = "count > 3",
            #            dropupAuto = FALSE, # This tells it NOT to automatically switch direction
            #            dropup = FALSE # Added this option
            #          ),
            #          choicesOpt = list() # Added choicesOpt
            #        )
            #      )
            # )
          ), # End of sidebar
          # Main content for Dashboard tab, controlled by uiOutput
          uiOutput("cloud_profile_main_content_area") # End of layout_sidebar
        ), # End of nav_panel("HROD") # End of CLOUD Regional nav_panel - COMMA is correct
        nav_panel(
          title = "CLOUD (SDO Breakdown)", # Your existing HROD content
          layout_sidebar(
            sidebar = sidebar(
              width = 350, # Keep the sidebar width
              title = "Dashboard Navigation", # Main sidebar title
              
              # Card for Main Category Picker (combining General Info, Resource Shortage, Other)
              # Assuming this UI code is part of your sidebar or main UI definition
              
              card(height = 400, # Adjusted height to 500
                   card_header(tags$b("Select Category")),
                   card_body( # Wrapped pickerInput in card_body
                     pickerInput(
                       inputId = "cloud_main_category_picker",
                       label = NULL,
                       choices = c(
                         "Enrolment Data" = "cloud_enrolment",
                         "SNED Learners" = "cloud_sned",
                         "IP Learners" = "cloud_ip",
                         "Muslim Learners" = "cloud_muslim",
                         "Displaced Learners" = "cloud_displaced",
                         "ALS Learners" = "cloud_als",
                         "Dropout Data" = "cloud_dropout",
                         "Teacher Inventory" = "cloud_teacherinventory",
                         "Years in Service" = "cloud_years",
                         "Classroom Inventory" = "cloud_classroom",
                         "Multigrade" = "cloud_multigrade",
                         "Organized Class" = "cloud_organizedclass",
                         "JHS Teacher Deployment" = "cloud_jhsdeployment",
                         "Shifting" = "cloud_shifting",
                         "Learning Delivery Modality" = "cloud_LDM",
                         "ARAL" = "cloud_ARAL",
                         "CRLA" = "cloud_crla",
                         "PhilIRI" = "cloud_philiri",
                         "Alternative Delivery Modality" = "cloud_adm",
                         "Reading Proficiency" = "cloud_rf",
                         "Electricity Source" = "cloud_elec",
                         "Water Source" = "cloud_water",
                         "Internet Source" = "cloud_internet",
                         "Internet Usage" = "cloud_internet_usage",
                         "Bullying Incidence" = "cloud_bully",
                         # "School Initiatives" = "cloud_initiatives",
                         # "Medium of Instruction" = "cloud_moi",
                         # "School Structure" = "cloud_sosss",
                         # "SHS Implementation" = "cloud_shsimplem",
                         "Overload Pay" = "cloud_overload",
                         "School Resources" = "cloud_resources",
                         "NAT" = "cloud_nat",
                         "NAT Sufficiency" = "cloud_nat_sufficiency",
                         "LAC" = "cloud_lac",
                         "Feeding Program" = "cloud_feeding",
                         "SHA" = "cloud_sha"
                         # "Child Protection" = "cloud_childprotection",
                         # "Extension" = "cloud_extension"
                       ),
                       selected = "general_school_count", # Keep the default selected value
                       multiple = FALSE, # Keep as FALSE for single selection
                       options = pickerOptions(
                         actionsBox = FALSE, # Keep as FALSE as it's single select
                         liveSearch = TRUE,
                         header = "Select a Category", # Keep existing header
                         title = "Select Category",
                         dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                         dropup = FALSE # Keep existing title
                         # selectedTextFormat is not applicable for multiple = FALSE, so it's not added
                       ),
                       choicesOpt = list() # Added choicesOpt = list() for consistency
                     )
                   )
              ),
              
              hr(), # Add a separator
              
              # Card for Region Picker
              # Assuming this UI code is part of your sidebar or main UI definition
              
              # Region Filter
              card(height = 400, # Adjusted height
                   card_header(tags$b("Region Filter")),
                   card_body( # Added card_body
                     pickerInput(
                       inputId = "cloud_region_filter", # Keep the same inputId for server compatibility
                       label = NULL,
                       choices = c("Region II" = "Region II", "MIMAROPA" = "MIMAROPA", "Region XII" = "Region XII", "CAR" = "CAR"),
                       selected = "Region II", # Keep the same default selected value
                       multiple = FALSE,
                       options = pickerOptions(
                         actionsBox = TRUE, # Changed to TRUE
                         liveSearch = TRUE,
                         header = "Select Regions", # Changed header text
                         title = "No Region Selected", # Changed title text
                         selectedTextFormat = "count > 3",
                         dropupAuto = FALSE, # This tells it NOT to automatically switch direction
                         dropup = FALSE # Added this option
                       ),
                       choicesOpt = list() # Added choicesOpt
                     )
                   )
              )
              # 
              # # Division Filter
              # card(height = 400, # Adjusted height
              #      card_header(tags$b("Division Filter")),
              #      card_body( # Added card_body
              #        pickerInput(
              #          inputId = "cloud_dashboard_division_filter", # Keep the same inputId for server compatibility
              #          label = NULL,
              #          choices = NULL, # Choices will be updated dynamically by the server
              #          selected = NULL,
              #          multiple = FALSE,
              #          options = pickerOptions(
              #            actionsBox = TRUE, # Changed to TRUE
              #            liveSearch = TRUE,
              #            header = "Select Divisions", # Changed header text
              #            title = "No Division Selected", # Changed title text
              #            selectedTextFormat = "count > 3",
              #            dropupAuto = FALSE, # This tells it NOT to automatically switch direction
              #            dropup = FALSE # Added this option
              #          ),
              #          choicesOpt = list() # Added choicesOpt
              #        )
              #      )
              # )
            ), # End of sidebar
            # Main content for Dashboard tab, controlled by uiOutput
            uiOutput("cloud_main_content_area")
          ) # End of layout_sidebar
        ), # End of nav_panel("HROD")
        nav_panel(
          title = tagList("CLOUD", em("(Multi-variable)")), # Your existing HROD content
          
          # A fluidRow to contain the three main boxes
          fluidRow(
            # First Box
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 1")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_1",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_enrolment",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_1") # Placeholder for the first graph
                )
              )
            ),
            
            # Second Box
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 2")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_2",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_teacherinventory",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_2") # Placeholder for the second graph
                )
              )
            ),
            
            # Third Box
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 3")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_3",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_classroom",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_3") # Placeholder for the third graph
                )
              )
            ),
            # Fourth Box
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 4")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_4",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_shifting",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_4") # Placeholder for the third graph
                )
              )
            ),
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 5")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_5",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_enrolment",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_5") # Placeholder for the first graph
                )
              )
            ),
            column(
              width = 6,
              card(
                card_header(tags$b("Data View 6")),
                card_body(
                  pickerInput(
                    inputId = "cloud_category_picker_6",
                    label = NULL,
                    choices = c(
                      "Enrolment Data" = "cloud_enrolment",
                      "SNED Learners" = "cloud_sned",
                      "IP Learners" = "cloud_ip",
                      "Muslim Learners" = "cloud_muslim",
                      "Displaced Learners" = "cloud_displaced",
                      "ALS Learners" = "cloud_als",
                      "Dropout Data" = "cloud_dropout",
                      "Teacher Inventory" = "cloud_teacherinventory",
                      "Years in Service" = "cloud_years",
                      "Classroom Inventory" = "cloud_classroom",
                      "Multigrade" = "cloud_multigrade",
                      "Organized Class" = "cloud_organizedclass",
                      "JHS Teacher Deployment" = "cloud_jhsdeployment",
                      "Shifting" = "cloud_shifting",
                      "Learning Delivery Modality" = "cloud_LDM",
                      "ARAL" = "cloud_ARAL",
                      "CRLA" = "cloud_crla",
                      "PhilIRI" = "cloud_philiri",
                      "Alternative Delivery Modality" = "cloud_adm",
                      "Reading Proficiency" = "cloud_rf",
                      "Electricity Source" = "cloud_elec",
                      "Water Source" = "cloud_water",
                      "Internet Source" = "cloud_internet",
                      "Internet Usage" = "cloud_internet_usage",
                      "Bullying Incidence" = "cloud_bully",
                      # "School Initiatives" = "cloud_initiatives",
                      # "Medium of Instruction" = "cloud_moi",
                      # "School Structure" = "cloud_sosss",
                      # "SHS Implementation" = "cloud_shsimplem",
                      "Overload Pay" = "cloud_overload",
                      "School Resources" = "cloud_resources",
                      "NAT" = "cloud_nat",
                      "NAT Sufficiency" = "cloud_nat_sufficiency",
                      "LAC" = "cloud_lac",
                      "Feeding Program" = "cloud_feeding",
                      "SHA" = "cloud_sha"
                      # "Child Protection" = "cloud_childprotection",
                      # "Extension" = "cloud_extension"
                    ),
                    selected = "cloud_enrolment",
                    multiple = FALSE,
                    options = pickerOptions(
                      liveSearch = TRUE,
                      title = "Select Category"
                    )
                  ),
                  uiOutput("cloud_graph_6") # Placeholder for the first graph
                )
              )
            )
          ))), # End of CLOUD nav_menu - COMMA is correct here
      
      nav_panel(
        title = tags$b("Contact Us"),
        icon = bs_icon("envelope"),
        h3("Contact Information"),
        fluidRow(
          column(12,
                 tags$iframe(
                   id = "googleform",
                   src = "https://docs.google.com/forms/d/e/1FAIpQLScmWmVzlAHgsitxUncINy4OC_5gkyg2LvYcJAkAGlGAzQHNvw/viewform?embedded=true", # Replace YOUR_FORM_ID
                   width = "100%", # Or a specific pixel value like "760"
                   height = "700px", # Or a specific pixel value like "500"
                   frameborder = "0",
                   marginheight = "0",
                   marginwidth = "0")
          )
        )
      ), # End of Contact Us nav_panel - COMMA is correct here
      
      # nav_spacer(), # COMMA is correct here
      # 
      # nav_item(
      #   tags$button(
      #     id = "main_app-logout",
      #     class = "btn btn-danger btn-sm",
      #     bs_icon("box-arrow-right"), "Log Out"
      #   )
      # ) # End of Logout nav_item - NO COMMA needed as it's the LAST item overall
      
    ) # End page_navbar
  }) # End renderUI
  
  #   # --- Scroll to and open the corresponding accordion when a card is clicked ---
  #   # ================================================================
  #   # ========== CARD CLICK ACTIONS (scroll + open exact accordion) ==========
  #   # ================================================================
  #   
  #   observeEvent(input$select_hr, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#hr_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#hr_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   observeEvent(input$select_school, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#school_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#school_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   observeEvent(input$select_classroom, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#classroom_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#classroom_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   observeEvent(input$select_financial, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#financial_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#financial_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   observeEvent(input$select_monitoring, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#monitoring_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#monitoring_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   observeEvent(input$select_ppas, {
  #     runjs("
  #     $('#home_accordion .accordion-collapse').removeClass('show');
  #     $('#home_accordion .accordion-button').addClass('collapsed').attr('aria-expanded', 'false');
  #     var section = $('#ppas_section').closest('.accordion-collapse');
  #     var header = section.prev('.accordion-header').find('.accordion-button');
  #     section.addClass('show');
  #     header.removeClass('collapsed').attr('aria-expanded', 'true');
  #     $('html, body').animate({ scrollTop: $('#ppas_section').offset().top - 100 }, 600);
  #   ")
  #   })
  #   
  #   # ================================================================
  #   # ========== BACK TO TOP BUTTON BEHAVIOR ==========
  #   # ================================================================
  #   
  # 
  #   observeEvent(input$scroll_top, {
  #     runjs("window.scrollTo({ top: 0, behavior: 'smooth' });")
  #   })
  #   
  #   # ================================================================
  #   # ========== DRILLDOWN SOURCES (HOME PANEL INCLUDED) ==========
  #   # ================================================================
  #   
  #   source_to_data_map <- list(
  #     "drilldown_source_1" = "uni",
  #     "drilldown_source_2" = "LMS",
  #     "drilldown_source_3" = "LMS",
  #     "drilldown_source_4" = "df",
  #     "drilldown_source_5" = "uni",
  #     
  #     # ðŸ†• Home Panel Sources
  #     "drilldown_source_home" = "uni",          # Total Schools
  #     "drilldown_source_home_LMS" = "LMS",      # Last Mile Schools
  #     "drilldown_source_home_infra" = "LMS"     # Classroom Shortage
  #   )
  #   
  #   drilldown_sources <- names(source_to_data_map)
  #   
  #   # --- Track Region / Division / District
  #   drilldown_state <- reactiveVal(list(region = NULL, division = NULL, district = NULL))
  #   
  #   lapply(drilldown_sources, function(source_id) {
  #     observeEvent(event_data("plotly_click", source = source_id), {
  #       click_data <- event_data("plotly_click", source = source_id)
  #       if (!is.null(click_data)) {
  #         y_val <- click_data$y
  #         
  #         # ðŸ§­ Region â†’ Division â†’ District
  #         state <- drilldown_state()
  #         
  #         if (is.null(state$region)) {
  #           # First click = Region
  #           drilldown_state(list(region = y_val, division = NULL, district = NULL))
  #           
  #         } else if (is.null(state$division)) {
  #           # Second click = Division
  #           drilldown_state(list(region = state$region, division = y_val, district = NULL))
  #           
  #         } else if (is.null(state$district)) {
  #           # Third click = District
  #           drilldown_state(list(region = state$region, division = state$division, district = y_val))
  #           
  #         } else {
  #           # Reset (after 3 levels)
  #           drilldown_state(list(region = NULL, division = NULL, district = NULL))
  #         }
  #       }
  #     })
  #   })
  #   
  #   
  #   # ================================================================
  # # ========== FINANCIAL PLACEHOLDERS (UI ONLY) ============
  # # ================================================================
  # 
  # output$fin_total_budget_allocation <- renderUI({
  #   bslib::card(
  #     style = "background-color: #FFFFFF;",
  #     bslib::card_header("Total Budget Allocation", class = "text-center"),
  #     bslib::card_body(
  #       tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #     )
  #   )
  # })
  # 
  # output$fin_total_mooe_utilization <- renderUI({
  #   bslib::card(
  #     style = "background-color: #FFFFFF;",
  #     bslib::card_header("Total MOOE Utilization", class = "text-center"),
  #     bslib::card_body(
  #       tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #     )
  #   )
  # })
  # 
  # output$fin_total_capital_outlay <- renderUI({
  #   bslib::card(
  #     style = "background-color: #FFFFFF;",
  #     bslib::card_header("Total Capital Outlay", class = "text-center"),
  #     bslib::card_body(
  #       tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #     )
  #   )
  # })
  #   # ================================================================
  #   # ========== HUMAN RESOURCE PLACEHOLDERS (UI ONLY) ============
  #   # ================================================================
  #   
  #   output$hr_total_central_office <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of Central Office Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   
  #   output$hr_total_ro_personnel <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of RO Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   
  #   output$hr_total_sdo_personnel <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of SDO Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   
  #   output$hr_total_teaching_personnel <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of Teaching Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   
  #   output$hr_total_nonteaching_personnel <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of Non-teaching Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   
  #   output$hr_total_teaching_related_personnel <- renderUI({
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of Teaching-related Personnel", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3("â€”", style = "text-align: center; font-weight: 700; color: #999;")
  #       )
  #     )
  #   })
  #   # ================================================================
  #   # ========== INFRASTRUCTURE VALUE BOXES (HOME) ============
  #   # ================================================================
  #   
  #   # 1. Total Number of Classrooms
  #   output$total_classrooms_home <- renderUI({
  #     total <- sum(filtered_data_LMS_erdb()$Instructional_Rooms, na.rm = TRUE)
  #     
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Number of Classrooms", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(scales::comma(total), style = "text-align: center; font-weight: 700;")
  #       )
  #     )
  #   })
  #   
  #   # 2. Total Number of Schools with Classroom Shortage
  #   output$schools_with_shortage_home <- renderUI({
  #     shortage_count <- filtered_data_LMS_erdb() %>%
  #       filter(Estimated_CL_Shortage > 0) %>%
  #       nrow()
  #     
  #     bslib::card(
  #       style = "background-color: #FFE5CC;",
  #       bslib::card_header("Schools with Classroom Shortage", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(scales::comma(shortage_count), style = "text-align: center; font-weight: 700;")
  #       )
  #     )
  #   })
  #   
  #   # 3. Total Number of Schools with Classroom Excess
  #   output$schools_with_excess_home <- renderUI({
  #     excess_count <- filtered_data_LMS_erdb() %>%
  #       filter(Estimated_CL_Excess > 0) %>%
  #       nrow()
  #     
  #     bslib::card(
  #       style = "background-color: #E0F7FA;",  # light teal for positive
  #       bslib::card_header("Schools with Classroom Excess", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(scales::comma(excess_count), style = "text-align: center; font-weight: 700;")
  #       )
  #     )
  #   })
  #   
  #   # 4. Total Number of Schools with Classroom Balance
  #   output$schools_with_balance_home <- renderUI({
  #     balance_count <- filtered_data_LMS_erdb() %>%
  #       filter(Estimated_CL_Shortage == 0 & Estimated_CL_Excess == 0) %>%
  #       nrow()
  #     
  #     bslib::card(
  #       style = "background-color: #E8F5E9;",  # light green
  #       bslib::card_header("Schools with Classroom Balance", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(scales::comma(balance_count), style = "text-align: center; font-weight: 700;")
  #       )
  #     )
  #   })
  #   
  #   # 5. Total Number of Classrooms Needing Repairs
  #   output$classrooms_needing_repair_home <- renderUI({
  #     repair_count <- sum(filtered_data_LMS_erdb()$Rooms_Needing_Repairs, na.rm = TRUE)
  #     
  #     bslib::card(
  #       style = "background-color: #FFF3CD; color: #664D03;",
  #       bslib::card_header("Classrooms Needing Repairs", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(scales::comma(repair_count), style = "text-align: center; font-weight: 700;")
  #       )
  #     )
  #   })
  #   
  #   # --- Classroom Shortage Drilldown (Infrastructure Accordion in Home Panel) ---
  #   output$classroomshortage_plot_home <- renderPlotly({
  #     state <- drilldown_state()
  #     
  #     if (is.null(state$region)) {
  #       # National View -> Group by Region
  #       plot_data <- LMS %>%
  #         group_by(Region) %>%
  #         summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data, 
  #         y = ~Region,
  #         x = ~TotalShortage,
  #         type = 'bar',
  #         source = "drilldown_source_home_infra",
  #         text = ~TotalShortage,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = "Classroom Shortage by Region", 
  #           xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed")
  #         )
  #       
  #     } else if (is.null(state$division)) {
  #       # Regional View -> Group by Division
  #       plot_data <- LMS %>%
  #         filter(Region == state$region) %>%
  #         group_by(Division) %>%
  #         summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data, 
  #         y = ~Division,
  #         x = ~TotalShortage,
  #         type = 'bar',
  #         source = "drilldown_source_home_infra",
  #         text = ~TotalShortage,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("Classroom Shortage in", state$region),
  #           xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed")
  #         )
  #       
  #     } else {
  #       # Divisional View -> Group by Legislative District
  #       plot_data <- LMS %>%
  #         filter(Region == state$region, Division == state$division) %>%
  #         group_by(Legislative.District) %>%
  #         summarise(TotalShortage = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$TotalShortage, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data,
  #         y = ~Legislative.District,
  #         x = ~TotalShortage,
  #         type = 'bar',
  #         text = ~TotalShortage,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("Classroom Shortage in", state$division),
  #           xaxis = list(title = "Total Shortage", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed")
  #         )
  #     }
  #     p
  #   })
  #   
  #   # ================================================================
  #   # ========== BASIC INFO: SCHOOL VISUALIZATIONS (HOME) ============
  #   # ================================================================
  #   output$total_schools_home <- renderUI({
  #     total <- nrow(filtered_data_uni_erdb())  # reuse your existing filtered data
  #     
  #     bslib::card(
  #       style = "background-color: #FFFFFF;",
  #       bslib::card_header("Total Schools Count", class = "text-center"),
  #       bslib::card_body(
  #         tags$h3(
  #           scales::comma(total),
  #           style = "text-align: center; font-weight: 700;"
  #         )
  #       )
  #     )
  #   })
  #   # ========== TOTAL SCHOOLS PLOT ==========
  #   output$totalschools_plot_home <- renderPlotly({
  #     state <- drilldown_state()
  #     
  #     if (is.null(state$region)) {
  #       plot_data <- uni %>%
  #         group_by(Region) %>%
  #         summarise(TotalSchools = n(), .groups = 'drop')
  #       
  #       p <- plot_ly(
  #         data = plot_data,
  #         y = ~Region,
  #         x = ~TotalSchools,
  #         type = 'bar',
  #         source = "drilldown_source_home",  # âœ… Keep source for Region
  #         text = ~TotalSchools,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = "Total Schools by Region",
  #           xaxis = list(title = "Number of Schools"),
  #           yaxis = list(title = "", autorange = "reversed")
  #         )
  #       
  #     } else if (is.null(state$division)) {
  #       plot_data <- uni %>%
  #         filter(Region == state$region) %>%
  #         group_by(Division) %>%
  #         summarise(TotalSchools = n(), .groups = 'drop')
  #       
  #       p <- plot_ly(
  #         data = plot_data,
  #         y = ~Division,
  #         x = ~TotalSchools,
  #         type = 'bar',
  #         source = "drilldown_source_home",  # âœ… KEEP SAME SOURCE
  #         text = ~TotalSchools,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("Schools in", state$region),
  #           xaxis = list(title = "Number of Schools"),
  #           yaxis = list(title = "", autorange = "reversed")
  #         )
  #       
  #     } else {
  #       plot_data <- uni %>%
  #         filter(Region == state$region, Division == state$division) %>%
  #         group_by(Legislative.District) %>%
  #         summarise(TotalSchools = n(), .groups = 'drop')
  #       
  #       p <- plot_ly(
  #         data = plot_data,
  #         y = ~Legislative.District,
  #         x = ~TotalSchools,
  #         type = 'bar',
  #         source = "drilldown_source_home",  # âœ… KEEP SAME SOURCE
  #         text = ~TotalSchools,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("Schools in", state$division),
  #           xaxis = list(title = "Number of Schools"),
  #           yaxis = list(title = "Legislative District", autorange = "reversed")
  #         )
  #     }
  #     
  #     p
  #   })
  #   
  #   
  #   # ========== CURRICULAR OFFERING PLOT ==========
  #   output$curricular_plot_home <- renderPlotly({
  #     state <- drilldown_state()
  #     
  #     plot_data <- if (is.null(state$region)) {
  #       uni
  #     } else if (is.null(state$division)) {
  #       uni %>% filter(Region == state$region)
  #     } else {
  #       uni %>% filter(Region == state$region, Division == state$division)
  #     }
  #     
  #     pie_data <- plot_data %>%
  #       group_by(Modified.COC) %>%
  #       summarise(Count = n(), .groups = 'drop')
  #     
  #     title_text <- if (is.null(state$region)) {
  #       "By Curricular Offering (National)"
  #     } else if (is.null(state$division)) {
  #       paste("By Curricular Offering (", state$region, ")")
  #     } else {
  #       paste("By Curricular Offering (", state$division, ")")
  #     }
  #     
  #     plot_ly(
  #       data = pie_data,
  #       labels = ~Modified.COC,
  #       values = ~Count,
  #       type = 'pie',
  #       textinfo = 'percent',
  #       insidetextorientation = 'radial'
  #     ) %>%
  #       layout(title = title_text, showlegend = TRUE)
  #   })
  #   
  #   # ========== LAST MILE SCHOOLS PLOT ==========
  #   output$LMS_plot_home <- renderPlotly({
  #     state <- drilldown_state()
  #     
  #     if (is.null(state$region)) {
  #       # --- NATIONAL VIEW ---
  #       plot_data <- LMS %>%
  #         filter(LMS == 1) %>%
  #         group_by(Region) %>%
  #         summarise(Count = n(), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$Count, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data, 
  #         y = ~Region,
  #         x = ~Count,
  #         type = 'bar',
  #         source = "drilldown_source_home",   # âœ… SAME SOURCE AS WORKING CHART
  #         text = ~Count,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = "Last Mile Schools by Region",
  #           xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed")
  #         )
  #       
  #     } else if (is.null(state$division)) {
  #       # --- REGIONAL VIEW ---
  #       plot_data <- LMS %>%
  #         filter(LMS == 1, Region == state$region) %>%
  #         group_by(Division) %>%
  #         summarise(Count = n(), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$Count, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data, 
  #         y = ~Division,
  #         x = ~Count,
  #         type = 'bar',
  #         source = "drilldown_source_home",   # âœ… SAME SOURCE
  #         text = ~Count,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("LMS in", state$region),
  #           xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed")
  #         )
  #       
  #     } else {
  #       # --- DIVISIONAL VIEW (drilldown to district) ---
  #       plot_data <- LMS %>%
  #         filter(LMS == 1, Region == state$region, Division == state$division) %>%
  #         group_by(Legislative.District) %>%
  #         summarise(Count = n(), .groups = 'drop')
  #       
  #       max_schools <- max(plot_data$Count, na.rm = TRUE)
  #       
  #       p <- plot_ly(
  #         data = plot_data, 
  #         y = ~Legislative.District,
  #         x = ~Count,
  #         type = 'bar',
  #         source = "drilldown_source_home",   # âœ… SAME SOURCE
  #         text = ~Count,
  #         texttemplate = '%{x:,.0f}',
  #         textposition = 'outside'
  #       ) %>%
  #         layout(
  #           title = paste("LMS in", state$division),
  #           xaxis = list(title = "Number of LMS", tickformat = ",", range = c(0, max_schools * 1.15)),
  #           yaxis = list(title = "Legislative District", categoryorder = "total descending", autorange = "reversed")
  #         )
  #     }
  #     
  #     p
  #   })
  #   
  #   
  #   # ========== TYPOLOGY PLOT ==========
  #   output$typology_plot_home <- renderPlotly({
  #     state <- drilldown_state()
  #     
  #     plot_data <- if (is.null(state$region)) {
  #       uni
  #     } else if (is.null(state$division)) {
  #       uni %>% filter(Region == state$region)
  #     } else {
  #       uni %>% filter(Region == state$region, Division == state$division)
  #     }
  #     
  #     typology_data <- plot_data %>%
  #       group_by(School.Size.Typology) %>%
  #       summarise(Count = n(), .groups = 'drop')
  #     
  #     max_schools <- max(typology_data$Count, na.rm = TRUE)
  #     
  #     title_text <- if (is.null(state$region)) {
  #       "By School Size (National)"
  #     } else if (is.null(state$division)) {
  #       paste("By School Size (", state$region, ")")
  #     } else {
  #       paste("By School Size (", state$division, ")")
  #     }
  #     
  #     plot_ly(
  #       data = typology_data,
  #       y = ~School.Size.Typology,
  #       x = ~Count,
  #       type = 'bar',
  #       text = ~Count,
  #       texttemplate = '%{x:,.0f}',
  #       textposition = 'outside'
  #     ) %>%
  #       layout(
  #         title = title_text,
  #         yaxis = list(title = "", categoryorder = "total descending", autorange = "reversed"),
  #         xaxis = list(title = "Number of Schools", tickformat = ",", range = c(0, max_schools * 1.15))
  #       )
  #   })
  #   
  
  # # --- EDUCATION RESOURCE DASHBOARD SERVER LOGIC ---
  # 
  # # Track which category is selected
  # erdb_selection <- reactiveVal("home")
  # 
  # # Observe sidebar clicks
  # observeEvent(input$erdb_hr,         { erdb_selection("Human Resource") })
  # observeEvent(input$erdb_school,     { erdb_selection("Basic Info") })
  # observeEvent(input$erdb_infra,      { erdb_selection("Infrastructure") })
  # observeEvent(input$erdb_financial,  { erdb_selection("Financial") })
  # observeEvent(input$erdb_monitoring, { erdb_selection("Monitoring") })
  # observeEvent(input$erdb_ppas,       { erdb_selection("PPAs") })
  # observeEvent(input$reset_button,    { erdb_selection("home") })
  # 
  # # --- Dynamic Main Content ---
  # output$dynamic_erdb_panel <- renderUI({
  #   selected <- erdb_selection()
  #   
  #   # =====================================================
  #   # HUMAN RESOURCE SECTION
  #   # =====================================================
  #   
  #   if (selected == "Human Resource") {
  #     tagList(
  #       h3("Human Resource Overview"),
  #       
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_hr",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Accordion Section: Teacher Deployment Summary ---
  #       accordion(
  #         accordion_panel(
  #           title = "Teacher Deployment Summary",
  #           icon = bs_icon("people-fill"),
  #           
  #           layout_column_wrap(
  #             width = 1/5,
  #             card(card_header("RO Filling-up Rate"), valueBoxOutput("hr_fill_ro")),
  #             card(card_header("SDO Filling-up Rate"), valueBoxOutput("hr_fill_sdo")),
  #             card(card_header("Unfilled Items"), valueBoxOutput("hr_unfilled")),
  #             card(card_header("Net Shortage"), valueBoxOutput("hr_shortage")),
  #             card(card_header("Deployment Status"), valueBoxOutput("hr_status"))
  #           )
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Map and Data Table Section ---
  #       layout_columns(
  #         card(
  #           full_screen = TRUE,
  #           card_header("Teacher Deployment Map"),
  #           leafletOutput("hr_map", height = 600)
  #         ),
  #         card(
  #           full_screen = TRUE,
  #           card_header("Teacher Deployment Table"),
  #           dataTableOutput("hr_table")
  #         ),
  #         col_widths = c(6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(
  #             full_screen = TRUE,
  #             card_header(strong("Basic Information")),
  #             tableOutput("schooldetails_erdb")
  #           ),
  #           card(
  #             full_screen = TRUE,
  #             card_header(strong("HR Data")),
  #             tableOutput("schooldetails2_erdb")
  #           ),
  #           card(
  #             full_screen = TRUE,
  #             card_header(strong("Classroom Data")),
  #             tableOutput("schooldetails3_erdb")
  #           ),
  #           card(
  #             full_screen = TRUE,
  #             card_header(
  #               div(
  #                 strong("Specialization Data"),
  #                 tags$span(
  #                   em("(based on eSF7 for SY 2023-2024)"),
  #                   style = "font-size: 0.7em; color: grey;"
  #                 )
  #               )
  #             ),
  #             tableOutput("schooldetails5_erdb")
  #           ),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Teacher Deployment Priorities"),
  #             plotlyOutput("Teaching_Deployment_Division_Graph1")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Classroom Shortage Priorities"),
  #             plotlyOutput("Classroom_Shortage_Division_Graph2")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Last Mile School Priorities"),
  #             plotlyOutput("LMS_Division_Graph2")
  #           )
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         
  #         # âœ… Reactable Header Styling
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         
  #         reactable::reactableOutput("priority_division_erdb"),
  #         hr(),
  #         downloadButton(
  #           "download_priority_data",
  #           "Download SDO Ranking as CSV",
  #           class = "btn-success"
  #         ),
  #         height = 800
  #       )
  #     )
  #   }else if (selected == "Basic Info") {
  #     tagList(
  #       h3("School Information Overview"),
  #       
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_basicinfo",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Value Box Section ---
  #       layout_columns(
  #         uiOutput("total_schools_erdb2"),
  #         col_widths = c(12)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Graph Section (4 graphs total) ---
  #       layout_columns(
  #         card(full_screen = TRUE, card_header("Number of Schools (Click to Drill Down)"), plotlyOutput("totalschools_plot_erdb2")),
  #         card(full_screen = TRUE, card_header("Curricular Offering"), plotlyOutput("curricular_plot_erdb2")),
  #         card(full_screen = TRUE, card_header("School Size Typology"), plotlyOutput("typology_plot_erdb2")),
  #         card(full_screen = TRUE, card_header("Last Mile Schools"), plotlyOutput("LMS_plot_erdb2", height = "420px")),
  #         col_widths = c(6, 6, 6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Dashboard Data Table + Mapping ---
  #       layout_columns(
  #         card(full_screen = TRUE, card_header("Data Table"), dataTableOutput("dashboarddt_erdb2"), height = "500px"),
  #         card(full_screen = TRUE, card_header("School Mapping"), leafletOutput("mapping_erdb2"), height = "500px"),
  #         col_widths = c(6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_erdb")),
  #           card(full_screen = TRUE, card_header(strong("HR Data")), tableOutput("schooldetails2_erdb")),
  #           card(full_screen = TRUE, card_header(strong("Classroom Data")), tableOutput("schooldetails3_erdb")),
  #           card(
  #             full_screen = TRUE,
  #             card_header(
  #               div(
  #                 strong("Specialization Data"),
  #                 tags$span(
  #                   em("(based on eSF7 for SY 2023-2024)"),
  #                   style = "font-size: 0.7em; color: grey;"
  #                 )
  #               )
  #             ),
  #             tableOutput("schooldetails5_erdb")
  #           ),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Teacher Deployment Priorities"),
  #             plotlyOutput("Teaching_Deployment_Division_Graph1")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Classroom Shortage Priorities"),
  #             plotlyOutput("Classroom_Shortage_Division_Graph2")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Last Mile School Priorities"),
  #             plotlyOutput("LMS_Division_Graph2")
  #           )
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section (Separate Card) ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         
  #         reactable::reactableOutput("priority_division_erdb"),
  #         hr(),
  #         downloadButton(
  #           "download_priority_data",
  #           "Download SDO Ranking as CSV",
  #           class = "btn-success"
  #         ),
  #         height = 800
  #       )
  #     )
  #   }
  #   
  #   else if (selected == "Infrastructure") {
  #     tagList(
  #       h3("Infrastructure Overview"),
  #       
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_infra",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Value Boxes Section ---
  #       layout_columns(
  #         uiOutput("total_classrooms_erdb2"),
  #         uiOutput("total_classroom_shortage_erdb2"),
  #         col_widths = c(6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Graph Section ---
  #       layout_columns(
  #         card(
  #           full_screen = TRUE,
  #           card_header("Classroom Shortage"),
  #           plotlyOutput("classroomshortage_plot_erdb2", height = "420px")
  #         ),
  #         col_widths = c(12)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Data Table and Mapping Section ---
  #       layout_columns(
  #         card(
  #           full_screen = TRUE,
  #           card_header("Data Table"),
  #           dataTableOutput("dashboarddt_erdb2"),
  #           height = "500px"
  #         ),
  #         card(
  #           full_screen = TRUE,
  #           card_header("School Mapping"),
  #           leafletOutput("mapping_erdb2"),
  #           height = "500px"
  #         ),
  #         col_widths = c(6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_erdb")),
  #           card(full_screen = TRUE, card_header(strong("HR Data")), tableOutput("schooldetails2_erdb")),
  #           card(full_screen = TRUE, card_header(strong("Classroom Data")), tableOutput("schooldetails3_erdb")),
  #           card(
  #             full_screen = TRUE,
  #             card_header(
  #               div(
  #                 strong("Specialization Data"),
  #                 tags$span(
  #                   em("(based on eSF7 for SY 2023-2024)"),
  #                   style = "font-size: 0.7em; color: grey;"
  #                 )
  #               )
  #             ),
  #             tableOutput("schooldetails5_erdb")
  #           ),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Teacher Deployment Priorities"),
  #             plotlyOutput("Teaching_Deployment_Division_Graph1")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Classroom Shortage Priorities"),
  #             plotlyOutput("Classroom_Shortage_Division_Graph2")
  #           ),
  #           
  #           card(
  #             full_screen = TRUE,
  #             card_header("Last Mile School Priorities"),
  #             plotlyOutput("LMS_Division_Graph2")
  #           )
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section (Separate Card) ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         
  #         # âœ… Custom styling for reactable table header
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         
  #         reactable::reactableOutput("priority_division_erdb"),
  #         hr(),
  #         downloadButton(
  #           "download_priority_data",
  #           "Download SDO Ranking as CSV",
  #           class = "btn-success"
  #         ),
  #         height = 800
  #       )
  #     )
  #   }
  #   else if (selected == "Financial") {
  #     tagList(
  #       h3("Financial Overview"),
  #       
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_financial",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Main Financial Charts ---
  #       layout_columns(
  #         card(full_screen = TRUE, card_header("Budget Allocation by Region"), plotlyOutput("fin_alloc_plot")),
  #         card(full_screen = TRUE, card_header("Utilization Rate"), plotlyOutput("fin_util_plot")),
  #         card(full_screen = TRUE, card_header("Division Expenditure"), dataTableOutput("fin_table")),
  #         col_widths = c(4, 4, 4)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_fin1")),
  #           card(full_screen = TRUE, card_header(strong("Financial Data")), tableOutput("schooldetails_fin2")),
  #           card(full_screen = TRUE, card_header(strong("Infrastructure Data")), tableOutput("schooldetails_fin3")),
  #           card(full_screen = TRUE, card_header(strong("Specialization Data")), tableOutput("schooldetails_fin4")),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           card(card_header("Budget Prioritization by Division"), plotlyOutput("fin_priority_plot1")),
  #           card(card_header("Utilization Rate Comparison"), plotlyOutput("fin_priority_plot2")),
  #           card(card_header("Funding Gaps"), plotlyOutput("fin_priority_plot3"))
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         reactable::reactableOutput("priority_division_fin"),
  #         hr(),
  #         downloadButton("download_priority_fin", "Download SDO Ranking as CSV", class = "btn-success"),
  #         height = 800
  #       )
  #     )
  #   }
  #   else if (selected == "Monitoring") {
  #     tagList(
  #       
  #       
  #       h3("Monitoring Overview"),
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_monitoring",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       hr(),
  #       
  #       # --- Monitoring Charts ---
  #       layout_columns(
  #         card(
  #           full_screen = TRUE,
  #           card_header("Project Implementation Status"),
  #           plotlyOutput("monitor_proj_plot")
  #         ),
  #         card(
  #           full_screen = TRUE,
  #           card_header("Monitoring Map"),
  #           leafletOutput("monitor_map", height = 600)
  #         ),
  #         col_widths = c(6, 6)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the map or table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_monitor1")),
  #           card(full_screen = TRUE, card_header(strong("Project Data")), tableOutput("schooldetails_monitor2")),
  #           card(full_screen = TRUE, card_header(strong("Financial Monitoring")), tableOutput("schooldetails_monitor3")),
  #           card(full_screen = TRUE, card_header(strong("Remarks / Status")), tableOutput("schooldetails_monitor4")),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           card(card_header("Delayed Projects"), plotlyOutput("monitor_priority_plot1")),
  #           card(card_header("On-time Completion Rate"), plotlyOutput("monitor_priority_plot2")),
  #           card(card_header("High-risk Projects"), plotlyOutput("monitor_priority_plot3"))
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         
  #         # --- Table Styling ---
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         
  #         reactable::reactableOutput("priority_division_monitor"),
  #         hr(),
  #         downloadButton("download_priority_monitor", "Download SDO Ranking as CSV", class = "btn-success"),
  #         height = 800
  #       )
  #     )
  #   }
  #   
  #   else if (selected == "PPAs") {
  #     tagList(
  #       
  #       h3("Programs, Projects, and Activities (PPAs) Overview"),
  #       # --- Back / Reset Button (Top of the Page) ---
  #       div(
  #         class = "text-start mb-3",
  #         actionButton(
  #           "reset_ppas",
  #           label = tagList(bs_icon("arrow-left"), "Back"),
  #           class = "btn btn-secondary btn-md"
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Main PPAs Charts ---
  #       layout_columns(
  #         card(full_screen = TRUE, card_header("PPA Distribution by Region"), plotlyOutput("ppa_region_plot")),
  #         card(full_screen = TRUE, card_header("PPA Table"), dataTableOutput("ppa_table")),
  #         card(full_screen = TRUE, card_header("Mapping"), leafletOutput("ppa_map", height = 600)),
  #         col_widths = c(4, 4, 4)
  #       ),
  #       
  #       hr(),
  #       
  #       # --- School Details Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header(
  #           div(
  #             strong("School Details"),
  #             tags$span(
  #               em("(Select a school from the map or table above)"),
  #               style = "font-size: 0.7em; color: grey;"
  #             )
  #           )
  #         ),
  #         layout_columns(
  #           card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_ppa1")),
  #           card(full_screen = TRUE, card_header(strong("PPA Data")), tableOutput("schooldetails_ppa2")),
  #           card(full_screen = TRUE, card_header(strong("Financial Info")), tableOutput("schooldetails_ppa3")),
  #           card(full_screen = TRUE, card_header(strong("Implementation Status")), tableOutput("schooldetails_ppa4")),
  #           col_widths = c(6, 6, 6, 6)
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- Priority Divisions Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("Priority Divisions"),
  #         layout_column_wrap(
  #           width = 1/3,
  #           heights_equal = "row",
  #           card(card_header("Delayed PPAs"), plotlyOutput("ppa_priority_plot1")),
  #           card(card_header("Low Budget Utilization"), plotlyOutput("ppa_priority_plot2")),
  #           card(card_header("High Impact PPAs"), plotlyOutput("ppa_priority_plot3"))
  #         )
  #       ),
  #       
  #       hr(),
  #       
  #       # --- SDO Ranking Section ---
  #       card(
  #         full_screen = TRUE,
  #         card_header("SDO Ranking"),
  #         
  #         # --- Table Styling ---
  #         tags$head(
  #           tags$style(HTML("
  #         .reactable thead th {
  #           white-space: normal !important;
  #           word-wrap: break-word !important;
  #           line-height: 1.1;
  #           text-align: center;
  #         }
  #         .reactable .rt-thead.-header { height: auto !important; }
  #         .reactable .rt-th {
  #           display: flex;
  #           justify-content: center;
  #           align-items: center;
  #           text-align: center;
  #         }
  #       "))
  #         ),
  #         
  #         reactable::reactableOutput("priority_division_ppa"),
  #         hr(),
  #         downloadButton("download_priority_ppa", "Download SDO Ranking as CSV", class = "btn-success"),
  #         height = 800
  #       )
  #     )
  #   }
  #   
  #   else {
  #     # Default Overview
  #     tagList(
  #       h3("Education Resource Dashboard Overview"),
  #       hr(),
  #       p("Select a category from the sidebar to explore the data visualizations, maps, and analytics for each component of the education resource system.")
  #     )
  #   }
  # })
  # 
  # --- EDUCATION RESOURCE DASHBOARD SERVER ---
  
  # Track which category is selected
  erdb_selection <- reactiveVal("education resource dashboard")
  
  # --- Observe Sidebar Button Clicks ---
  observeEvent(input$erdb_hr,         { erdb_selection("Human Resource") })
  observeEvent(input$erdb_basic,      { erdb_selection("Basic Info") })
  observeEvent(input$erdb_infra,      { erdb_selection("Infrastructure") })
  observeEvent(input$erdb_fin,        { erdb_selection("Financial") })
  observeEvent(input$erdb_monitoring, { erdb_selection("Monitoring") })
  observeEvent(input$erdb_ppas,       { erdb_selection("PPAs") })
  observeEvent(input$reset_button,    { erdb_selection("home") })
  
  # --- Dynamic Main Content ---
  output$erdb_content <- renderUI({
    selected <- erdb_selection()
    
    # =====================================================
    # HUMAN RESOURCE SECTION
    # =====================================================
    if (selected == "Human Resource") {
      tagList(
        h3("Human Resource Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton("reset_hr", label = tagList(bs_icon("arrow-left"), "Back"), class = "btn btn-secondary btn-md")
        ),
        
        hr(),
        
        # --- TABSET CONTAINER ---
        navset_tab(
          
          # =====================================================
          # TAB 1: Teacher Deployment Summary
          # =====================================================
          nav_panel(
            title = "Teacher Deployment Summary",
            icon = bs_icon("people-fill"),
            
            accordion(
              accordion_panel(
                title = "Teacher Deployment Summary",
                icon = bs_icon("bar-chart-fill"),
                layout_column_wrap(
                  width = 1/5,
                  card(card_header("RO Filling-up Rate"), valueBoxOutput("hr_fill_ro")),
                  card(card_header("SDO Filling-up Rate"), valueBoxOutput("hr_fill_sdo")),
                  card(card_header("Unfilled Items"), valueBoxOutput("hr_unfilled")),
                  card(card_header("Net Shortage"), valueBoxOutput("hr_shortage")),
                  card(card_header("Deployment Status"), valueBoxOutput("hr_status"))
                )
              )
            ),
            
            hr(),
            
            layout_columns(
              card(full_screen = TRUE, card_header("Teacher Deployment Map"), leafletOutput("hr_map", height = 600)),
              card(full_screen = TRUE, card_header("Teacher Deployment Table"), dataTableOutput("hr_table")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 2: School Details
          # =====================================================
          nav_panel(
            title = "School Details",
            icon = bs_icon("building"),
            
            card(
              full_screen = TRUE,
              card_header(div(strong("School Details"), tags$span(em("(Select a school from the table above)"), style = "font-size: 0.7em; color: grey;"))),
              layout_columns(
                card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_erdb")),
                card(full_screen = TRUE, card_header(strong("HR Data")), tableOutput("schooldetails2_erdb")),
                card(full_screen = TRUE, card_header(strong("Classroom Data")), tableOutput("schooldetails3_erdb")),
                card(full_screen = TRUE, card_header(div(strong("Specialization Data"), tags$span(em("(based on eSF7 for SY 2023-2024)"), style = "font-size: 0.7em; color: grey;"))), tableOutput("schooldetails5_erdb")),
                col_widths = c(6, 6, 6, 6)
              )
            )
          ),
          
          # =====================================================
          # TAB 3: Priority Divisions
          # =====================================================
          nav_panel(
            title = "Priority Divisions",
            icon = bs_icon("list-stars"),
            
            card(
              full_screen = TRUE,
              card_header("Priority Divisions Overview"),
              layout_column_wrap(
                width = 1/3,
                heights_equal = "row",
                card(full_screen = TRUE, card_header("Teacher Deployment Priorities"), plotlyOutput("Teaching_Deployment_Division_Graph1")),
                card(full_screen = TRUE, card_header("Classroom Shortage Priorities"), plotlyOutput("Classroom_Shortage_Division_Graph2")),
                card(full_screen = TRUE, card_header("Last Mile School Priorities"), plotlyOutput("LMS_Division_Graph2"))
              )
            )
          ),
          
          # =====================================================
          # TAB 4: SDO Ranking
          # =====================================================
          nav_panel(
            title = "SDO Ranking",
            icon = bs_icon("award"),
            
            card(
              full_screen = TRUE,
              card_header("SDO Ranking"),
              tags$head(tags$style(HTML("
            .reactable thead th {
              white-space: normal !important;
              word-wrap: break-word !important;
              line-height: 1.1;
              text-align: center;
            }
            .reactable .rt-thead.-header { height: auto !important; }
            .reactable .rt-th {
              display: flex;
              justify-content: center;
              align-items: center;
              text-align: center;
            }
          "))),
              reactable::reactableOutput("priority_division_erdb"),
              hr(),
              downloadButton("download_priority_data", "Download SDO Ranking as CSV", class = "btn-success"),
              height = 800
            )
          ),
          
          # =====================================================
          # TAB 5: Workforce Planning (Future Placeholder)
          # =====================================================
          nav_panel(
            title = "Workforce Planning",
            icon = bs_icon("clipboard-data"),
            div(class = "text-center p-5", tags$em("No data yet. This section will contain workforce planning analytics soon."))
          )
        )
      )
      # =====================================================
      # BASIC INFORMATION SECTION (with Tabs)
      # =====================================================
    } else if (selected == "Basic Info") {
      tagList(
        h3("School Information Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton("reset_basicinfo",
                       label = tagList(bs_icon("arrow-left"), "Back"),
                       class = "btn btn-secondary btn-md")
        ),
        
        hr(),
        
        # --- TABSET PANEL START ---
        tabsetPanel(
          id = "basicinfo_tabs",
          
          # =====================================================
          # TAB 1: Overview (Reactive Values + Charts)
          # =====================================================
          tabPanel(
            title = "Overview",
            icon = icon("chart-bar"),
            
            # --- Reactive Values (e.g. total schools, counts, etc.) ---
            layout_columns(uiOutput("total_schools_erdb"), col_widths = c(12)),
            
            hr(),
            
            # --- Charts Section ---
            layout_columns(
              card(full_screen = TRUE, card_header("Number of Schools (Click to Drill Down)"), plotlyOutput("totalschools_plot_erdb")),
              card(full_screen = TRUE, card_header("Curricular Offering"), plotlyOutput("curricular_plot_erdb")),
              card(full_screen = TRUE, card_header("School Size Typology"), plotlyOutput("typology_plot_erdb")),
              card(full_screen = TRUE, card_header("Last Mile Schools"), plotlyOutput("LMS_plot_erdb", height = "420px")),
              col_widths = c(6, 6, 6, 6)
            )
          ),
          
          # =====================================================
          # TAB 2: Data Table, Map, and Basic Information
          # =====================================================
          tabPanel(
            title = "Data & Map",
            icon = icon("table"),
            tagList(
              # --- Data Table & Map Section ---
              layout_columns(
                card(full_screen = TRUE, card_header("Data Table"), dataTableOutput("dashboarddt_erdb"), height = "500px"),
                card(full_screen = TRUE, card_header("School Mapping"), leafletOutput("mapping_erdb"), height = "500px"),
                col_widths = c(6, 6)
              ),
              
              hr(),
              
              # --- Basic Information Tables Section ---
              card(
                full_screen = TRUE,
                card_header(
                  div(
                    strong("School Details"),
                    tags$span(em("(Select a school from the table above)"), style = "font-size: 0.7em; color: grey;")
                  )
                ),
                layout_columns(
                  card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_erdb")),
                  card(full_screen = TRUE, card_header(strong("HR Data")), tableOutput("schooldetails2_erdb")),
                  card(full_screen = TRUE, card_header(strong("Classroom Data")), tableOutput("schooldetails3_erdb")),
                  card(
                    full_screen = TRUE,
                    card_header(
                      div(
                        strong("Specialization Data"),
                        tags$span(em("(based on eSF7 for SY 2023-2024)"), style = "font-size: 0.7em; color: grey;")
                      )
                    ),
                    tableOutput("schooldetails5_erdb")
                  ),
                  col_widths = c(6, 6, 6, 6)
                )
              )
            )
          ),
          
          # # =====================================================
          # # TAB 3: (Optional Future Use)
          # # =====================================================
          # tabPanel(
          #   title = "Additional Insights",
          #   icon = icon("chart-area"),
          #   p("This tab can be used for future data analysis or additional charts.")
          # )
        ) # --- END OF TABSET PANEL ---
      )
      
      # =====================================================
      # INFRASTRUCTURE SECTION (with Tabs + School Details)
      # =====================================================
    } else if (selected == "Infrastructure") {
      tagList(
        h3("Infrastructure Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton("reset_infra",
                       label = tagList(bs_icon("arrow-left"), "Back"),
                       class = "btn btn-secondary btn-md")
        ),
        
        hr(),
        
        # --- TABSET PANEL START ---
        tabsetPanel(
          id = "infrastructure_tabs",
          
          # =====================================================
          # TAB 1: Overview (Reactive Values + Charts)
          # =====================================================
          tabPanel(
            title = "Overview",
            icon = icon("building"),
            
            # --- Reactive Values ---
            layout_columns(
              uiOutput("total_classrooms_erdb"),
              uiOutput("total_classroom_shortage_erdb"),
              col_widths = c(6, 6)
            ),
            
            hr(),
            
            # --- Chart Section ---
            layout_columns(
              card(
                full_screen = TRUE,
                card_header("Classroom Shortage"),
                plotlyOutput("classroomshortage_plot_erdb", height = "420px")
              ),
              col_widths = c(12)
            )
          ),
          
          # =====================================================
          # TAB 2: Data Table, Map, and Basic Information
          # =====================================================
          tabPanel(
            title = "Data & Map",
            icon = icon("table"),
            tagList(
              # --- Data Table & Map Section ---
              layout_columns(
                card(full_screen = TRUE, card_header("Data Table"), dataTableOutput("dashboarddt_erdb"), height = "500px"),
                card(full_screen = TRUE, card_header("School Mapping"), leafletOutput("mapping_erdb"), height = "500px"),
                col_widths = c(6, 6)
              ),
              
              hr(),
              
              # --- Basic Information (School Details) Section ---
              card(
                full_screen = TRUE,
                card_header(
                  div(
                    strong("School Details"),
                    tags$span(em("(Select a school from the table above)"), style = "font-size: 0.7em; color: grey;")
                  )
                ),
                layout_columns(
                  card(full_screen = TRUE, card_header(strong("Basic Information")), tableOutput("schooldetails_erdb")),
                  card(full_screen = TRUE, card_header(strong("HR Data")), tableOutput("schooldetails2_erdb")),
                  card(full_screen = TRUE, card_header(strong("Classroom Data")), tableOutput("schooldetails3_erdb")),
                  card(
                    full_screen = TRUE,
                    card_header(
                      div(
                        strong("Specialization Data"),
                        tags$span(em("(based on eSF7 for SY 2023-2024)"), style = "font-size: 0.7em; color: grey;")
                      )
                    ),
                    tableOutput("schooldetails5_erdb")
                  ),
                  col_widths = c(6, 6, 6, 6)
                )
              )
            )
          )
        ) # --- END OF TABSET PANEL ---
      )
      
      # =====================================================
      # FINANCIAL SECTION (with Tabs)
      # =====================================================
    } else if (selected == "Financial") {
      tagList(
        h3("Financial Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton(
            "reset_financial",
            label = tagList(bs_icon("arrow-left"), "Back"),
            class = "btn btn-secondary btn-md"
          )
        ),
        
        hr(),
        
        # --- TABSET PANEL START ---
        tabsetPanel(
          id = "financial_tabs",
          
          # =====================================================
          # TAB 1: Overview (Charts / Summary)
          # =====================================================
          tabPanel(
            title = "Overview",
            icon = icon("chart-bar"),
            layout_columns(
              card(full_screen = TRUE, card_header("Budget Allocation by Region"), plotlyOutput("fin_alloc_plot")),
              card(full_screen = TRUE, card_header("Utilization Rate"), plotlyOutput("fin_util_plot")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 2: Data Table & Mapping
          # =====================================================
          tabPanel(
            title = "Data & Map",
            icon = icon("table"),
            layout_columns(
              card(full_screen = TRUE, card_header("Division Expenditure Table"), dataTableOutput("fin_table"), height = "500px"),
              card(full_screen = TRUE, card_header("Financial Mapping"), leafletOutput("fin_map"), height = "500px"),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 3: Future Financial Reports (Placeholder)
          # =====================================================
          tabPanel(
            title = "Reports",
            icon = icon("file-alt"),
            div(
              class = "text-center p-5",
              tags$h4("Financial Reports Section"),
              tags$p("Detailed budget and expenditure reports will be available here soon.")
            )
          )
        ) # --- END TABSET PANEL ---
      )
      
      # =====================================================
      # MONITORING SECTION (with Tabs)
      # =====================================================
    } else if (selected == "Monitoring") {
      tagList(
        h3("Monitoring Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton(
            "reset_monitoring",
            label = tagList(bs_icon("arrow-left"), "Back"),
            class = "btn btn-secondary btn-md"
          )
        ),
        
        hr(),
        
        # --- TABSET PANEL START ---
        tabsetPanel(
          id = "monitoring_tabs",
          
          # =====================================================
          # TAB 1: Overview (Charts / Status)
          # =====================================================
          tabPanel(
            title = "Overview",
            icon = icon("chart-line"),
            
            # Optional: Add summary cards later (e.g., total projects, completed %, delayed %)
            layout_columns(
              card(full_screen = TRUE, card_header("Project Implementation Status"), plotlyOutput("monitor_proj_plot", height = "450px")),
              card(full_screen = TRUE, card_header("Monitoring Progress Trends"), plotlyOutput("monitor_trend_plot", height = "450px")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 2: Data Table & Map
          # =====================================================
          tabPanel(
            title = "Data & Map",
            icon = icon("table"),
            layout_columns(
              card(full_screen = TRUE, card_header("Monitoring Table"), dataTableOutput("monitor_table"), height = "500px"),
              card(full_screen = TRUE, card_header("Monitoring Map"), leafletOutput("monitor_map", height = "500px")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 3: Reports / Insights (Placeholder)
          # =====================================================
          tabPanel(
            title = "Reports",
            icon = icon("file-alt"),
            div(
              class = "text-center p-5",
              tags$h4("Monitoring Reports Section"),
              tags$p("Insights and performance summaries will be displayed here soon.")
            )
          )
        ) # --- END TABSET PANEL ---
      )
      
      # =====================================================
      # PPAs SECTION (with Tabs)
      # =====================================================
    } else if (selected == "PPAs") {
      tagList(
        h3("Programs, Projects, and Activities (PPAs) Overview"),
        
        div(
          class = "text-start mb-3",
          actionButton(
            "reset_ppas",
            label = tagList(bs_icon("arrow-left"), "Back"),
            class = "btn btn-secondary btn-md"
          )
        ),
        
        hr(),
        
        # --- TABSET PANEL START ---
        tabsetPanel(
          id = "ppas_tabs",
          
          # =====================================================
          # TAB 1: Overview (Charts / Summary)
          # =====================================================
          tabPanel(
            title = "Overview",
            icon = icon("chart-pie"),
            
            # Optional summary values (for later: total PPAs, total budget, completion rate)
            layout_columns(
              card(full_screen = TRUE, card_header("PPA Distribution by Region"), plotlyOutput("ppa_region_plot", height = "450px")),
              card(full_screen = TRUE, card_header("PPA Status Breakdown"), plotlyOutput("ppa_status_plot", height = "450px")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 2: Data Table & Map
          # =====================================================
          tabPanel(
            title = "Data & Map",
            icon = icon("table"),
            layout_columns(
              card(full_screen = TRUE, card_header("PPA Data Table"), dataTableOutput("ppa_table"), height = "500px"),
              card(full_screen = TRUE, card_header("PPA Mapping"), leafletOutput("ppa_map", height = "500px")),
              col_widths = c(6, 6)
            )
          ),
          
          # =====================================================
          # TAB 3: Reports / Analysis (Placeholder)
          # =====================================================
          tabPanel(
            title = "Reports",
            icon = icon("file-alt"),
            div(
              class = "text-center p-5",
              tags$h4("PPAs Reports Section"),
              tags$p("Detailed PPA progress and budget analysis will be displayed here soon.")
            )
          )
        ) # --- END TABSET PANEL ---
      )
      # =====================================================
      # DEFAULT DASHBOARD HOME
      # =====================================================
    }
    else {
      tagList(
        h3("Education Resource Dashboard Overview"),
        hr(),
        p("Select a category from the sidebar to explore the data visualizations, maps, and analytics for each component of the education resource system.")
      )
    }
  })
  
  
  # Reactive expression to generate the main panel content
  output$dynamic_resource_panel <- renderUI({
    
    selected_resource_type <- input$resource_type_selection
    if (selected_resource_type == "Teaching Deployment") {
      
      tagList(
        h3("Teaching Deployment Overview"),
        hr(),
        
        layout_columns(
          # selectInput("resource_map_level", "Filter Curricular Level:",
          #             choices = c("Elementary School"="ES",
          #                         "Junior High School"="JHS",
          #                         "Senior High School"="SHS"),
          #             selected = "ES"),
          input_task_button("Teaching_Deployment_Refresh", strong("Refresh"), class = "btn-warning"),
          col_widths = c(4, -8, 2)
        ),
        
        hr(),
        
        # --- Accordion only for summary cards ---
        accordion(
          open = "Deployment Summary by Level",
          
          accordion_panel(
            title = "Deployment Summary by Level",
            icon = bsicons::bs_icon("bar-chart-fill"),
            
            # --- Start of Tabset (now ABOVE the summary cards) ---
            navset_tab(
              # nav_panel("Regional Breakdown",
              #           plotlyOutput("Teaching_Deployment_Region_Graph")
              # ),
              # nav_panel("Priority Divisions",
              #           plotlyOutput("Teaching_Deployment_Division_Graph1")
              # ),
              # nav_panel("Dataset",
              #           dataTableOutput("Teaching_Deployment_Dataset")
              # )
            ),
            # --- End of Tabset ---
            
            hr(),
            
            # --- Summary Cards ---
            layout_column_wrap(
              width = 1/5,
              card(
                card_header(strong("RO Filling-up Rate")),
                valueBoxOutput("f")
              ),
              card(
                card_header(strong("RO Unfilled Items")),
                valueBoxOutput("g")
              ),
              card(
                card_header(strong("SDO Filling-up Rate")),
                valueBoxOutput("a")
              ),
              card(
                card_header(strong("SDO Unfilled Items")),
                valueBoxOutput("b")
              ),
              card(
                card_header(strong("SDO Net Shortage")),
                valueBoxOutput("e")
              )
            )
          )
        ),
        
        hr(),
        
        layout_columns(
          card(
            card_header(strong("Teacher Excess and Shortage")),
            dataTableOutput("TeacherShortage_Table")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("Personnel Deployment Mapping")),
            leafletOutput("TeacherShortage_Mapping", height = 700)
          ),
          card(
            height = 200,
            card_header(div(
              "School Summary",
              tags$span(em("(Select a school from the table above)"),
                        style = "font-size: 0.7em; color: grey;")
            )),
            uiOutput("TeacherShortage_Assessment")
          ),
          col_widths = c(4, 8, 12)
        )
      )
      
    }
    else if (selected_resource_type == "Non-teaching Deployment") {
      tagList(
        h3("Non-teaching Deployment Overview"),
        hr(),
        
        # --- Accordion for the summary sections ---
        accordion(
          open = "Deployment Summary by Level",
          accordion_panel(
            title = "Deployment Summary by Level",
            icon = bsicons::bs_icon("people-fill"),
            
            # --- Tabbed summaries inside accordion ---
            navset_card_tab(
              nav_spacer(),
              
              # --- Regional Summary ---
              nav_panel(
                title = "Regional Summary",
                layout_column_wrap(
                  width = 1/2,  # Two cards side by side
                  card(
                    card_header(strong("Schools under Clustered AO II Deployment")),
                    valueBoxOutput("f2")
                  ),
                  card(
                    card_header(strong("Schools with Dedicated AOII Deployment")),
                    valueBoxOutput("g2")
                  )
                )
              ),
              
              # --- Division Summary ---
              nav_panel(
                title = "Division Summary",
                layout_column_wrap(
                  width = 1/2,
                  card(
                    card_header(strong("Schools under Clustered AO II Deployment")),
                    valueBoxOutput("a2")
                  ),
                  card(
                    card_header(strong("Schools with Dedicated AOII Deployment")),
                    valueBoxOutput("b2")
                  )
                )
              ),
              
              # --- District Summary ---
              nav_panel(
                title = "District Summary",
                layout_column_wrap(
                  width = 1/2,
                  card(
                    card_header(strong("Schools under Clustered AO II Deployment")),
                    valueBoxOutput("e2")
                  ),
                  card(
                    card_header(strong("Schools with Dedicated AOII Deployment")),
                    valueBoxOutput("h2")
                  )
                )
              )
            )
          )
        ),
        
        hr(),
        
        # --- This part stays outside the accordion ---
        layout_columns(
          card(
            card_header(
              div(
                strong("AO II Deployment Status"),
                tags$span(
                  em("(as of September 2, 2025)"),
                  style = "font-size: 0.8em; color: grey; margin-top: 0.1em; margin-bottom: 0;"
                )
              )
            ),
            dataTableOutput("AO2Table")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("Personnel Deployment Mapping")),
            leafletOutput("AO2Mapping", height = 800)
          ),
          col_widths = c(5,7)
        )
      )
      
      
    } else if (selected_resource_type == "Classroom Inventory") {
      tagList(
        h3("Classroom Inventory Overview"),
        hr(),
        
        # --- Accordion for National and Shortage Summaries ---
        accordion(
          
          # âƒ£Panel: National Overview
          accordion_panel(
            title = "National Classroom Inventory Overview",
            icon = bsicons::bs_icon("bar-chart-fill"),
            layout_columns(
              # card(
              #   full_screen = TRUE,
              #   card_header(
              #     tagList(
              #       strong("Classroom Shortage Breakdown"),
              #       tags$br(),
              #       tags$em("(n = 165,443)")
              #     )
              #   ),
              #   # Start of Tabset
              #   navset_tab(
              #     # Tab 1: Regional Classroom Breakdown (Your existing content)
              #     # nav_panel("Regional Breakdown",
              #     #           plotlyOutput("Classroom_Shortage_Region_Graph2")
              #     # ),
              #     # Tab 2: Division Classroom Shortage Breakdown (The new tab)
              #     # nav_panel("Priority Divisions",
              #     #           plotlyOutput("Classroom_Shortage_Division_Graph2")
              #     # ),
              #     nav_panel("Dataset",
              #               dataTableOutput("Classroom_Shortage_Dataset"))
              #   )),
              # # End of Tabset
              
              card(
                card_header(strong("Regional Classroom Shortage")),
                valueBoxOutput("ROCRShort")
              ),
              card(
                card_header(strong("Division Classroom Shortage")),
                valueBoxOutput("SDOCRShort")
              ),
              #card(
              # card_header(strong("District Classroom Shortage")),
              #valueBoxOutput("DistCRShort")
              #),
              col_widths = c(6,6)
            )
          )
        ),
        
        hr(),
        
        # --- Table and Mapping ---
        layout_columns(
          card(
            full_screen = TRUE,
            card_header(strong("Classroom Shortage")),
            dataTableOutput("CLTable")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("School Mapping")),
            leafletOutput("CLMapping", height = 800)
          )
        )
      )
      
      
    } else if (selected_resource_type == "Industries") {
      
      tagList(
        h3("Industries Overview"),
        hr(),
        
        # --- Accordion for Industry Summary and others ---
        accordion(
          open = "Industry Summary",
          
          #  Panel: Industry Summary
          accordion_panel(
            title = "Industry Summary",
            icon = bsicons::bs_icon("bar-chart"),
            
            # # --- Industry Distribution Overview Card placed FIRST ---
            # card(
            #   full_screen = TRUE,
            #   card_header(
            #     tagList(
            #       strong("Industry Breakdown"),
            #       tags$br(),
            #       tags$em("(n = )")
            #     )
            #   ),
            #   
            #   # --- Tabset ---
            #   navset_tab(
            #     nav_panel("Regional Breakdown",
            #               plotlyOutput("Ind_Regional_Graph")
            #     ),
            #     # nav_panel("Priority Divisions",
            #     #           plotlyOutput("Ind_Division_Graph")
            #     # ),
            #     nav_panel("Dataset",
            #               dataTableOutput("Ind_Dataset")
            #     )
            #   )
            # ),
            # 
            # # --- Divider line for better separation ---
            # hr(),
            # 
            # --- Summary Counts ---
            layout_column_wrap(
              width = 1/2,
              card(
                card_header(strong("Total SHS Count")),
                valueBoxOutput("SHSCountUniv")
              ),
              card(
                card_header(strong("Total Industry Count")),
                valueBoxOutput("IndCount")
              )
            ),
            
            # --- Nearby Industry Count ---
            card(
              card_header("Nearby Industry Count (~10 km radius):"),
              layout_column_wrap(
                width = 1/6,
                card(
                  card_header(strong("Manufacturing and Engineering")),
                  valueBoxOutput("AccoCount")
                ),
                card(
                  card_header(strong("Hospitality and Tourism")),
                  valueBoxOutput("ProfCount")
                ),
                card(
                  card_header(strong("Public Administration")),
                  valueBoxOutput("TranCount")
                ),
                card(
                  card_header(strong("Professional/Private Services")),
                  valueBoxOutput("WastCount")
                ),
                card(
                  card_header(strong("Business and Finance")),
                  valueBoxOutput("WholCount")
                ),
                card(
                  card_header(strong("Agriculture and Agri-business")),
                  valueBoxOutput("WholCount2")
                )
              )
            )
          )
        ),
        
        hr(),
        
        # --- Remaining Layout: SHS list, mapping, etc. ---
        layout_columns(
          card(
            card_header(strong("List of SHS")),
            dataTableOutput("SHSListTable")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("SHS to Industry Mapping")),
            leafletOutput("SHSMapping", height = 700, width = "100%")
          ),
          card(
            full_screen = TRUE,
            card_header(div(strong("School Profile"),
                            tags$span(em("(Select a school in the table above)"),
                                      style = "font-size: 0.7em; color: grey;")
            )),
            tableOutput("SHSTablex")
          ),
          card(
            full_screen = TRUE,
            card_header(div(strong("Specialization Data"),
                            tags$span(em("(based on eSF7 for SY 2023-2024)"),
                                      style = "font-size: 0.7em; color: grey;")
            )),
            tableOutput("PilotSpec")
          ),
          card(
            card_header(div(strong("Nearby Industries"),
                            tags$span(em("(Select a school in the table above)"),
                                      style = "font-size: 0.7em; color: grey;")
            )),
            dataTableOutput("dataTableSHS")
          ),
          col_widths = c(4, 8, 6, 6, 12)
        )
      )
    }
    
    
    else if (selected_resource_type == "Facilities") {
      
      tagList(
        h3("Education Facilities Mapping"),
        
        layout_columns(
          col_widths = c(6, 6), 
          selectInput("EFD_Type", "Select Type",
                      choices = c("New Construction","Electrification","Health","QRF","LMS","ALS-CLC","Gabaldon", "Repairs"),
                      selected = "New Construction"
          )
        ),
        
        input_task_button("Facilities_Refresh", strong("Refresh"), class = "btn-success"),
        hr(),
        
        # # --- Accordion Wrapper ---
        # accordion(
        #   open = "Facilities Overview",
        #   
        #   accordion_panel(
        #     title = "Facilities Overview",
        #     icon = bsicons::bs_icon("building"),
        #     
        #     # --- Start of Tabset ---
        #     navset_tab(
        #       nav_panel("Regional Breakdown",
        #                 plotlyOutput("Facilities_Regional_Graph")
        #       ),
        #       nav_panel("Division Breakdown",
        #                 plotlyOutput("Facilities_Division_Graph")
        #       ),
        #       nav_panel("Dataset",
        #                 dataTableOutput("Facilities_Dataset")
        #       )
        #     )
        #     # --- End of Tabset ---
        #   )
        # ),
        
        hr(),
        
        layout_columns(
          card(
            full_screen = TRUE,
            card_header(strong("School Project Allocation per Funding Year")),
            dataTableOutput("FacTable")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("School Mapping")),
            leafletOutput("FacMapping", height = 800)
          )
        )
      )
      
    }
    else if (selected_resource_type == "Learner Congestion") {
      
      tagList(
        h3("Learner Congestion Mapping (SY 2023-2024)"),
        hr(),
        
        # # --- Accordion Wrapper ---
        # accordion(
        #   open = "Learner Congestion Overview",
        #   
        #   accordion_panel(
        #     title = "Learner Congestion Overview",
        #     icon = bsicons::bs_icon("diagram-3-fill"),
        #     
        #     # --- Start of Tabset ---
        #     navset_tab(
        #       nav_panel("Regional Breakdown",
        #                 plotlyOutput("Congest_Regional_Graph")
        #       ),
        #       nav_panel("Division Breakdown",
        #                 plotlyOutput("Congest_Division_Graph")
        #       ),
        #       nav_panel("Dataset",
        #                 dataTableOutput("Congest_Dataset")
        #       )
        #     )
        #     # --- End of Tabset ---
        #   )
        # ),
        
        hr(),
        
        layout_columns(
          card(
            full_screen = TRUE,
            card_header(strong("Congestion Summary Table")),
            dataTableOutput("CongestTable")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("School Mapping")),
            leafletOutput("CongestMapping", height = 800)
          )
        )
      )
      
    }
    else if (selected_resource_type == "Last Mile School") {
      tagList(
        h3("Last Mile Schools (LMS) Overview"),
        hr(),
        
        # --- Accordion for LMS Summaries ---
        accordion(
          open = "National and Regional Breakdown",  # optional: open first panel by default
          
          # 1ï¸âƒ£ Panel: National + Regional Breakdown
          accordion_panel(
            title = "National and Regional Breakdown",
            icon = bsicons::bs_icon("bar-chart"),
            layout_columns(
              # card(
              #   full_screen = TRUE,
              #   card_header(
              #     tagList(
              #       strong("Breakdown of Last Mile Schools"),
              #       tags$br(),
              #       tags$em("(n = 9,100)")
              #     )
              #   ),
              #   # Start of Tabset
              #   navset_tab(
              #     # Tab 1: Regional Breakdown (Your existing content)
              #     # nav_panel("Regional Breakdown",
              #     #           plotlyOutput("LMS_Nation_Graph2")
              #     # ),
              #     # # Tab 2: Division Breakdown (The new tab)
              #     # nav_panel("Priority Divisions",
              #     #           plotlyOutput("LMS_Division_Graph2")
              #     # ),
              #     nav_panel("Dataset",
              #               dataTableOutput("LMS_Dataset")
              #     )
              #   )),
              card(
                card_header(strong("Total Last Mile Schools by Region")),
                valueBoxOutput("LMS_Total_Region")
              ),
              card(
                card_header(strong("Total Last Mile Schools by Division")),
                valueBoxOutput("LMS_Total_Division")
              ),
              col_widths = c(6,6)
            )
          )
        ),
        
        hr(), 
        
        layout_columns(
          card(
            full_screen = TRUE,
            card_header(strong("List of Last Mile Schools")),
            dataTableOutput("LMSTable")
          ),
          card(
            full_screen = TRUE,
            card_header(strong("LMS Mapping")),
            leafletOutput("LMSMapping", height = 800)
          ),
          col_widths = c(6, 6)
        )
      )
    }
  })
  
  #For Division:
  
  output$dashboard_division_filter<- renderUI({
    filtered_division <- c(df[df$Region==input$dashboard_region_filter,"Division"])
    pickerInput(
      inputId = "Dashboard_SDO",
      label = HTML(paste0("Division ", em(style = "font-size: 0.8em;", "(for Legislative District data):"))),
      choices = filtered_division,
      selected = filtered_division[1], # This will select all choices by default
      multiple = TRUE, # Set to TRUE to enable multiple selections
      options = pickerOptions(
        actionsBox = TRUE,
        liveSearch = TRUE,
        header = "Select one or more Divisions",
        title = "No Divisions Selected",
        selectedTextFormat = "count > 3",
        dropupAuto = FALSE,
        dropup = FALSE
      ),
      choicesOpt = list()
    )
  })
  
  output$cloud_dashboard_division_filter <- renderUI({
    filtered_division <- c(df[df$Region==input$cloud_dashboard_region_filter,"Division"])
    selectInput("cloud_Dashboard_SDO",HTML(paste0("Division ", em(style = "font-size: 0.8em;", "(for Legislative District data):"))), filtered_division, selected = filtered_division[1])})
  
  # --- Update Division Picker when Region changes ---
  observeEvent(input$resource_map_region, {
    req(input$resource_map_region)  # make sure region exists
    
    filtered_division <- unique(df[df$Region == input$resource_map_region, "Division"])
    filtered_division <- filtered_division[!is.na(filtered_division) & filtered_division != ""]
    
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "Resource_SDO",
      choices = filtered_division,
      selected = if (length(filtered_division) > 0) filtered_division[1] else NULL
    )
    
    # Reset district when region changes
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "Resource_LegDist",
      choices = NULL,
      selected = NULL
    )
  })
  
  # --- Update District Picker when Division changes ---
  observeEvent(input$Resource_SDO, {
    req(input$Resource_SDO)
    
    filtered_district <- unique(df[df$Division == input$Resource_SDO, "Legislative.District"])
    filtered_district <- filtered_district[!is.na(filtered_district) & filtered_district != ""]
    
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "Resource_LegDist",
      choices = filtered_district,
      selected = if (length(filtered_district) > 0) filtered_district[1] else NULL
    )
  })
  
  observeEvent(TRUE, {
    req(df)
    
    # Initialize only once at startup
    isolate({
      if (!is.null(input$resource_map_region) && input$resource_map_region == "Region I") {
        filtered_division <- unique(df[df$Region == "Region I", "Division"])
        filtered_division <- filtered_division[!is.na(filtered_division) & filtered_division != ""]
        
        shinyWidgets::updatePickerInput(
          session = session,
          inputId = "Resource_SDO",
          choices = filtered_division,
          selected = if (length(filtered_division) > 0) filtered_division[1] else NULL
        )
      }
    })
  })
  
  # Reactive value to store uploaded data
  uploaded_data <- reactiveVal(NULL)
  
  # --- Single reactive value for the currently selected dashboard sub-page ---
  # Default to the first option of the new first category ("General Info" -> "School Count")
  current_dashboard_selection <- reactiveVal("general_school_count")
  
  # --- Observers to update the single selection and deselect others (Dashboard) ---
  observeEvent(input$dashboard_general_selector, {
    if (!is.null(input$dashboard_general_selector)) {
      current_dashboard_selection(input$dashboard_general_selector)
      # Deselect other groups
      updateRadioButtons(session, "dashboard_others_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_resource_shortage_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_infrastructure_selector", selected = character(0))
    }
  })
  
  observeEvent(input$dashboard_others_selector, {
    if (!is.null(input$dashboard_others_selector)) {
      current_dashboard_selection(input$dashboard_others_selector)
      # Deselect other groups
      updateRadioButtons(session, "dashboard_general_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_resource_shortage_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_infrastructure_selector", selected = character(0))
    }
  })
  
  observeEvent(input$dashboard_resource_shortage_selector, {
    if (!is.null(input$dashboard_resource_shortage_selector)) {
      current_dashboard_selection(input$dashboard_resource_shortage_selector)
      # Deselect other groups
      updateRadioButtons(session, "dashboard_general_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_others_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_infrastructure_selector", selected = character(0))
    }
  })
  
  observeEvent(input$dashboard_infrastructure_selector, {
    if (!is.null(input$dashboard_infrastructure_selector)) {
      current_dashboard_selection(input$dashboard_infrastructure_selector)
      # Deselect other groups
      updateRadioButtons(session, "dashboard_general_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_others_selector", selected = character(0))
      updateRadioButtons(session, "dashboard_resource_shortage_selector", selected = character(0))
    }
  })
  
  # --- Dashboard Structure ---
  # Inside your server function:
  output$dashboard_main_content_area <- renderUI({
    req(input$hrod_main_category_picker)
    
    switch(input$hrod_main_category_picker,
           "general_school_count" = {
             tagList(
               h3("School Count Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/6,
                 value_box(title = "Purely ES", value = "35,036"),
                 value_box(title = "JHS with SHS", value = "6,598"),
                 value_box(title = "ES and JHS (K to 10)", value = "1,690"),
                 value_box(title = "Purely JHS", value = "1,367"),
                 value_box(title = "All Offering (K to 12)", value = "832"),
                 value_box(title = "Purely SHS", value = "262")
               ),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,6,6,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional School Count Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO School Count Data"),
                                  plotlyOutput("school_count_division_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District School Count Data"),
                                  plotlyOutput("school_count_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("school_count_data_table")))# This is the target for interaction
               )
             )
           },
           "resource_shortage_classroom" = {
             tagList(
               h3("Classroom Shortage Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/3,
                 value_box(title = "National Classroom Shortage", value = "165,443", showcase = bs_icon("building"))
               ),
               layout_columns(
                 col_widths = c(12,6,6,12), # Keep this as is for now, but consider adjusting for better layout if needed
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional Classroom Shortage Data"),
                                  plotlyOutput("Classroom_Shortage_Region_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Classroom Shortage Data"),
                                  plotlyOutput("Classroom_Shortage_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District Classroom Shortage Data"),
                                  plotlyOutput("Classroom_Shortage_District_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("Classroom_Shortage_All_List"))) # Changed to plotlyOutput
               )
             )
           },
           "resource_lms" = {
             tagList(
               h3("Last Mile Schools Overview (NSBI SY 2023-2024)"),
               hr(),
               layout_columns(
                 col_widths = c(12,12,12),
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional LMS Data"),
                                  plotlyOutput("LMS_Nation_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO LMS Data"),
                                  plotlyOutput("LMS_Division_Graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Classroom Shortage Data"),
                 #                  plotlyOutput("Classroom_Shortage_District_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("LMS_All_List"))) # Changed to plotlyOutput
               )
             )
           },
           "general_sosss" = {
             tagList(
               h3("School Organization and Staffing Standards (SOSSS)"),
               hr(),
               layout_column_wrap(
                 width = 1/7,
                 value_box(title = "Very Small", value = "24,976"),
                 value_box(title = "Small", value = "10,105"),
                 value_box(title = "Medium", value = "5,726"),
                 value_box(title = "Large", value = "4,210"),
                 value_box(title = "Very Large", value = "727"),
                 value_box(title = "Extremely Large", value = "38"),
                 value_box(title = "Mega", value = "3")
               ),
               layout_columns(
                 col_widths = c(12,6,6,12), # Keep as is
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional SOSSS Typology Data"),
                                  plotlyOutput("SOSSS_Region_Typology", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO SOSSS Typology Data"),
                                  plotlyOutput("SOSSS_Division_Typology", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District SOSSS Typology Data"),
                                  plotlyOutput("SOSSS_District_Typology", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("SOSSS_All_List_Typology"))) # Changed to plotlyOutput
               )
             )
           },
           "resource_shortage_principal" = {
             tagList(
               h3("School Principal Shortage Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/3,
                 value_box(title = "School Principal", value = "21,781", showcase = bs_icon("person-badge")),
                 value_box(title = "Teacher-in-Charge", value = "23,370", showcase = bs_icon("exclamation-circle")),
                 value_box(title = "Officer-in-Charge", value = "177", showcase = bs_icon("person-fill-add"))
               ),
               layout_columns(
                 col_widths = c(12,6,6,12),
                 card(full_screen = TRUE,
                      card_header(strong("Regional School Principal Shortage Data"),
                                  plotlyOutput("School_Principal_Regional_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO School Principal Shortage Data"),
                                  plotlyOutput("School_Principal_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District School Principal Shortage Data"),
                                  plotlyOutput("School_Principal_District_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("School_Principal_All_List")))),
             )
           },
           "resource_shortage_teacher" = {
             tagList(
               h3("Teacher Shortage Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/5,
                 value_box(title = "Total Teacher Shortage", value = "32,916", showcase = bs_icon("person-vcard"), theme = "danger"),
                 value_box(title = "ES Shortage", value = "22,023", showcase = bs_icon("exclamation-circle")),
                 value_box(title = "JHS Shortage", value = "9,302", showcase = bs_icon("exclamation-circle")),
                 value_box(title = "SHS Shortage", value = "1,591", showcase = bs_icon("exclamation-circle")),
                 value_box(title = "Total Schools with Teacher Shortage", value = "26,102", showcase = bs_icon("person-vcard"), theme = "danger")
               ),
               layout_columns(
                 col_widths = c(12,12,12), # Keep as is
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional Teacher Shortage Data"),
                                  plotlyOutput("Teacher_Shortage_Regional_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Teacher Shortage Data"),
                                  plotlyOutput("Teacher_Shortage_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Database"),
                                  dataTableOutput("Teacher_Shortage_Regional_Table", height = 500))),
               )
             )
           },
           "resource_shortage_non_teaching" = {
             tagList(
               h3("AO II Shortage Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/3,
                 value_box(title = "Dedicated", value = "12,734", showcase = bs_icon("person-lines-fill")),
                 value_box(title = "Clustered", value = "20,169", showcase = bs_icon("exclamation-circle")),
                 value_box(title = "None Deployed", value = "12,425", showcase = bs_icon("clipboard2-pulse"), theme = "danger")
               ),
               layout_columns(
                 col_widths = c(12,6,6,12), # Keep as is
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional AO II Deployment Data"),
                                  plotlyOutput("AOII_Regional_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO AO II Deployment Data"),
                                  plotlyOutput("AOII_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District AO II Deployment Data"),
                                  plotlyOutput("AOII_District_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("AOII_Data_Table"))), # Changed to plotlyOutput
               ),
               h3("PDO I Shortage Overview"),
               hr(),
               layout_column_wrap(
                 width = 1/2,
                 value_box(title = "With PDO I", value = "1500", showcase = bs_icon("person-lines-fill")),
                 value_box(title = "Without PDO I", value = "43,828", showcase = bs_icon("exclamation-circle"), theme = "danger")
               ),
               layout_columns(
                 col_widths = c(12,6,6,12), # Keep as is
                 # Uncomment and adjust if you need a national data table as a plotly table
                 card(full_screen = TRUE,
                      card_header(strong("Regional PDO I Deployment Data"),
                                  plotlyOutput("PDOI_Regional_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO PDO I Deployment Data"),
                                  plotlyOutput("PDOI_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("Legislative District PDO I Deployment Data"),
                                  plotlyOutput("PDOI_District_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("PDOI_Data_Table"))), # Changed to plotlyOutput
               )
             )
           },
           "others_sufficiency" = {
             tagList(
               h3("Sufficiency Overview"),
               hr(),
               layout_columns(
                 col_widths = c(12,12,12), # Keep as is
                 card(full_screen = TRUE,
                      card_header(strong("Regional Sufficiency Data"),
                                  selectInput("SuffOpt","Select a Category:", multiple = FALSE, selected = "Teacher.Sufficiency", choices = c("Teacher Sufficiency" = "Teacher.Sufficiency","Classroom Sufficiency" = "Classroom.Sufficiency","School Principal Sufficiency" = "SH.Sufficiency", "AO Sufficiency" = "AO.Sufficiency")),
                                  plotlyOutput("Sufficiency_Regional_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Sufficiency Data"),
                                  selectInput("SuffOpt","Select a Category:", multiple = FALSE, selected = "Teacher.Sufficiency", choices = c("Teacher Sufficiency" = "Teacher.Sufficiency","Classroom Sufficiency" = "Classroom.Sufficiency","School Principal Sufficiency" = "SH.Sufficiency", "AO Sufficiency" = "AO.Sufficiency")),
                                  plotlyOutput("Sufficiency_Division_Graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("Sufficiency_All_List"))) # Changed to plotlyOutput
               )
             )
           }
    )
  })
  
  ### CLOUD COMPARE SERVER ###
  
  ### CLOUD SERVER ###
  
  output$cloud_graph_1 <- renderUI({
    req(input$cloud_category_picker_1)
    
    switch(input$cloud_category_picker_1,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  output$cloud_graph_2 <- renderUI({
    req(input$cloud_category_picker_2)
    
    switch(input$cloud_category_picker_2,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  output$cloud_graph_3 <- renderUI({
    req(input$cloud_category_picker_3)
    
    switch(input$cloud_category_picker_3,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  output$cloud_graph_4 <- renderUI({
    req(input$cloud_category_picker_4)
    
    switch(input$cloud_category_picker_4,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  output$cloud_graph_5 <- renderUI({
    req(input$cloud_category_picker_5)
    
    switch(input$cloud_category_picker_5,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  output$cloud_graph_6 <- renderUI({
    req(input$cloud_category_picker_6)
    
    switch(input$cloud_category_picker_6,
           "cloud_enrolment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))))
             )
           },
           "cloud_sned" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ip" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ip_regional_graph", height = 500)))
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500)))
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500)))
               )
             )
           },
           "cloud_als" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500)))
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500)))
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500)))
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500)))
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500)))
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500)))
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500)))
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_adm" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500)))
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500)))
               )
             )
           },
           "cloud_crla" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500)))
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500)))
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500)))
               )
             )
           },
           "cloud_moi" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500)))
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500)))
               )
             )
           },
           "cloud_overload" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500)))
               )
             )
           },
           "cloud_resources" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500)))
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500)))
               )
             )
           },
           "cloud_rf" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500)))
               )
             )
           },
           "cloud_lac" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500)))
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500)))
               )
             )
           },
           "cloud_sha" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500)))
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500)))
               )
             )
           },
           "cloud_support" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500)))
               )
             )
           },
           "cloud_extension" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500)))
               )
             )
           },
           "cloud_years" = {
             tagList(
               layout_columns(
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500)))
               )
             )
           },
           "cloud_elec" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500)))
               )
             )
           },
           "cloud_water" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500)))
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500)))
               )
             )
           },
           "cloud_bully" = {
             tagList(
               layout_columns(
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500)))
               )
             )
           }
           
    )
  })
  
  ### CLOUD SERVER ###
  
  output$cloud_profile_main_content_area <- renderUI({
    layout_columns(
      col_widths = 12,
      card(
        card_header(strong("Enrolment")),
        layout_columns(
          card(
            card_header("Total Enrolment per Category"),
            plotlyOutput("totalenrolment_regional_profile_graph")),
          card(
            card_header("Enrolment"),
            plotlyOutput("enrolment_regional_profile_graph")),
          card(
            card_header("SNED Learners"),
            plotlyOutput("sned_regional_profile_graph")),
          card(
            card_header("IP Learners"),
            plotlyOutput("ip_regional_profile_graph")),
          card(
            card_header("Muslim Learners"),
            plotlyOutput("muslim_regional_profile_graph")),
          card(
            card_header("Displaced Learners"),
            plotlyOutput("displaced_regional_profile_graph")),
          card(
            card_header("ALS Learners"),
            plotlyOutput("als_regional_profile_graph")),
          card(
            card_header("Dropouts"),
            plotlyOutput("dropout_regional_profile_graph")),
          col_widths = c(4,4,4,4,4,4,4,4)
        )
      ),
      card(
        card_header(strong("Teacher Deployment")),
        layout_columns(
          card(
            card_header("Teacher Inventory"),
            plotlyOutput("teacherinventory_regional_profile_graph")),
          card(
            card_header("JHS Teacher Deployment"),
            plotlyOutput("jhsdeployment_regional_profile_graph")),
          card(
            card_header("Teacher Overload"),
            plotlyOutput("overload_regional_profile_graph")),
          card(
            card_header("Multigrade Teachers"),
            plotlyOutput("multigrade_regional_profile_graph")),
          card(
            card_header("Years in Service"),
            plotlyOutput("years_regional_profile_graph")),
          col_widths = c(4,4,4,4,4,4)
        )
      ),
      card(
        card_header(strong("Classroom Data")),
        layout_columns(
          card(
            card_header("Classroom Data"),
            plotlyOutput("classroom_regional_profile_graph")),
          card(
            card_header("Resources Data"),
            plotlyOutput("resources_regional_profile_graph")),
          card(
            card_header("Shifting"),
            plotlyOutput("shifting_regional_profile_graph")),
          card(
            card_header("Organized Class"),
            plotlyOutput("organizedclass_regional_profile_graph")),
          card(
            card_header("Electricity"),
            plotlyOutput("elec_regional_profile_graph")),
          card(
            card_header("Water"),
            plotlyOutput("water_regional_profile_graph")),
          card(
            card_header("Internet"),
            plotlyOutput("internet_regional_profile_graph")),
          card(
            card_header("Internet Usage"),
            plotlyOutput("internet_usage_regional_profile_graph")),
          col_widths = c(4,4,4,4,4,4,4,4)
        )
      ),
      card(
        card_header(strong("Remediation")),
        layout_columns(
          card(
            card_header("Reading Proficiency"),
            plotlyOutput("rf_regional_profile_graph")),
          card(
            card_header("ARAL"),
            plotlyOutput("aral_regional_profile_graph")),
          card(
            card_header("CRLA"),
            plotlyOutput("crla_regional_profile_graph")),
          card(
            card_header("PhilIRI"),
            plotlyOutput("philiri_regional_profile_graph")),
          # card(
          #   card_header("NAT"),
          #   plotlyOutput("nat_regional_profile_graph")),
          # card(
          #   card_header("NAT Sufficiency"),
          #   plotlyOutput("nat_sufficiency_regional_profile_graph")),
          col_widths = c(4,4,4,4)
        )
      ),
      card(
        card_header(strong("Child Protection")),
        layout_columns(
          card(
            card_header("Bullying"),
            plotlyOutput("bully_regional_profile_graph")),
          card(
            card_header("Feeding Program Recipients"),
            plotlyOutput("feeding_regional_profile_graph")),
          col_widths = c(4,4,4,4)
        )
      ))
  })
  
  
  output$cloud_main_content_area <- renderUI({
    req(input$cloud_main_category_picker)
    
    switch(input$cloud_main_category_picker,
           "cloud_enrolment" = {
             tagList(
               h3("Enrolment Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("enrolment_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("enrolment_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("enrolment_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("enrolment_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_sned" = {
             tagList(
               h3("SNED Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("sned_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("sned_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("sned_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("sned_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_ip" = {
             tagList(
               h3("IP Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("RegionalData"),
                                  plotlyOutput("ip_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("ip_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("ip_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("ip_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_muslim" = {
             tagList(
               h3("Muslim Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("muslim_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("muslim_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("muslim_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("muslim_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_displaced" = {
             tagList(
               h3("Displaced Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("displaced_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("displaced_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("displaced_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("displaced_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_als" = {
             tagList(
               h3("ALS Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("als_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("als_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("als_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_dropout" = {
             tagList(
               h3("School Dropout Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("dropout_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("dropout_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("dropout_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("dropout_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_teacherinventory" = {
             tagList(
               h3("Teaching Inventory Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("teacherinventory_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("teacherinventory_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("teacherinventory_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("teacherinventory_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_classroom" = {
             tagList(
               h3("Classroom Inventory"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("classroom_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("classroom_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("classroom_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("classroom_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_multigrade" = {
             tagList(
               h3("Multigrade Classes"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("multigrade_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("multigrade_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("multigrade_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("multigrade_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_organizedclass" = {
             tagList(
               h3("Number of Organized Class"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("organizedclass_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("organizedclass_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("organizedclass_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("organizedclass_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_jhsdeployment" = {
             tagList(
               h3("JHS Deployment"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("jhsdeployment_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("jhsdeployment_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("jhsdeployment_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("jhsdeployment_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_shifting" = {
             tagList(
               h3("Shifting Strategies"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shifting_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("shifting_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("shifting_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("shifting_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_LDM" = {
             tagList(
               h3("Learning Delivery Modality"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("ldm_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("ldm_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("school_count_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("ldm_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_adm" = {
             tagList(
               h3("Alternative Delivery Modality"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("adm_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("adm_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("school_count_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("adm_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_ARAL" = {
             tagList(
               h3("Prospective ARAL Learners"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("aral_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("aral_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("aral_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("aral_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_crla" = {
             tagList(
               h3("CRLA Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("crla_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("crla_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("crla_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("crla_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_philiri" = {
             tagList(
               h3("PhilIRI Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("philiri_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("philiri_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("philiri_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("philiri_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_initiatives" = {
             tagList(
               h3("School Initiatives"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("initiatives_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("initiatives_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("initiatives_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("initiatives_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_moi" = {
             tagList(
               h3("Medium of Instruction"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("moi_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("moi_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("moi_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("moi_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_sosss" = {
             tagList(
               h3("School Organizational Structure and Staffing Standards"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sosss_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("sosss_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("sosss_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("sosss_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_shsimplem" = {
             tagList(
               h3("SHS Implementation"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("shsimplem_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("shsimplem_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("shsimplem_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("shsimplem_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_overload" = {
             tagList(
               h3("Teaching Overload Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("overload_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("overload_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("overload_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("overload_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_resources" = {
             tagList(
               h3("School Resources"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("resources_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("resources_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("resources_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("resources_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_nat" = {
             tagList(
               h3("NAT Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("nat_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("nat_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("nat_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_nat_sufficiency" = {
             tagList(
               h3("NAT Sufficiency Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("nat_sufficiency_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("nat_sufficiency_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("nat_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("nat_sufficiency_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_rf" = {
             tagList(
               h3("Reading Proficiency Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("rf_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("rf_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("nat_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("rf_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_lac" = {
             tagList(
               h3("LAC Sessions"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("lac_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("lac_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("lac_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("lac_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_feeding" = {
             tagList(
               h3("Feeding Program"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("feeding_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("feeding_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("feeding_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("feeding_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_sha" = {
             tagList(
               h3("Special Hardship Allowance"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("sha_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("sha_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("sha_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("sha_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_childprotection" = {
             tagList(
               h3("Child Protection"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("childprotection_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("childprotection_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("childprotection_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("childprotection_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_support" = {
             tagList(
               h3("Support Received"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("support_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("support_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("support_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("support_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_extension" = {
             tagList(
               h3("Extension Schools Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("extension_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("extension_division_graph", height = 500))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("extension_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("extension_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_extension" = {
             tagList(
               h3("Extension Schools Data"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional  Data"),
                                  plotlyOutput("school_count_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("school_count_division_graph", height = 00))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District  Data"),
                 #                  plotlyOutput("school_count_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("school_count_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_years" = {
             tagList(
               h3("Years in Service"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("years_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("years_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("years_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_elec" = {
             tagList(
               h3("Electricity Source"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("elec_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("elec_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("elec_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_water" = {
             tagList(
               h3("Water Source"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("water_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("water_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("water_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_internet" = {
             tagList(
               h3("Internet Source"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("internet_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("internet_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_internet_usage" = {
             tagList(
               h3("Internet Usage"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("internet_usage_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("internet_usage_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("internet_usage_data_table")))# This is the target for interaction
               )
             )
           },
           "cloud_bully" = {
             tagList(
               h3("Recorded Bullying Incidence"),
               hr(),
               layout_columns(
                 # Adjusted col_widths for the three plots/tables to be side-by-side
                 col_widths = c(12,12,12), # Assuming you want 3 columns for these
                 #Uncomment and adjust if you need a national data table as a plotly table
                 # Changed to plotlyOutput
                 card(full_screen = TRUE,
                      card_header(strong("Regional Data"),
                                  plotlyOutput("bully_regional_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("SDO Data"),
                                  plotlyOutput("bully_division_graph", height = 800))),
                 # card(full_screen = TRUE,
                 #      card_header(strong("Legislative District Data"),
                 #                  plotlyOutput("als_district_graph", height = 500))),
                 card(full_screen = TRUE,
                      card_header(strong("School Database"),
                                  dataTableOutput("bully_data_table")))# This is the target for interaction
               )
             )
           }
           
    )
  })
  
  #--------Server Outputs-------------------#
  
  
  filtered_school_data_region <- reactive({
    req(uni)
    
    temp_data <- uni
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    return(temp_data)
  })
  
  filtered_LMS_region <- reactive({
    req(LMS)
    
    temp_data <- LMS
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    return(temp_data)
  })
  
  filtered_teacher_shortage_data_region <- reactive({
    req(DBMProp)
    
    temp_data <- DBMProp
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    return(temp_data)
  })
  
  filtered_teacher_shortage_data_division <- reactive({
    req(DBMProp)
    
    temp_data <- DBMProp
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    if (!is.null(input$dashboard_division_filter) && length(input$dashboard_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Division %in% input$dashboard_division_filter)
    }
    
    return(temp_data)
  })
  
  filtered_school_data_division <- reactive({
    req(uni)
    
    temp_data <- uni
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    if (!is.null(input$dashboard_division_filter) && length(input$dashboard_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Division %in% input$dashboard_division_filter)
    }
    
    return(temp_data)
  })
  # Inside your server function
  # Make sure you have the 'scales' library loaded for comma formatting
  library(scales) # Add this if not already present
  
  # Assuming 'filtered_school_data_region' is a reactive expression that provides
  # the data, similar to how it was introduced in the first response.
  # Make sure your 'filtered_school_data_region' reactive is defined in your server logic.
  
  
  # Server
  output$total_schools_box <- renderUI({
    # Get the count from the reactive data object
    total_schools <- nrow(filtered_school_data_region())
    
    # Create the value_box with the reactive value
    value_box(
      title = "Total Schools in the Selected Regions",
      value = total_schools,
      showcase = bs_icon("building-fill")
    )
  })
  
  output$total_schools_box_div <- renderUI({
    # Get the count from the reactive data object
    total_schools <- nrow(filtered_school_data_division())
    
    # Create the value_box with the reactive value
    value_box(
      title = "Total Schools in the Selected Divisions",
      value = total_schools,
      showcase = bs_icon("building-fill")
    )
  })
  
  output$school_count_regional_graph <- renderPlotly({
    
    # --- If picker is empty, clear the plot ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)  # This will make the plot area blank
    }
    
    # Continue only when there is a selection
    current_filtered_data <- filtered_school_data_region()
    
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected regions/divisions") +
          theme_void()
      ))
    }
    
    coc_levels <- c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
                    "Purely JHS", "All Offering (K to 12)", "Purely SHS")
    
    plot_data <- current_filtered_data %>%
      group_by(Region, Modified.COC) %>%
      summarise(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Modified.COC) %>%
      summarise(TotalCount = sum(Count))
    
    p <- ggplot(plot_data, aes(
      x = factor(Modified.COC, levels = coc_levels),
      y = Count,
      fill = Region,
      text = paste("Region: ", Region,
                   "<br>School Type: ", Modified.COC,
                   "<br>Count: ", scales::comma(Count))
    )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Modified.COC, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs( title = "Regional Distribution of Schools by Curricular Offering", x = "Modified Curricular Offering",
            y = "Number of Schools", fill = "Region") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text")
  })
  
  output$SOSSS_DataTable <- DT::renderDT({
    uni %>% mutate(School.Size.Typology = factor(School.Size.Typology, levels = c("Very Small","Small","Medium","Large","Very Large","Extremely Large","Mega"))) %>% 
      select(School.Size.Typology) %>%
      group_by(School.Size.Typology) %>%
      summarize(Total = n()) %>% 
      pivot_wider(names_from = "School.Size.Typology", values_from = "Total")
  },
  rownames = FALSE,
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ))
  
  output$SOSSS_Region_Typology <- renderPlotly({
    
    # --- Hide plot if Region picker is empty ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    # --- Use filtered region-level data ---
    current_filtered_data <- filtered_school_data_region()
    
    # --- Handle no data case ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected regions") +
                        theme_void()))
    }
    
    # --- Prepare data for plotting ---
    plot_data <- current_filtered_data %>%
      group_by(Region, School.Size.Typology) %>%
      summarise(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(School.Size.Typology) %>%
      summarise(TotalCount = sum(Count))
    
    region_totals <- plot_data %>%
      group_by(Region) %>%
      summarise(TotalCount = sum(Count), .groups = 'drop')
    
    plot_data <- plot_data %>%
      left_join(region_totals, by = "Region") %>%
      mutate(Old.Region_reordered = reorder(Region, -TotalCount))
    
    sosss_levels <- c("Very Small", "Small", "Medium", "Large", 
                      "Very Large", "Extremely Large", "Mega")
    
    # --- Plot ---
    p <- ggplot(plot_data,
                aes(x = factor(School.Size.Typology, levels = sosss_levels),
                    y = Count,
                    fill = Old.Region_reordered,
                    text = paste("Region: ", Region,
                                 "<br>School Size: ", School.Size.Typology,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = School.Size.Typology, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs(
        title = "Regional Distribution of Schools by Size Typology",
        x = "School Size Typology",
        y = "Number of Schools",
        fill = "Region") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "sosssRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100))
  })
  
  
  output$SOSSS_All_List_Typology <- DT::renderDT({
    datatable(
      uni %>%
        select(Region, Division, SchoolID, School.Name, TotalEnrolment, School.Size.Typology) %>%
        mutate(School.Size.Typology = factor(School.Size.Typology, levels = c("Very Small","Small","Medium","Large","Very Large","Extremely Large","Mega"))) %>% 
        filter(Region %in% input$dashboard_region_filter) %>% 
        arrange(School.Size.Typology), # This is the data argument to datatable()
      extension = 'Buttons',  # These are now separate arguments to datatable()
      rownames = FALSE,
      filter = "top",
      options = list(
        scrollX = TRUE,
        pageLength = 10,
        columnDefs = list(list(className = 'dt-center', targets = "_all")),
        dom = 'lfrtip', # Corrected dom string to include 'f' for filter/search input
        buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
      )
    )
  })
  
  observeEvent(input$dashboard_region_filter, {
    # Assuming 'df' is your main dataset and it has a 'Division' column
    # and 'Region' column
    req(input$dashboard_region_filter, df) # Make sure df is available
    
    filtered_divisions <- df %>%
      filter(Region  %in%  input$dashboard_region_filter) %>%
      pull(Division) %>%
      unique() %>%
      sort()
    
    updatePickerInput(
      session = session,
      inputId = "dashboard_division_filter",
      choices = filtered_divisions,
      # CHANGE THIS LINE:
      selected = filtered_divisions[1] # This will select all available divisions
    )
  })
  
  output$Classroom_Shortage_Region_Graph <- renderPlotly({
    
    # Hide plot when no region is selected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_LMS_region()
    
    # Handle empty data
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected regions") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      group_by(Region) %>%
      summarise(Count = sum(as.numeric(Estimated_CL_Shortage), na.rm = TRUE), .groups = 'drop')
    
    # Plot
    p <- ggplot(plot_data,
                aes(x = reorder(Region, -Count),
                    y = Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>Classroom Shortage: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", color = "black") +
      geom_text(aes(y = Count * 1.05, label = scales::comma(Count)),
                size = 3.5, color = "black") +
      labs(title = "Regional Classroom Shortage Distribution", x = "Region", y = "Classroom Shortage") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "none",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "classroomShortageRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100))
  })
  
  
  
  output$LMS_Nation_Graph <- renderPlotly({
    
    # Hide plot when no region is selected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    # Reactive data
    current_filtered_data <- filtered_LMS_region() %>%
      rename(
        "With Buildable Space" = Buildable_space,
        "With Excess Classrooms" = With_Excess,
        "Without Classroom Shortage" = Without_Shortage,
        "Last Mile Schools" = LMS,
        "GIDCA" = GIDCA,
        "With Shortage" = With_Shortage
      ) %>%
      pivot_longer(13:18, names_to = "Type", values_to = "Count")
    
    # Handle empty data
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      group_by(Region, Type) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Type) %>%
      summarise(TotalCount = sum(Count))
    
    # Plot
    p <- ggplot(plot_data,
                aes(x = reorder(Type, -Count),
                    y = Count,
                    fill = Region,
                    text = paste("Type:", Type, "<br>Count:", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Type, y = TotalCount * 1.05, label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs( title = "Regional Distribution of Last Mile School Indicators", x = "Type", y = "Count", fill = "Region") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "right",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "LMS_Region") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) %>%
      style(hoverinfo = "text")
  })
  
  
  # --- Teaching Deployment: Regional Breakdown Graph ---
  output$Teaching_Deployment_Region_Graph <- renderPlotly({
    
    # --- Use the full dataset instead of the filtered one ---
    current_filtered_data <- df  
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data available for Teaching Deployment",
                   size = 5, color = "red") +
          theme_void()
      ))
    }
    
    # --- Prepare grouped data (all regions) ---
    plot_data <- current_filtered_data %>%
      group_by(Region) %>%
      summarise(TeacherShortage = sum(as.numeric(TeacherShortage), na.rm = TRUE),
                .groups = "drop")
    
    # --- Add labels ---
    plot_data <- plot_data %>%
      mutate(Label = scales::comma(TeacherShortage))
    
    # --- Plot ---
    p <- ggplot(plot_data,
                aes(x = reorder(Region, -TeacherShortage),
                    y = TeacherShortage,
                    fill = Region,
                    text = paste("Region:", Region,
                                 "<br>Teacher Shortage:", scales::comma(TeacherShortage)))) +
      geom_bar(stat = "identity", color = "black") +
      geom_text(aes(label = Label), vjust = -0.5, size = 3.5, color = "black") +
      labs(
        title = "Teacher Shortage by Region",
        x = "Region",
        y = "Number of Teacher Shortages"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "none"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      )
  })
  
  
  #Classroom Shortage
  output$Classroom_Shortage_Region_Graph2 <- renderPlotly({
    
    # Use the reactive filtered data
    current_filtered_data <- LMS
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- current_filtered_data %>%
      group_by(Region) %>%
      summarise(Count = sum(as.numeric(Estimated_CL_Shortage), na.rm = TRUE), .groups = 'drop')
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = reorder(Region, -Count),
                    y = Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>Classroom Shortage: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", color = "black") +
      geom_text(data = plot_data,
                aes(x = Region, y = Count * 1.05, label = scales::comma(Count)), # Modified line
                inherit.aes = FALSE,
                size = 3.5,
                color = "black") +
      labs(x = "Region",
           y = "Classroom Shortage") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "none", # No legend needed for single fill
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "classroomShortageRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             # Adjust margins to prevent labels from being cut off if needed
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  #learner congestion
  output$Congest_Regional_Graph <- renderPlotly({
    # --- Use filtered or static data (replace with your reactive dataset) ---
    current_filtered_data <- Learner_Congestion  # Example placeholder
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions") +
          theme_void()
      ))
    }
    
    # --- Data preparation ---
    plot_data <- current_filtered_data %>%
      group_by(Region, Congestion_Level) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = "drop")
    
    # --- Compute region totals ---
    region_totals <- plot_data %>%
      group_by(Region) %>%
      summarise(Total = sum(Count, na.rm = TRUE), .groups = "drop")
    
    # --- Plot ---
    p <- ggplot(plot_data,
                aes(
                  x = reorder(Region, -Count),
                  y = Count,
                  fill = Congestion_Level,
                  text = paste(
                    "Region:", Region,
                    "<br>Congestion Level:", Congestion_Level,
                    "<br>Count:", scales::comma(Count)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(
        data = region_totals,
        aes(x = Region, y = Total * 1.05, label = scales::comma(Total)),
        inherit.aes = FALSE,
        size = 3.5,
        color = "black"
      ) +
      labs(
        title = "Regional Learner Congestion Distribution",
        x = "Region",
        y = "Learner Count",
        fill = "Congestion Level"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      ) %>%
      style(hoverinfo = "text")
  })
  
  output$Congest_Division_Graph <- renderPlotly({
    current_filtered_data <- Learner_Congestion  # Example placeholder
    
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected divisions") +
          theme_void()
      ))
    }
    
    # --- Data preparation ---
    plot_data <- current_filtered_data %>%
      group_by(Division, Congestion_Level) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = "drop") %>%
      arrange(desc(Count)) %>%
      slice_head(n = 20)
    
    division_totals <- plot_data %>%
      group_by(Division) %>%
      summarise(Total = sum(Count, na.rm = TRUE), .groups = "drop")
    
    p <- ggplot(plot_data,
                aes(
                  x = reorder(Division, -Count),
                  y = Count,
                  fill = Congestion_Level,
                  text = paste(
                    "Division:", Division,
                    "<br>Congestion Level:", Congestion_Level,
                    "<br>Count:", scales::comma(Count)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(
        data = division_totals,
        aes(x = Division, y = Total * 1.05, label = scales::comma(Total)),
        inherit.aes = FALSE,
        size = 3.5,
        color = "black"
      ) +
      labs(
        title = "Top 20 Divisions: Learner Congestion Distribution",
        x = "Division",
        y = "Learner Count",
        fill = "Congestion Level"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      ) %>%
      style(hoverinfo = "text")
  })
  
  #Facilities
  output$Facilities_Regional_Graph <- renderPlotly({
    # Placeholder dataset until reactive data is ready
    current_filtered_data <- Facilities
    
    # --- Empty data handler ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data available for selected facilities type") +
          theme_void()
      ))
    }
    
    # --- Data prep ---
    plot_data <- current_filtered_data %>%
      group_by(Region, ProjectType) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = "drop")
    
    region_totals <- plot_data %>%
      group_by(Region) %>%
      summarise(Total = sum(Count, na.rm = TRUE), .groups = "drop")
    
    # --- Chart ---
    p <- ggplot(plot_data,
                aes(
                  x = reorder(Region, -Count),
                  y = Count,
                  fill = ProjectType,
                  text = paste(
                    "Region:", Region,
                    "<br>Project Type:", ProjectType,
                    "<br>Count:", scales::comma(Count)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(
        data = region_totals,
        aes(x = Region, y = Total * 1.05, label = scales::comma(Total)),
        inherit.aes = FALSE,
        size = 3.5,
        color = "black"
      ) +
      labs(
        title = "Regional Breakdown: Facilities Projects",
        x = "Region",
        y = "Number of Projects",
        fill = "Project Type"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(hoverlabel = list(bgcolor = "white"), margin = list(b = 100))
  })
  
  
  output$Facilities_Division_Graph <- renderPlotly({
    # Placeholder dataset
    current_filtered_data <- Facilities
    
    # --- Empty data handler ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data available for selected facilities type") +
          theme_void()
      ))
    }
    
    # --- Data prep ---
    plot_data <- current_filtered_data %>%
      group_by(Division, ProjectType) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = "drop") %>%
      arrange(desc(Count)) %>%
      slice_head(n = 20)  # Top 20 only
    
    division_totals <- plot_data %>%
      group_by(Division) %>%
      summarise(Total = sum(Count, na.rm = TRUE), .groups = "drop")
    
    # --- Chart ---
    p <- ggplot(plot_data,
                aes(
                  x = reorder(Division, -Count),
                  y = Count,
                  fill = ProjectType,
                  text = paste(
                    "Division:", Division,
                    "<br>Project Type:", ProjectType,
                    "<br>Count:", scales::comma(Count)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(
        data = division_totals,
        aes(x = Division, y = Total * 1.05, label = scales::comma(Total)),
        inherit.aes = FALSE,
        size = 3.5,
        color = "black"
      ) +
      labs(
        title = "Top 20 Divisions: Facilities Projects",
        x = "Division",
        y = "Number of Projects",
        fill = "Project Type"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(hoverlabel = list(bgcolor = "white"), margin = list(b = 100))
  })
  
  
  #LMS
  output$LMS_Nation_Graph2 <- renderPlotly({
    full_data <- LMS %>%   
      rename(
        "With Buildable Space" = Buildable_space,
        "With Excess Classrooms" = With_Excess,
        "Without Classroom Shortage" = Without_Shortage,
        "Last Mile Schools" = LMS,
        "GIDCA" = GIDCA,
        "With Shortage" = With_Shortage
      ) %>%
      pivot_longer(13:18, names_to = "Type", values_to = "Count")
    
    # --- Keep only "Last Mile Schools" and aggregate all regions ---
    plot_data <- full_data %>%
      filter(Type == "Last Mile Schools") %>%
      group_by(Region) %>%
      summarise(
        Count = sum(as.numeric(Count), na.rm = TRUE),
        .groups = "drop"
      )
    
    # --- Compute national total ---
    national_total <- sum(plot_data$Count, na.rm = TRUE)
    
    # ---  Create the chart ---
    p <- ggplot(plot_data,
                aes(
                  x = reorder(Region, -Count),
                  y = Count,
                  fill = Region,
                  text = paste(
                    "Region:", Region,
                    "<br>Count:", scales::comma(Count)
                  )
                )) +
      geom_bar(stat = "identity", color = "black", size = 0.25) +
      geom_text(
        aes(label = scales::comma(Count), y = Count * 1.05),
        size = 3.5,
        color = "black"
      ) +
      labs(
        x = "Region",
        y = "Number of Last Mile Schools",
        fill = "Region"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "none"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      ) %>%
      style(hoverinfo = "text")
  })
  
  
  output$LMS_Division_Graph <- renderPlotly({
    
    # Hide plot when region or division is unselected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_LMS_division() %>%
      rename(
        "With Buildable Space" = Buildable_space,
        "With Excess Classrooms" = With_Excess,
        "Without Classroom Shortage" = Without_Shortage,
        "Last Mile Schools" = LMS,
        "GIDCA" = GIDCA,
        "With Shortage" = With_Shortage
      ) %>%
      pivot_longer(13:18, names_to = "Type", values_to = "Count")
    
    # Handle empty data
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected divisions") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      group_by(Division, Type) %>%
      summarise(Count = sum(as.numeric(Count), na.rm = TRUE), .groups = 'drop')
    
    # Plot
    p <- ggplot(plot_data,
                aes(x = reorder(Type, -Count),
                    y = Count,
                    fill = Division,
                    text = paste("Division:", Division,
                                 "<br>Count:", scales::comma(Count)))) +
      geom_bar(stat = "identity", color = "black", size = 0.25) +
      geom_text(data = plot_data,
                aes(x = Type, y = Count * 1.05, label = scales::comma(Count)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs( title = "Division Distribution of Last Mile School Indicators",x = "Division", y = "Count") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "right",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "LMS_Division") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) %>%
      style(hoverinfo = "text")
  })
  
  
  # --- Regional Breakdown: Total number of industries per Region ---
  output$Ind_Regional_Graph <- renderPlotly({
    
    # --- Use your existing dataset name (replace this if named differently)
    plot_data <- ind %>%
      group_by(Region, Sector) %>%
      summarise(Total = n(), .groups = "drop")  # count number of companies
    
    # --- Compute totals per Region for total labels ---
    region_totals <- plot_data %>%
      group_by(Region) %>%
      summarise(Total_All = sum(Total, na.rm = TRUE), .groups = "drop") %>%
      arrange(desc(Total_All))
    
    # --- Make Region an ordered factor for display ---
    plot_data$Region <- factor(plot_data$Region, levels = region_totals$Region)
    region_totals$Region <- factor(region_totals$Region, levels = region_totals$Region)
    
    # --- Create stacked bar chart ---
    p <- ggplot(plot_data,
                aes(
                  x = Region,
                  y = Total,
                  fill = Sector,
                  text = paste0(
                    "Region: ", Region,
                    "<br>Sector: ", Sector,
                    "<br>Count: ", scales::comma(Total)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      
      # --- Add total count label above each Region ---
      geom_text(
        data = region_totals,
        aes(x = Region, y = Total_All, label = scales::comma(Total_All)),
        inherit.aes = FALSE,
        vjust = -0.7,
        size = 3.8,
        fontface = "bold",
        color = "black"
      ) +
      
      labs(
        title = "",
        x = "Region",
        y = "Industry Count",
        fill = "Sector"
      ) +
      scale_y_continuous(
        labels = scales::comma,
        expand = expansion(mult = c(0, 0.12))  # Extra space above bars for labels
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "right"
      )
    
    # --- Convert ggplot to interactive plotly ---
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      ) %>%
      style(hoverinfo = "text")
  })
  
  
  
  # --- Priority Divisions: Total number of industries per Division ---
  output$Ind_Division_Graph <- renderPlotly({
    
    # --- Base dataset ---
    plot_data <- ind %>%
      group_by(Province, Sector) %>%
      summarise(Total = n(), .groups = "drop")
    
    # --- Compute totals per Province for ranking ---
    province_totals <- plot_data %>%
      group_by(Province) %>%
      summarise(Total_All = sum(Total, na.rm = TRUE), .groups = "drop") %>%
      arrange(desc(Total_All)) %>%
      slice_head(n = 20)  # Top 20 provinces
    
    # --- Keep only those top 20 provinces in the main data ---
    plot_data <- plot_data %>%
      filter(Province %in% province_totals$Province)
    
    # --- Make Province an ordered factor for display ---
    plot_data$Province <- factor(plot_data$Province, levels = province_totals$Province)
    province_totals$Province <- factor(province_totals$Province, levels = province_totals$Province)
    
    # --- Create stacked bar chart ---
    p <- ggplot(plot_data,
                aes(
                  x = Province,
                  y = Total,
                  fill = Sector,
                  text = paste0(
                    "Province: ", Province,
                    "<br>Sector: ", Sector,
                    "<br>Count: ", scales::comma(Total)
                  )
                )) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      
      # --- Add total count label above each province ---
      geom_text(
        data = province_totals,
        aes(x = Province, y = Total_All, label = scales::comma(Total_All)),
        inherit.aes = FALSE,   # ðŸ‘ˆ Prevent ggplot from looking for "Sector"
        vjust = -0.7,
        size = 3.8,
        fontface = "bold",
        color = "black"
      ) +
      
      labs(
        title = "",
        x = "Division",
        y = "Industry Count",
        fill = "Sector"
      ) +
      scale_y_continuous(
        labels = scales::comma,
        expand = expansion(mult = c(0, 0.12))  # Extra space above for labels
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        legend.position = "right"
      )
    
    # --- Convert to interactive plotly ---
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 120)
      ) %>%
      style(hoverinfo = "text")
  })
  
  
  output$LMS_All_List  <- DT::renderDT({
    
    data_to_display <- filtered_LMS_division() %>% select(Region, Division, School_Name, With_Excess, Without_Shortage, Buildable_space, LMS, GIDCA) 
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display, # Use the output of your reactive expression
      options = list(
        pageLength = 10, # Number of rows to display per page
        lengthMenu = c(5, 10, 15, 20), # Options for number of rows per page
        searching = TRUE, # Enable search box
        filter = "top",
        paging = TRUE, # Enable pagination
        info = TRUE, # Display table information (e.g., "Showing 1 to 10 of 50 entries")
        ordering = TRUE # Enable column sorting
      ),
      rownames = FALSE # Do not display row names
    )
  })
  
  output$LMS_Dataset  <- DT::renderDT(server = TRUE, {
    
    data_to_display <- LMS %>%
      filter(LMS == 1) %>%
      select(
        Region,
        Division,
        School_Name,
        Total_Enrollment,
        Instructional_Rooms,
        Estimated_CL_Shortage,
        Buildable_space
      ) %>%
      rename(
        "School Name" = School_Name,
        "Total Enrolment" = Total_Enrollment,
        "Number of Classrooms" = Instructional_Rooms,
        "Estimated Classroom Shortage" = Estimated_CL_Shortage,
        "Buildable Space" = Buildable_space
      ) %>%
      # âœ… Convert 0/1 values to Yes/No for Buildable Space
      mutate(`Buildable Space` = ifelse(`Buildable Space` == 1, "Yes", "No"))
    
    # Handle empty data
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'),
        rownames = FALSE
      ))
    }
    
    # Render DataTable
    DT::datatable(
      data_to_display,
      options = list(
        extensions = 'Buttons',
        dom = 'Bfrtip',
        buttons = list('csv', 'excel', 'pdf', 'print'),
        pageLength = 10,
        lengthMenu = c(5, 10, 15, 20),
        searching = TRUE,
        filter = "top",
        paging = TRUE,
        info = TRUE,
        ordering = TRUE
      ),
      rownames = FALSE
    )
  })
  
  
  output$Classroom_Shortage_Dataset  <- DT::renderDT(server = TRUE, {
    
    data_to_display <- LMS %>%
      select(
        Region,
        Division,
        School_Name,
        Total_Enrollment,
        Instructional_Rooms,
        Estimated_CL_Shortage,
        Buildable_space
      ) %>%
      rename(
        "School Name" = School_Name,
        "Total Enrolment" = Total_Enrollment,
        "Number of Classrooms" = Instructional_Rooms,
        "Estimated Classroom Shortage" = Estimated_CL_Shortage,
        "Buildable Space" = Buildable_space
      ) %>%
      # âœ… Convert 0/1 to Yes/No for Buildable Space
      mutate(`Buildable Space` = ifelse(`Buildable Space` == 1, "Yes", "No"))
    
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'),
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(
        extensions = 'Buttons',
        dom = 'Bfrtip',
        buttons = list('csv', 'excel', 'pdf', 'print'),
        pageLength = 10,
        lengthMenu = c(5, 10, 15, 20),
        searching = TRUE,
        filter = "top",
        paging = TRUE,
        info = TRUE,
        ordering = TRUE
      ),
      rownames = FALSE
    )
  })
  
  
  output$Teacher_Shortage_Data_Table <- DT::renderDT({
    # Ensure DBMProp is accessible within this reactive context.
    # If DBMProp is a reactive expression, call it like DBMProp().
    # If it's a static dataframe loaded globally, it's fine as is.
    DBMProp
  },
  rownames = FALSE,
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ))
  
  output$School_Principal_Shortage_Data_Table <- DT::renderDT({
    
    uni %>% filter(Region != "BARMM") %>% mutate(Country = "Philippines") %>%
      select(Country, Designation) %>%
      group_by(Designation) %>%
      summarize(Count = n()) %>% 
      arrange(desc(Count))
  },
  rownames = FALSE,
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ))
  
  # Assuming 'uni' is your original unfiltered data frame for School Principal data
  # Make sure 'uni' is loaded and available in your Shiny app's global environment or server.R
  
  # Define filtered_school_principal_data as a reactive expression in your server logic
  # This reactive expression will filter the 'uni' data based on the selected region and division.
  
  
  output$School_Principal_Regional_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_region()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected regions") +
          theme_void()
      ))
    }
    
    # --- Prepare data ---
    plot_data <- current_filtered_data %>%
      group_by(Region, Designation) %>%
      summarise(Total_Count = n(), .groups = 'drop')
    
    # --- Totals for each Designation ---
    plot_data_totals <- plot_data %>%
      group_by(Designation) %>%
      summarise(TotalCount = sum(Total_Count))
    
    # --- Order of designations ---
    designation_levels <- c("School Principal", "Teacher-in-Charge", "Officer-in-Charge")
    
    # --- Build Plot ---
    p <- ggplot(plot_data,
                aes(x = factor(Designation, levels = designation_levels),
                    y = Total_Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>Designation: ", Designation,
                                 "<br>Total Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Designation, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Designation",
           y = "Total Count of Individuals",
           title = "Regional School Principal Shortage by Designation") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    # --- Convert to Plotly ---
    ggplotly(p, tooltip = "text", source = "schoolPrincipalRegionPlot") %>%
      layout(
        hoverlabel = list(bgcolor = "white"),
        margin = list(b = 100)
      )
  })
  
  
  output$School_Principal_All_List <- DT::renderDT({
    datatable(uni %>% filter(Region != "BARMM") %>% filter(Region %in% input$dashboard_region_filter) %>% select("Division","SchoolID","School.Name","Designation") %>% rename("School" = School.Name, "School ID" = SchoolID), extension = 'Buttons', rownames = FALSE, filter = 'top', options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))})
  
  
  output$AOII_Data_Table <- DT::renderDT({
    uni %>% filter(Region != "BARMM") %>% 
      select(Clustering.Status) %>% 
      mutate(Country = "Philippines") %>%
      group_by(Country,Clustering.Status) %>%
      summarize(Count = n()) %>% 
      select(Clustering.Status, Count) %>% 
      rename("AO II Deployment" = Clustering.Status, "Total" = Count)
  },
  rownames = FALSE,
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ))
  
  output$PDOI_Data_Table <- DT::renderDT({
    uni %>% filter(Region != "BARMM") %>%
      select(PDOI_Deployment) %>% 
      mutate(Country = "Philippines") %>%
      group_by(Country,PDOI_Deployment) %>%
      summarize(Count = n()) %>% 
      select(PDOI_Deployment, Count) %>% 
      rename("PDO I Deployment" = PDOI_Deployment, "Total" = Count)
  },
  rownames = FALSE,
  options = list(
    scrollX = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ))
  
  # Assuming 'uni' is your original unfiltered data frame for AOII Deployment
  # Make sure 'uni' is loaded and available in your Shiny app's global environment or server.R
  
  # Assuming 'filtered_school_data_region' and 'filtered_pdoi_data' are reactive expressions
  # defined in your server logic.
  
  output$AOII_Regional_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_region()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected regions") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Region, Clustering.Status) %>%
      summarise(Total_Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Clustering.Status) %>%
      summarise(TotalCount = sum(Total_Count))
    
    clustering_levels <- c("None Deployed", "Clustered", "Dedicated")
    
    p <- ggplot(plot_data,
                aes(x = factor(Clustering.Status, levels = clustering_levels),
                    y = Total_Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>Clustering Status: ", Clustering.Status,
                                 "<br>Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Clustering.Status, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Clustering Status",
           y = "Total Count of Schools",
           title = "Regional AO II Deployment by Clustering Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "aoiiRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100))
  })
  
  
  output$PDOI_Regional_Graph <- renderPlotly({
    
    # --- Hide plot when no region is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_region()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions") +
          theme_void()
      ))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Region, PDOI_Deployment) %>%
      summarise(Total_Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(PDOI_Deployment) %>%
      summarise(TotalCount = sum(Total_Count))
    
    pdoi_levels <- c("Without PDO I", "With PDO I")
    
    p <- ggplot(plot_data,
                aes(x = factor(PDOI_Deployment, levels = pdoi_levels),
                    y = Total_Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>PDO I Deployment: ", PDOI_Deployment,
                                 "<br>Total Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = PDOI_Deployment, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs(x = "PDO I Deployment",
           y = "Total Count of Schools",
           title = "Regional PDO I Deployment by Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "pdoiRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  # Assuming 'uni' is your original unfiltered data frame for Sufficiency data
  # Make sure 'uni' is loaded and available in your Shiny app's global environment or server.R
  
  # Define filtered_sufficiency_data_region as a reactive expression in your server logic
  # This reactive expression will filter the 'uni' data based on the selected region and division.
  filtered_sufficiency_data_region <- reactive({
    # Ensure uni data is available.
    req(uni)
    
    # Start with the full dataset
    data <- uni
    
    # Data transformation as per your original code, but applied to the filtered data
    data %>%
      select(SchoolID, Region, Division, Teacher, Classroom, School.Head, AO) %>%
      mutate(
        Teacher = as.numeric(Teacher),
        Classroom = as.numeric(Classroom),
        School.Head = as.numeric(School.Head),
        AO = as.numeric(AO) # Ensure AO is also numeric
      ) %>%
      mutate(
        Teacher.Sufficiency = case_when(
          (Teacher >= 0 & Teacher <= 0.25) ~ "Critically Under-Resourced",
          (Teacher > 0.25 & Teacher <= 0.5) ~ "Under-Resourced",
          (Teacher > 0.5 & Teacher <= 0.75) ~ "Resource-Deficient",
          (Teacher > 0.75 & Teacher <= 0.9) ~ "Adequately Resourced",
          (Teacher > 0.9 & Teacher <= 1) ~ "Generously Resourced",
          Teacher > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        Classroom.Sufficiency = case_when(
          (Classroom >= 0 & Classroom <= 0.25) ~ "Critically Under-Resourced",
          (Classroom > 0.25 & Classroom <= 0.5) ~ "Under-Resourced",
          (Classroom > 0.5 & Classroom <= 0.75) ~ "Resource-Deficient",
          (Classroom > 0.75 & Classroom <= 0.9) ~ "Adequately Resourced",
          (Classroom > 0.9 & Classroom <= 1) ~ "Generously Resourced",
          Classroom > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        SH.Sufficiency = case_when(
          (School.Head >= 0 & School.Head <= 0.25) ~ "Critically Under-Resourced",
          (School.Head > 0.25 & School.Head <= 0.5) ~ "Under-Resourced",
          (School.Head > 0.5 & School.Head <= 0.75) ~ "Resource-Deficient",
          (School.Head > 0.75 & School.Head <= 0.9) ~ "Adequately Resourced",
          (School.Head > 0.9 & School.Head <= 1) ~ "Generously Resourced",
          School.Head > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        AO.Sufficiency = case_when(
          (AO >= 0 & AO <= 0.25) ~ "Critically Under-Resourced",
          (AO > 0.25 & AO <= 0.5) ~ "Under-Resourced",
          (AO > 0.5 & AO <= 0.75) ~ "Resource-Deficient",
          (AO > 0.75 & AO <= 0.9) ~ "Adequately Resourced",
          (AO > 0.9 & AO <= 1) ~ "Generously Resourced",
          AO > 1 ~ "For Validation",
          TRUE ~ NA_character_
        )
      ) %>%
      pivot_longer(
        cols = c(Teacher.Sufficiency, Classroom.Sufficiency, SH.Sufficiency, AO.Sufficiency),
        names_to = "Criteria",
        values_to = "Sufficiency"
      ) %>%
      filter(!is.na(Sufficiency)) %>% # Filter NA sufficiency before grouping
      group_by(Region, Criteria, Sufficiency) %>%
      summarise(SufficiencyTotal = n(), .groups = 'drop_last') %>%
      # Calculate the total for each Region and Criteria for percentage calculation
      mutate(RegionCriteriaTotal = sum(SufficiencyTotal)) %>%
      mutate(Percentage = (SufficiencyTotal / RegionCriteriaTotal)) %>%
      ungroup() %>%
      mutate(Sufficiency = factor(Sufficiency, levels = c(
        "Critically Under-Resourced",
        "Under-Resourced",
        "Resource-Deficient",
        "Adequately Resourced",
        "Generously Resourced",
        "For Validation"))) # Ensure consistent order for plotting
  })
  
  
  # Assuming 'filtered_sufficiency_data_region' is a reactive expression that provides
  # the data, similar to how it was introduced in previous responses.
  # Make sure your 'filtered_sufficiency_data_region' reactive is defined in your server logic.
  
  output$Sufficiency_Regional_Graph <- renderPlotly({
    # Use the reactive filtered data
    current_filtered_data_for_plot <- filtered_sufficiency_data_region()
    
    # Filter by the selected category from input$SuffOpt
    plot_data <- current_filtered_data_for_plot %>%
      filter(Criteria == input$SuffOpt)
    
    # --- Empty Data Handling ---
    if (nrow(plot_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = paste("No data for selected regions/divisions and category:", input$SuffOpt)) +
                        theme_void()))
    }
    
    # Determine the title based on the selected input$SuffOpt
    plot_title <- switch(input$SuffOpt,
                         "Teacher.Sufficiency" = "Regional Teacher Sufficiency by Category",
                         "Classroom.Sufficiency" = "Regional Classroom Sufficiency by Category",
                         "SH.Sufficiency" = "Regional School Principal Sufficiency by Category",
                         "AO.Sufficiency" = "Regional AO Sufficiency by Category",
                         "Regional Sufficiency Overview")
    
    # Calculate total percentages per region for the overall labels on top of stacked bars
    # This needs to be done *after* filtering by Criteria
    total_labels_data <- plot_data %>%
      group_by(Region) %>%
      summarise(Grand_Total_Percentage = sum(Percentage), .groups = 'drop') # Sum percentages for labeling
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = reorder(Region, -Percentage), # Reorder regions based on the percentage of the current 'Criteria' and 'Sufficiency'
                    y = Percentage,
                    fill = Sufficiency, # Fill by Sufficiency for stacking
                    text = paste("Region: ", Region,
                                 "<br>Sufficiency: ", Sufficiency,
                                 "<br>Percentage: ", scales::percent(Percentage, accuracy = 0.1),
                                 "<br>Total Schools (Category): ", scales::comma(SufficiencyTotal)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) + # Changed to position="stack" for stacked bars
      labs(x = "Region",
           y = "Percentage",
           fill = "Sufficiency Category") +
      scale_y_continuous(labels = scales::percent, limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Format y-axis as percentage
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "sufficiencyRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$Sufficiency_All_List <- DT::renderDT({
    datatable(
      uni %>% filter(Region %in% input$dashboard_region_filter) %>% 
        select(SchoolID, School.Name, Region, Division, Teacher, Classroom, School.Head, AO) %>%
        mutate(
          Teacher = as.numeric(Teacher),
          Classroom = as.numeric(Classroom),
          School.Head = as.numeric(School.Head)
        ) %>%
        mutate(
          Teacher.Sufficiency = case_when(
            (Teacher >= 0 & Teacher <= 0.25) ~ "Critically Under-Resourced",
            (Teacher > 0.25 & Teacher <= 0.5) ~ "Under-Resourced",
            (Teacher > 0.5 & Teacher <= 0.75) ~ "Resource-Deficient",
            (Teacher > 0.75 & Teacher <= 0.9) ~ "Adequately Resourced",
            (Teacher > 0.9 & Teacher <= 1) ~ "Generously Resourced",
            Teacher > 1 ~ "For Validation",
            TRUE ~ NA_character_
          ),
          Classroom.Sufficiency = case_when(
            (Classroom >= 0 & Classroom <= 0.25) ~ "Critically Under-Resourced",
            (Classroom > 0.25 & Classroom <= 0.5) ~ "Under-Resourced",
            (Classroom > 0.5 & Classroom <= 0.75) ~ "Resource-Deficient",
            (Classroom > 0.75 & Classroom <= 0.9) ~ "Adequately Resourced",
            (Classroom > 0.9 & Classroom <= 1) ~ "Generously Resourced",
            Classroom > 1 ~ "For Validation",
            TRUE ~ NA_character_
          ),
          SH.Sufficiency = case_when(
            (School.Head >= 0 & School.Head <= 0.25) ~ "Critically Under-Resourced",
            (School.Head > 0.25 & School.Head <= 0.5) ~ "Under-Resourced",
            (School.Head > 0.5 & School.Head <= 0.75) ~ "Resource-Deficient",
            (School.Head > 0.75 & School.Head <= 0.9) ~ "Adequately Resourced",
            (School.Head > 0.9 & School.Head <= 1) ~ "Generously Resourced",
            School.Head > 1 ~ "For Validation",
            TRUE ~ NA_character_
          ),
          AO.Sufficiency = case_when(
            (AO >= 0 & AO <= 0.25) ~ "Critically Under-Resourced",
            (AO > 0.25 & AO <= 0.5) ~ "Under-Resourced",
            (AO > 0.5 & AO <= 0.75) ~ "Resource-Deficient",
            (AO > 0.75 & AO <= 0.9) ~ "Adequately Resourced",
            (AO > 0.9 & AO <= 1) ~ "Generously Resourced",
            AO > 1 ~ "For Validation",
            TRUE ~ NA_character_
          )
        ) %>% select("SchoolID","School.Name","Division","Teacher.Sufficiency","Classroom.Sufficiency","SH.Sufficiency","AO.Sufficiency") %>% rename("School" = School.Name, "School ID" = SchoolID, "Teacher Sufficiency" = Teacher.Sufficiency, "Classroom Sufficiency" = Classroom.Sufficiency, "School Principal Sufficiency" = SH.Sufficiency, "AO Sufficiency" = AO.Sufficiency), extension = 'Buttons', rownames = FALSE, filter ='top', options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))})
  
  filtered_divisions_choices <- reactive({
    req(input$selected_region) 
    
    divisions <- EFD_Projects %>%
      filter(Region %in% input$selected_region) %>%
      distinct(Division) %>%
      pull(Division) %>%
      sort()
    
    return(divisions)
  })
  
  # Update Division pickerInput choices and selected values based on selected_region
  observeEvent(filtered_divisions_choices(), {
    # Get the currently selected division(s) from the input
    current_selected <- input$selected_division
    
    # Get the new available choices for divisions from the reactive expression
    new_choices <- filtered_divisions_choices()
    
    # Determine what should be selected
    selected_value <- NULL # Initialize selected_value to NULL
    
    # Logic for determining the selected value:
    if (length(new_choices) > 0) {
      # If there are new choices available:
      if (!is.null(current_selected) && all(current_selected %in% new_choices)) {
        # Case 1: If something was previously selected AND all previous selections are still valid among the new choices,
        # then keep those previous selections. This handles changes in region filters while preserving user intent.
        selected_value <- current_selected
      } else {
        # Case 2: If there's nothing previously selected, OR if the previous selections are no longer valid
        # (e.g., region filter changed and old divisions are gone),
        # then default to selecting ALL of the new available choices. This is crucial for the initial load.
        selected_value <- new_choices
      }
    }
    # Case 3: If new_choices is empty (e.g., no region selected that has divisions),
    # selected_value remains NULL, which correctly results in "Nothing selected".
    
    # Update the picker input with the determined choices and selection
    updatePickerInput(
      session = session,
      inputId = "selected_division",
      choices = new_choices,
      selected = new_choices
    )
  }, ignoreNULL = FALSE, ignoreInit = FALSE) # Ensure ignoreInit is FALSE to run on app start
  
  # Reactive expression for filtered data (by Category, Region AND Division)
  filtered_data <- reactive({
    req(input$selected_category, input$selected_region, input$selected_division)
    
    data_filtered <- EFD_Projects %>% 
      filter(Category %in% input$selected_category) %>%
      filter(Region %in% input$selected_region) %>%
      filter(Division %in% input$selected_division) 
    
    print("--- filtered_data() Check ---")
    print("Categories selected in input:")
    print(input$selected_category)
    print("Regions selected in input:")
    print(input$selected_region) 
    print("Divisions selected in input:") 
    print(input$selected_division)      
    print("Head of filtered_data():")
    print(head(data_filtered))
    print("Unique categories in filtered_data():")
    print(length(unique(data_filtered$Category)))
    print("Rows in filtered_data():")
    print(nrow(data_filtered))
    print("-----------------------------")
    return(data_filtered)
  })
  
  filtered_data2 <- reactive({
    req(input$selected_category, input$selected_region, input$selected_division)
    
    data_filtered <- EFD_Pipeline %>%
      mutate(Allocation = as.numeric(Allocation)) %>% 
      filter(FundingYear <= 2030) %>% 
      filter(Category %in% input$selected_category) %>%
      filter(Region %in% input$selected_region) %>%
      filter(Division %in% input$selected_division) 
    
    print("--- filtered_data() Check ---")
    print("Categories selected in input:")
    print(input$selected_category)
    print("Regions selected in input:")
    print(input$selected_region) 
    print("Divisions selected in input:") 
    print(input$selected_division)      
    print("Head of filtered_data():")
    print(head(data_filtered))
    print("Unique categories in filtered_data():")
    print(length(unique(data_filtered$Category)))
    print("Rows in filtered_data():")
    print(nrow(data_filtered))
    print("-----------------------------")
    return(data_filtered)
  })
  
  filtered_data3 <- reactive({
    req(input$selected_category, input$selected_region, input$selected_division)
    
    data_filtered <- EFD_Projects %>% 
      filter(Category %in% input$selected_category) %>%
      filter(Region %in% input$selected_region) %>%
      filter(Division %in% input$selected_division) 
    
    print("--- filtered_data() Check ---")
    print("Categories selected in input:")
    print(input$selected_category)
    print("Regions selected in input:")
    print(input$selected_region) 
    print("Divisions selected in input:") 
    print(input$selected_division)      
    print("Head of filtered_data():")
    print(head(data_filtered))
    print("Unique categories in filtered_data():")
    print(length(unique(data_filtered$Category)))
    print("Rows in filtered_data():")
    print(nrow(data_filtered))
    print("-----------------------------")
    return(data_filtered)
  })
  
  # Get unique funding years for dynamic value boxes
  alloc_filter <- EFD_Projects
  unique_funding_years <- sort(unique(alloc_filter$FundingYear))
  
  # Get unique categories and regions for filter choices (initial load)
  all_categories <- sort(unique(alloc_filter$Category))
  all_regions <- sort(unique(alloc_filter$Region))
  all_divisions <- sort(unique(alloc_filter$Division)) # All divisions for initial selection
  
  # --- Render Value Boxes for Each Funding Year (using renderText for value) ---
  lapply(unique_funding_years, function(year) {
    output[[paste0("vb_total_alloc_", year)]] <- renderText({
      total_alloc_for_year <- filtered_data() %>%
        filter(FundingYear == year) %>%
        summarise(Total = sum(Allocation, na.rm = TRUE)) %>%
        pull(Total)
      paste0(scales::comma(total_alloc_for_year))
    })
  })
  
  # --- Plot 1: Allocation per Category per FundingYear (Grouped Bar Graph) ---
  output$allocationStackedBar <- renderPlotly({
    # Define the custom color palette
    category_colors <- c(
      "ALS-CLC" = "#E41A1C",
      "Electrification" = "#FF7F00",
      "Gabaldon" = "#4DAF4A",
      "Health" = "#1B9E77",
      "LMS" = "#17BECF",
      "New Construction" = "#A6CEE3",
      "QRF" = "#984EA3",
      "Repairs" = "#F781BF",
      "SPED-ILRC" = "#FDBF6F", # You can choose any color here, this is an example
      "LIH" = "#CAB2D6"       # And another one for LIH
    )
    
    if (nrow(filtered_data3()) == 0) {
      return(ggplotly(ggplot() + annotate("text", x = 0.5, y = 0.5, label = "No data for selected categories/regions/divisions") + theme_void()))
    }
    
    plot_data_stacked <- filtered_data3() %>% 
      group_by(FundingYear, Category) %>%
      summarise(TotalAllocation = sum(Allocation, na.rm = TRUE), .groups = 'drop') %>%
      ungroup() %>%
      # Calculate percentage of each category within its FundingYear
      group_by(FundingYear) %>%
      mutate(
        TotalAllocationYear = sum(TotalAllocation, na.rm = TRUE),
        Percentage = (TotalAllocation / TotalAllocationYear) * 100
      ) %>%
      ungroup()
    
    plot_data_totals <- plot_data_stacked %>% 
      group_by(FundingYear) %>% 
      summarise(GrandTotalAllocation = sum(TotalAllocation, na.rm = TRUE), .groups = 'drop')
    
    p <- ggplot(plot_data_stacked, aes(x = factor(FundingYear), y = TotalAllocation, fill = Category,
                                       text = paste("Year: ", FundingYear,
                                                    "<br>Category: ", Category,
                                                    "<br>Allocation: PhP ", scales::dollar(round(TotalAllocation,2), prefix = "â‚±"),
                                                    "<br>Percentage: ", round(Percentage, 2), "%"), # <--- ADDED PERCENTAGE HERE
                                       key = paste(FundingYear, Category, "allocation"))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25, size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = factor(FundingYear), y = GrandTotalAllocation * 1.05, label = scales::dollar(GrandTotalAllocation, prefix = "â‚±")), # Modified line
                inherit.aes = FALSE,
                size = 3.5,
                color = "black") +
      labs(title = "Total Allocation per Category per Funding Year", x = "Funding Year", y = "Total Allocation (PhP)", fill = "BEFF Allocation") +
      scale_y_continuous(labels = scales::comma) +
      scale_fill_manual(values = category_colors) +
      theme_minimal() +
      theme(legend.position = "bottom")
    
    ggplotly(p, tooltip = "text", source = "stackedBarPlot") %>% layout(hoverlabel = list(bgcolor = "white"))
  })
  
  # --- Plot 3: Allocation Trend per Category per FundingYear (Line Graph) ---
  output$allocationTrendLine <- renderPlotly({
    # Define the custom color palette
    category_colors <- c(
      "ALS-CLC" = "#E41A1C",
      "Electrification" = "#FF7F00",
      "Gabaldon" = "#4DAF4A",
      "Health" = "#1B9E77",
      "LMS" = "#17BECF",
      "New Construction" = "#A6CEE3",
      "QRF" = "#984EA3",
      "Repairs" = "#F781BF",
      "SPED-ILRC" = "#FDBF6F", # You can choose any color here, this is an example
      "LIH" = "#CAB2D6"       # And another one for LIH
    )
    
    if (nrow(filtered_data3()) == 0) {
      return(ggplotly(ggplot() + annotate("text", x = 0.5, y = 0.5, label = "No data for selected categories/regions/divisions") + theme_void()))
    }
    
    plot_data_trend <- filtered_data3() %>% 
      group_by(FundingYear, Category) %>%
      summarise(TotalAllocation = sum(Allocation, na.rm = TRUE), .groups = 'drop') %>%
      ungroup()
    
    p <- ggplot(plot_data_trend, aes(x = FundingYear, y = TotalAllocation, color = Category, group = Category,
                                     text = paste("Year: ", FundingYear,
                                                  "<br>Category: ", Category,
                                                  "<br>Allocation: PhP ", scales::comma(TotalAllocation)))) +
      geom_line(size = 1) +
      geom_point(size = 2) + # Removed aes(color = Category) here as it's already defined globally in ggplot()
      labs(title = "Allocation Trend per Category", x = "Funding Year", y = "Total Allocation (PhP)") +
      scale_y_continuous(labels = scales::comma) +
      scale_x_continuous(breaks = min(plot_data_trend$FundingYear):max(plot_data_trend$FundingYear)) +
      scale_color_manual(values = category_colors) + # <--- ADDED CUSTOM COLORS HERE
      theme_minimal() +
      theme(legend.position = "bottom")
    
    ggplotly(p, tooltip = "text") %>% layout(hoverlabel = list(bgcolor = "white"))
  })
  
  # --- NEW PLOT: Average Completion per Category per Funding Year (Bar Graph) ---
  output$completionByCategoryPlot <- renderPlotly({
    # Define the custom color palette based on your image
    category_colors <- c(
      "ALS-CLC" = "#E41A1C",       # Red
      "Electrification" = "#FF7F00",   # Orange
      "Gabaldon" = "#4DAF4A",       # Green
      "Health" = "#1B9E77",         # Darker Teal-Green
      "LMS" = "#17BECF",            # Teal
      "New Construction" = "#A6CEE3", # Light Blue
      "QRF" = "#984EA3",           # Purple
      "Repairs" = "#F781BF"        # Pink
    )
    
    filtered_data_no_2025 <- filtered_data3() %>%
      filter(FundingYear != 2025)
    
    if (nrow(filtered_data_no_2025) == 0) {
      return(plotly_empty() %>% layout(title = "No data available for selected filters."))
    }
    
    completion_threshold <- 0.0001
    
    category_yearly_avg <- filtered_data_no_2025 %>%
      group_by(FundingYear, Category) %>%
      summarise(AverageCompletion = mean(Completion, na.rm = TRUE), .groups = 'drop') %>%
      filter(AverageCompletion > completion_threshold)
    
    if (nrow(category_yearly_avg) == 0) {
      return(plotly_empty() %>% layout(title = "No data available after filtering for non-zero completion."))
    }
    
    plot_data <- category_yearly_avg %>%
      mutate(FundingYear = factor(FundingYear, levels = sort(unique(FundingYear)))) %>%
      mutate(Category = factor(Category)) %>%
      arrange(FundingYear)
    
    plot_ly(plot_data, x = ~FundingYear, y = ~AverageCompletion, color = ~Category,
            colors = category_colors, # <--- ADDED CUSTOM COLORS HERE
            type = 'bar',
            marker = list(line = list(color = 'black', width = 1)),
            text = ~paste("Year: ", FundingYear, "<br>Category: ", Category, "<br>Avg Completion: ", scales::percent(AverageCompletion, accuracy = 1)),
            hoverinfo = "text",
            source = "completionPlot",
            key = ~paste(FundingYear, Category, "completion")
    ) %>%
      layout(title = "Average Completion per Category per Year",
             xaxis = list(title = "Funding Year", type = "category",
                          categoryorder = "array", categoryarray = levels(plot_data$FundingYear)),
             yaxis = list(title = "Average Completion (%)", tickformat = ".0%", range = c(0, 1)),
             barmode = 'group',
             legend = list(traceorder = "reversed")
      )
  })
  
  output$PipelinePrograms <- renderPlotly({
    # Define the custom color palette
    category_colors <- c(
      "ALS-CLC" = "#E41A1C",        # Red
      "Electrification" = "#FF7F00",    # Orange
      "Gabaldon" = "#4DAF4A",      # Green
      "Health" = "#1B9E77",         # Darker Teal-Green
      "LMS" = "#17BECF",            # Teal
      "New Construction" = "#A6CEE3", # Light Blue
      "QRF" = "#984EA3",            # Purple
      "Repairs" = "#F781BF"         # Pink
    )
    
    # Filter data for FundingYear 2026 onwards
    filtered_data_2026_onwards <- filtered_data2() %>%
      filter(FundingYear >= 2026)
    
    # Check if there's any data after filtering
    if (nrow(filtered_data_2026_onwards) == 0) {
      # Changed to ggplotly and annotate for consistency with allocationStackedBar
      return(ggplotly(ggplot() + annotate("text", x = 0.5, y = 0.5, label = "No data available for 2026 onwards.") + theme_void()))
    }
    
    # Summarize data: Sum Allocation per year and category
    pipeline_programs_summary <- filtered_data_2026_onwards %>%
      group_by(FundingYear, Category) %>%
      summarise(TotalAllocation = sum(Allocation, na.rm = TRUE), .groups = 'drop') %>%
      # Calculate percentage of each category within its FundingYear
      group_by(FundingYear) %>%
      mutate(
        TotalAllocationYear = sum(TotalAllocation, na.rm = TRUE),
        Percentage = (TotalAllocation / TotalAllocationYear) * 100
      ) %>%
      ungroup()
    
    # Check if there's any data after summarization
    if (nrow(pipeline_programs_summary) == 0) {
      # Changed to ggplotly and annotate for consistency
      return(ggplotly(ggplot() + annotate("text", x = 0.5, y = 0.5, label = "No pipeline program data available after aggregation.") + theme_void()))
    }
    
    # Prepare data for plotting (Factor levels for x-axis order)
    plot_data_pipeline <- pipeline_programs_summary %>%
      mutate(FundingYear = factor(FundingYear, levels = sort(unique(FundingYear))))
    # Category already factor from group_by or assumed from previous step. No need for explicit mutate(Category = factor(Category)) if it's already a factor.
    
    # Create the ggplot object
    p <- ggplot(plot_data_pipeline, aes(x = FundingYear, y = TotalAllocation, fill = Category,
                                        text = paste("Year: ", FundingYear,
                                                     "<br>Category: ", Category,
                                                     "<br>Total Allocation: PhP ", scales::comma(TotalAllocation),
                                                     "<br>Percentage: ", round(Percentage, 2), "%"),
                                        key = paste(FundingYear, Category, "pipeline"))) +
      geom_bar(stat = "identity", position = "stack") + # Stacked bar chart
      labs(title = "Total Allocation for Pipeline Programs per Category per Year (2026 Onwards)",
           x = "Funding Year",
           y = "Total Allocation (PhP)") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis as currency with commas
      scale_fill_manual(values = category_colors) + # Apply custom colors
      theme_minimal() + # Minimal theme
      theme(legend.position = "bottom") # Place legend at the bottom
    
    # Convert ggplot to plotly, specifying tooltip to use the 'text' aesthetic
    ggplotly(p, tooltip = "text", source = "pipelinePlot") %>% layout(hoverlabel = list(bgcolor = "white"))
  })
  
  # --- Reactive Values to store the latest click data ---
  rv <- reactiveValues(
    latest_click_key = NULL,
    latest_click_type = NULL 
  )
  
  # Observer for allocation plot clicks
  observeEvent(event_data("plotly_click", source = "stackedBarPlot"), {
    click_data <- event_data("plotly_click", source = "stackedBarPlot")
    if (!is.null(click_data)) {
      rv$latest_click_key <- click_data$key
      rv$latest_click_type <- "allocation"
    }
  })
  
  # Observer for completion plot clicks
  observeEvent(event_data("plotly_click", source = "completionPlot"), {
    click_data <- event_data("plotly_click", source = "completionPlot")
    if (!is.null(click_data)) {
      rv$latest_click_key <- click_data$key
      rv$latest_click_type <- "completion"
    }
  })
  
  # In your server.R file, after your output$PipelinePrograms definition
  
  # Define a reactiveValues object to store click data (if you don't have one already)
  # This should be defined once at the top of your server function:
  # rv <- reactiveValues(latest_click_key = NULL, latest_click_type = NULL)
  
  observeEvent(event_data("plotly_click", source = "pipelinePlot"), { # <--- Changed source to "pipelinePlot"
    click_data <- event_data("plotly_click", source = "pipelinePlot") # <--- Changed source
    if (!is.null(click_data)) {
      # The 'key' attribute you defined in plot_ly is passed here
      # For PipelinePrograms, your key is ~paste(FundingYear, Category, "pipeline")
      rv$latest_click_key <- click_data$key
      rv$latest_click_type <- "pipeline" # <--- Set type to "pipeline" for this graph
      
      # Optional: Print click data to console for debugging
      # print("Click on PipelinePrograms plot:")
      # print(click_data)
      # print(paste("Clicked Key:", click_data$key))
    }
  })
  
  # Your existing output$PipelinePrograms definition would be above this observeEvent
  # output$PipelinePrograms <- renderPlotly({ ... })
  
  # --- Reactive Table Data based on Plotly Click (Updated for Multiple Sources) ---
  output$projectDetailTable <- DT::renderDT(server = TRUE, {
    # Initialize table_to_display with the pre-filtered data
    table_to_display <- filtered_data3()
    
    # Only apply additional filters if a plot segment has been clicked
    if (!is.null(rv$latest_click_key) && !is.null(rv$latest_click_type)) {
      clicked_key <- rv$latest_click_key
      clicked_type <- rv$latest_click_type
      
      clicked_split <- strsplit(as.character(clicked_key), " ")[[1]]
      
      if (length(clicked_split) >= 3) {
        clicked_year <- as.numeric(clicked_split[1])
        clicked_category <- paste(clicked_split[2:(length(clicked_split)-1)], collapse = " ")
        
        # Now, apply specific filters to the ALREADY-FILTERED data
        if (clicked_type == "completion") {
          table_to_display <- table_to_display %>%
            filter(FundingYear == clicked_year, Category == clicked_category, FundingYear != 2025)
        } else if (clicked_type == "allocation") {
          table_to_display <- table_to_display %>%
            filter(FundingYear == clicked_year, Category == clicked_category)
        } else if (clicked_type == "pipeline") {
          table_to_display <- table_to_display %>%
            filter(FundingYear == clicked_year, Category == clicked_category, FundingYear >= 2026)
        }
      }
    }
    
    table_to_display <- table_to_display %>%
      select(Region, Division, SchoolName, FundingYear, Category, Allocation, Completion)
    
    if (nrow(table_to_display) == 0) {
      return(DT::datatable(data.frame(Message = "No project data available for this selection."), options = list(dom = 't')))
    }
    
    DT::datatable(table_to_display %>% mutate(FundingYear = as.character(FundingYear)),
                  options = list(
                    pageLength = 10),
                  filter = 'top',
                  rownames = FALSE
    ) %>%
      formatCurrency('Allocation', currency = 'PhP') %>%
      formatPercentage('Completion', digits = 1)
  })
  
  output$DataBuilder_HROD_SDO <- renderUI({
    
    divisions_vector <- uni %>% 
      filter(Region %in% input$DataBuilder_HROD_Region) %>%
      pull(Division)
    
    # Ensure divisions are unique and sorted
    sorted_unique_divisions <- sort(unique(divisions_vector))
    
    # Create the final choices list
    choices_list <- c(sorted_unique_divisions)
    
    # Check if there are any divisions to display
    if (length(choices_list) > 1) {
      pickerInput(
        inputId = "DataBuilder_SDO",
        label = "Select a Division:",
        choices = choices_list,
        selected = choices_list,
        multiple = TRUE,
        options = pickerOptions(
          actionsBox = TRUE,
          liveSearch = TRUE,
          header = "Select Categories",
          title = "No Category Selected",
          selectedTextFormat = "count > 3",
          dropupAuto = FALSE,
          dropup = FALSE
        ),
        choicesOpt = list()
      )
    } else {
      # Return NULL if there are no divisions to display.
      return(NULL)
    }
  })
  
  output$HROD_Table <- DT::renderDT(server = TRUE, {
    all_regions <- unique(uni$Region)
    all_divisions <- unique(uni$Division)
    
    all_regions_selected <- length(input$DataBuilder_HROD_Region) == length(all_regions)
    all_divisions_selected <- length(input$DataBuilder_SDO) == length(all_divisions)
    
    filtered_uni <- reactive({
      if (all_regions_selected && all_divisions_selected) {
        return(uni)
      } else {
        uni %>%
          filter(Region %in% input$DataBuilder_HROD_Region) %>%
          filter(Division %in% input$DataBuilder_SDO)
      }
    })
    
    datatable(
      filtered_uni() %>%
        mutate(across(where(is.character), ~ str_replace_all(., "Ã±", "n"))) %>%
        mutate(across(18:43, ~ if_else(. == 0, "-", as.character(.)))) %>%
        # Removed input$EFD_Data_Toggles from selection
        select(Region, School.Name, SchoolID, Division, District,
               input$School_Data_Toggles,
               input$Teaching_Data_Toggles,
               input$NTP_Data_Toggles,
               input$Enrolment_Data_Toggles,
               input$Specialization_Data_Toggles) %>%
        arrange(desc(District)),
      extension = 'Buttons',
      filter = 'top',
      options = list(
        scrollX = TRUE,
        fixedColumns = list(leftColumns = 6),
        pageLength = 10,
        columnDefs = list(list(className = 'dt-center', targets = "_all")),
        rownames = FALSE,
        dom = 'Bfrtip',
        buttons = list(
          list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "print", exportOptions = list(modifier = list(page = "all")))
        )
      )
    )
  })
  
  filtered_third <- reactive({
    df <- ThirdLevel %>%
      filter(STRAND %in% input$ThirdLevel_Strands) %>%
      mutate(across(
        c(STRAND, BUREAU.SERVICE, OFFICE, NAME, POSITION, DESIGNATION, TELEPHONE.NUMBER, DEPED.EMAIL),
        ~ ifelse(is.na(.) | . == "", "-", .)
      ))
    
    print(head(df))
    df
    
  })
  
  output$ThirdLevel_Table <- DT::renderDT(server = TRUE, {
    
    
    datatable(
      filtered_third() %>%
        select(
          STRAND,
          OFFICE,
          BUREAU.SERVICE,
          NAME,
          POSITION,
          DESIGNATION,
          TELEPHONE.NUMBER,
          DEPED.EMAIL
        ),
      extension = 'Buttons',
      filter = 'top',
      options = list(
        scrollX = TRUE,
        autoWidth = TRUE,
        fixedColumns = list(leftColumns = 5),
        pageLength = 10,
        columnDefs = list(list(className = 'dt-center', targets = "_all")),
        dom = 'Bfrtip',
        buttons = list(
          list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "print", exportOptions = list(modifier = list(page = "all")))
        )
      )
      
      
    )
  })
  
  # --- EFD Database Server Logic (Updated - Barangay Picker Removed) ---
  
  # Reactive filter logic
  filtered_EFD_reactive <- reactive({
    df <- EFDDB
    
    # Region (single)
    if (!is.null(input$EFD_Region) && nzchar(input$EFD_Region)) {
      df <- df %>% filter(Region == input$EFD_Region)
    }
    
    # Division (multi)
    if (!is.null(input$EFD_Division) && length(input$EFD_Division) > 0) {
      df <- df %>% filter(Division %in% input$EFD_Division)
    }
    
    # Legislative District (multi)
    if (!is.null(input$EFD_LD) && length(input$EFD_LD) > 0) {
      df <- df %>% filter(Legislative.District %in% input$EFD_LD)
    }
    
    df
  })
  
  # --- Render DT (with robust "-" replacement for blanks/NA/#N/A) ---
  output$EFD_Table <- DT::renderDT(server = TRUE, {
    df <- filtered_EFD_reactive()
    
    if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) {
      return(datatable(data.frame(Message = "No data available for current selection.")))
    }
    
    # Handle toggle columns safely
    selected_cols <- if (!is.null(input$EFD_Toggles) && length(input$EFD_Toggles) > 0) {
      intersect(input$EFD_Toggles, names(df))
    } else {
      character(0)
    }
    
    # Ensure no list columns break the table
    df <- df %>%
      mutate(across(where(is.list), ~ sapply(., function(x) {
        if (length(x) == 0) return(NA)
        paste(as.character(x), collapse = ", ")
      })))
    
    # Base columns (Barangay still visible)
    base_cols <- c("Region", "Division", "Legislative.District", "Barangay", "School.Name", "SchoolID")
    base_cols <- base_cols[base_cols %in% names(df)]
    
    # âœ… Replace NA, blank, or any form of "#N/A" (case-insensitive) with "-"
    df <- df %>%
      mutate(across(
        everything(),
        ~ {
          val <- trimws(as.character(.))  # clean spaces and coerce to text
          ifelse(
            is.na(val) | val == "" | grepl("^#N/A$", val, ignore.case = TRUE),
            "-",
            val
          )
        }
      ))
    
    # Prepare final display
    display_df <- df %>%
      mutate(across(where(is.character), ~ stringr::str_replace_all(., "Ã±", "n"))) %>%
      select(all_of(base_cols), any_of(selected_cols))
    
    datatable(
      display_df,
      extension = 'Buttons',
      filter = 'top',
      options = list(
        scrollX = TRUE,
        fixedColumns = list(leftColumns = 4),
        pageLength = 10,
        columnDefs = list(list(className = 'dt-center', targets = "_all")),
        rownames = FALSE,
        dom = 'Bfrtip',
        buttons = list(
          list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "print", exportOptions = list(modifier = list(page = "all")))
        )
      )
    )
  })
  
  # --- Welcome Modal Logic ---
  welcome_modal_shown <- reactiveVal(FALSE) # Track if shown this session
  current_feature_step <- reactiveVal(1)     # Start at Feature 1
  
  # Observer to show the modal when the user authenticates AND is meant to see mgmt_content
  # Observe the user_status reactive value directly
  observeEvent(user_status(), {
    # Trigger only when status becomes 'authenticated'
    req(user_status() == "authenticated")
    
    # Get the authenticated username
    current_user <- authenticated_user()
    req(current_user) # Ensure we have a username
    
    # Determine if this user *should* see the mgmt_content
    # This logic mirrors part of your output$page_ui renderUI
    users_db <- user_database() # Assuming user_database() is available here
    user_row <- users_db[users_db$Email_Address == current_user, ]
    
    should_see_mgmt_content <- FALSE
    if (current_user == "guest_user@stride") {
      should_see_mgmt_content <- TRUE # Guest sees mgmt_content
    } else if (nrow(user_row) == 1) {
      station <- user_row$Station[1]
      # Check if the station is one that should see mgmt_content
      # Adjust this list based on your actual roles/stations
      if (station %in% c("Central Office", "Regional Office", "Schools Division Office")) { # Example stations
        should_see_mgmt_content <- TRUE
      }
    }
    
    # Only proceed if this user should see mgmt_content AND the modal hasn't been shown
    req(should_see_mgmt_content, !welcome_modal_shown())
    
    print("Conditions met: Showing Welcome Modal") # For debugging
    
    # Define the UI for the modal content here (using the corrected version)
    welcomeModalUI <- modalDialog(
      title = tagList(
        bsicons::bs_icon("stars"),
        "Welcome to DepEd STRIDE!"
      ),
      size = "xl",
      easyClose = FALSE,
      footer = NULL,
      tagList(
        # --- CSS Section ---
        tags$head(
          tags$style(HTML("
          /* Video header styles specific to modal */
          #welcomeModal .video-container { /* Target elements inside modal */
            position: relative; width: 100%; height: 30vh; /* Adjust height as needed for modal */
            overflow: hidden; color: white; text-align: center;
            border-radius: 5px; /* Optional: round corners */
          }
          #welcomeModal .video-container video { /* Target elements inside modal */
            position: absolute; top: 50%; left: 50%;
            min-width: 100%; min-height: 100%; width: auto; height: auto;
            transform: translate(-50%, -50%); z-index: 0;
          }
          #welcomeModal .video-container::after { /* Target elements inside modal */
            content: ''; position: absolute; inset: 0;
            background: rgba(0, 0, 0, 0.5); z-index: 1;
          }
          #welcomeModal .video-overlay { /* Target elements inside modal */
            position: relative; z-index: 2; top: 50%; transform: translateY(-50%);
          }
          #welcomeModal .video-overlay h1 { /* Target elements inside modal */
            font-size: 4rem; /* Adjusted for modal */ font-weight: 900; letter-spacing: 0.1em;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7); margin-bottom: 0;
          }
          #welcomeModal .video-overlay h3 { /* Target elements inside modal */
            font-size: 1.5rem; /* Adjusted for modal */ font-weight: 300; letter-spacing: 0.05em;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.7); line-height: 1.2;
          }
          .modal-xl {
  max-width: 95% !important; /* Make it 95% of the screen width */
          }
          .modal-backdrop.show { /* Target the backdrop when it's visible */
            backdrop-filter: blur(5px) !important; /* Apply blur - adjust '5px' as needed */
            /* Optional: Make the backdrop slightly darker/lighter */
            /* background-color: rgba(0, 0, 0, 0.3) !important; */ /* Example: slightly darker semi-transparent black */
          }")) # Correctly closed HTML and tags$style
        ), # Added comma
        
        # --- Video Header ---
        div(
          id = "home_intro_section",
          style = "
    position: relative;
    height: 400px;          /* only the intro section area */
    overflow: hidden;
    border-radius: 20px;
    margin-bottom: 40px;
  ",
          
          # Background Video (only inside this box)
          tags$video(
            src = "home_bg1.mp4",   # ensure it's in www/
            autoplay = NA,
            loop = NA,
            muted = NA,
            playsinline = NA,
            style = "
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      border-radius: 20px;
    "
          ),
          
          # Overlay description
          div(
            class = "video-description",
            style = "
      position: relative;
      z-index: 2;
      text-align: center;
      color: white;
      padding: 60px 20px;
      background: rgba(0, 0, 0, 0.35);
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 20px;
    ",
            
            h1("Welcome to DepEd STRIDE", style = "font-weight: 700; font-size: 5rem; margin-bottom: 10px;"),
            # p("Strategic Inventory for Deployment Efficiency", style = "font-size: 1.2rem; margin-bottom: 15px;"),
            p("A unified data platform for smarter resource planning, teacher deployment, and infrastructure management.", 
              style = "font-size: 1rem; max-width: 800px; color: #f2f2f2;")
          )
        ),
        
        hr(), # Added comma
        
        # --- Short Description ---
        layout_columns(
          col_widths = 12, # Ensure it takes full width
          # --- Quick Tour Introduction ---
          # --- Quick Tour Introduction (in a Card) ---
          card(
            class = "mb-4 text-center", # Add margin below and center text
            style = "border: none; box-shadow: none; background-color: transparent;", # Make it visually subtle
            card_body(
              h3(bsicons::bs_icon("joystick"), "Before you dive in...", class = "mb-3"),
              p(class = "lead mb-0", "Take a quick tour of STRIDE's key features:") # Added mb-0 to reduce bottom margin
            )
          )), # Added comma), # Added comma
        # The "Take a sneak peek..." text is now implicitly covered by the features below.
        # You could add it back explicitly if desired:
        # div(class = "text-center mb-3",
        #     strong("Take a sneak peek of what STRIDE can do!")
        # ),
        
        # --- Feature Section ---
        # --- Feature Section (Wrapped in Cards) ---
        div(class = "mb-4 p-2",
            layout_column_wrap(
              width = 1, # Still stack features vertically
              
              # --- Feature 1: Analytics ---
              card(
                class = "mb-3", # Add margin between cards
                full_screen = TRUE, # Allow card to be expanded
                card_header(tags$h4("Feature 1: In-depth Analytics")),
                card_body(
                  # Content of Feature 1 goes here
                  p(em("The dashboard's interactive visualizations support drill-down functionality. Try and click on any of the bars in the bar graph!"), ""), # Added citation placeholder
                  layout_columns(
                    col_widths = c(4, 4, 4),
                    uiOutput("card_enrollment"),
                    uiOutput("card_teachers"),
                    uiOutput("card_schools")
                  ),
                  div(
                    style = "text-align: left; margin-bottom: 5px; margin-top: 10px;",
                    shinyjs::hidden(actionButton("btn_back", "Back One Level", class = "btn-primary btn-sm"))
                  ),
                  # Inner card for plots can remain or be removed, placing plots directly in body
                  card(
                    # Removed inner card_header
                    card_body(
                      layout_columns(
                        col_widths = c(4, 4, 4),
                        plotlyOutput("plotly_enrollment"),
                        plotlyOutput("plotly_teachers"),
                        plotlyOutput("plotly_schools")
                      )
                    )
                  ) # End inner card for plots
                ) # End card_body for Feature 1
              ), # End card for Feature 1, Added comma
              
              # --- Feature 2: Mapping ---
              card(
                class = "mb-3",
                full_screen = TRUE,
                card_header(tags$h4("Feature 2: Interactive Mapping")),
                card_body(
                  # Content of Feature 2
                  p(em("The dashboard's data table is interactively linked to the geospatial display. Click on any of the rows on the table to see its location on the map!"), ""), # Added citation placeholder
                  # Inner card for map/table can remain or be removed
                  card(
                    card_body(
                      layout_columns(
                        col_widths = c(6,6), # Keeping side-by-side as requested before
                        heights_equal = "row", # Keep heights equal
                        div(style = "height: 100%;", DTOutput("demo_table_2")),
                        leafletOutput("demo_map", height="400px") # Keep height for side-by-side balance
                      )
                    )
                  )
                ) # End card_body for Feature 2
              ), # End card for Feature 2, Added comma
              
              # --- Feature 3: Deployment ---
              card(
                class = "mb-3",
                full_screen = TRUE,
                card_header(tags$h4("Feature 3: Data Deployment")),
                card_body(
                  # Content of Feature 3
                  p(em("The platform features a comprehensive tabular display of school-level data. You can click on the columns to sort the data or search using space below each column. You can also click the download button below to download this table into a CSV file!"), ""), # Added citation placeholder
                  # Inner card for reactable can remain or be removed
                  card(
                    card_body(
                      tagList(
                        reactableOutput("feature_3_table"),
                        div(
                          style = "text-align: right; margin-top: 10px;",
                          downloadButton("download_feature3", "Download Sample Data", class = "btn-primary btn-sm")
                        )
                      )
                    )
                  ) # End inner card
                ) # End card_body for Feature 3
              ) # End card for Feature 3
              
            ) # End layout_column_wrap for features
        ), # End feature container div, Added command feature container div, Added comma
        
        div(class = "text-center p-3", # Reduced padding
            h3("Ready to get started?"),
            actionButton("btn_to_dashboard", "Go to the Dashboard", class = "btn-success btn-lg", `data-bs-dismiss` = "modal") # Added attribute to help close modal
        ),
        hr(),# Added citation placeholder # End button div
      ) # End Main tagList
    ) # End modalDialog
    
    showModal(welcomeModalUI)
    welcome_modal_shown(TRUE) # Mark as shown for this session
    
  }, ignoreNULL = TRUE, ignoreInit = TRUE) # ignoreInit=TRUE prevents running before user_status is set
  
  # Inside the server function
  
  observeEvent(input$btn_to_dashboard, {
    # First, remove the modal if it's open
    removeModal()
    # Then, navigate to the dashboard tab
    # Assuming 'main_nav' is the ID of your main page_navbar or similar container
    # Adjust 'main_nav' and 'dashboard_tab' if your IDs are different
    # This part might need adjustment based on your *actual* main navigation structure.
    # If the button is *inside* the STRIDE2 UI, you need to navigate *within* STRIDE2.
    # Let's navigate to the "Home" tab within STRIDE2 as an example.
    nav_select(id = "STRIDE2_navbar", selected = "home_tab_main") # Replace STRIDE2_navbar and home_tab_main with actual IDs
    # If the goal is to navigate to a different top-level UI (like STRIDE1), the logic would be different.
    # Based on your original code, it seems you want to navigate *within* the current navbar.
    print("Navigating to dashboard tab after closing modal") # For debugging
    
    # !! IMPORTANT !!: You need to know the actual ID of the `page_navbar`
    #                  within STRIDE2 and the `value` of the target `nav_panel`.
    #                  Replace "STRIDE2_navbar" and "home_tab_main" accordingly.
    #                  If your first real tab after Welcome was "Home", use its value.
  })
  
  # If you don't have an ID for the page_navbar inside STRIDE2, add one:
  # In output$STRIDE2 <- renderUI({ page_navbar( id = "STRIDE2_navbar", ... ) })
  # And ensure the target nav_panel has a 'value', e.g., nav_panel(title="Home", value="home_tab_main", ...)
  
  # =====================================================
  # DYNAMIC PICKER UPDATES (Barangay logic removed)
  # =====================================================
  
  # When Region changes
  observeEvent(input$EFD_Region, {
    region_data <- EFDDB %>% filter(Region == input$EFD_Region)
    
    divs <- sort(unique(region_data$Division))
    updatePickerInput(session, "EFD_Division", choices = divs, selected = divs[1])
    
    lds <- sort(unique(region_data$Legislative.District))
    updatePickerInput(session, "EFD_LD", choices = lds, selected = lds[1])
  }, ignoreNULL = TRUE, ignoreInit = FALSE)
  
  # When Division changes
  observeEvent(input$EFD_Division, {
    req(input$EFD_Region)
    
    div_data <- EFDDB %>%
      filter(Region == input$EFD_Region, Division %in% input$EFD_Division)
    
    lds <- sort(unique(div_data$Legislative.District))
    updatePickerInput(session, "EFD_LD", choices = lds, selected = lds[1])
  }, ignoreNULL = TRUE)
  
  # When Legislative District changes (Barangay logic removed)
  observeEvent(input$EFD_LD, {
    req(input$EFD_Region)
  }, ignoreNULL = TRUE)
  
  output$explorer_masterlist_data_table <- DT::renderDT(server = TRUE, {datatable(EFDMP %>% filter(Region == input$explorer_masterlist_region_filter) %>% filter(Division == input$explorer_masterlist_SDO) %>% arrange(desc(FundingYear)) %>% select(Region, Division, District, SchoolID, School.Name,FundingYear,Category,Allocation,Completion,Status), extension = 'Buttons', filter = 'top', options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), rownames = FALSE, dom = 'Bfrtip', buttons = list('csv','excel','print')))})
  
  output$explorer_efd_division_filter <- renderUI({
    req(input$explorer_efd_region_filter) # Ensure region is selected before updating division
    selectInput("explorer_efd_SDO","Select a Division:", 
                choices = c(unique(df[df$Region==input$explorer_efd_region_filter,"Division"])),
                selected = "")
  })
  
  output$explorer_masterlist_division_filter <- renderUI({
    req(input$explorer_masterlist_region_filter) # Ensure region is selected before updating division
    selectInput("explorer_masterlist_SDO","Select a Division:", 
                choices = c(unique(df[df$Region==input$explorer_masterlist_region_filter,"Division"])),
                selected = "")
  })
  
  
  # --- Initialize map only once ---
  output$TextMapping <- renderLeaflet({
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 5) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
      addMeasure(position = "topright",
                 primaryLengthUnit = "kilometers",
                 primaryAreaUnit = "sqmeters") %>%
      addLayersControl(baseGroups = c("Satellite", "Road Map"))
  })
  
  # --- Reactive controls for input and button ---
  observe({
    txt <- trimws(input$text)
    
    # Disable button if text is empty
    shinyjs::toggleState("TextRun", condition = txt != "")
    
    # Show or hide warning message
    output$text_warning <- renderText({
      if (txt == "") {
        "âš  Please enter a school name before showing results."
      } else {
        ""
      }
    })
  })
  
  
  # --- Observe button click ---
  observeEvent(input$TextRun, {
    Text <- trimws(input$text)
    
    # Extra safety check (should not trigger because button is disabled when blank)
    if (Text == "") return()
    
    # --- Filter data based on input ---
    mainreact1 <- uni %>%
      arrange(Region, Division) %>%
      filter(grepl(Text, as.character(School.Name), ignore.case = TRUE))
    
    # --- Handle no matching results ---
    if (nrow(mainreact1) == 0) {
      output$text_warning <- renderText(paste0("âš  No results found for '", Text, "'."))
      leafletProxy("TextMapping") %>%
        clearMarkers() %>%
        clearMarkerClusters()
      output$TextTable <- DT::renderDT(NULL)
      return()
    } else {
      output$text_warning <- renderText("")  # clear any old warning
    }
    
    # --- Create leaflet labels ---
    values.comp <- paste(
      strong("SCHOOL INFORMATION"),
      "<br>School Name:", mainreact1$School.Name,
      "<br>School ID:", mainreact1$SchoolID
    ) %>% lapply(htmltools::HTML)
    
    # --- Update leaflet map ---
    leafletProxy("TextMapping") %>%
      clearMarkers() %>%
      clearMarkerClusters() %>%
      setView(lng = mainreact1$Longitude[1],
              lat = mainreact1$Latitude[1],
              zoom = 4.5) %>%
      addAwesomeMarkers(
        lng = mainreact1$Longitude,
        lat = mainreact1$Latitude,
        icon = makeAwesomeIcon(
          icon = "education",
          library = "glyphicon",
          markerColor = "blue"
        ),
        label = values.comp,
        labelOptions = labelOptions(
          noHide = FALSE,
          textsize = "12px",
          direction = "top",
          fill = TRUE,
          style = list("border-color" = "rgba(0,0,0,0.5)")
        )
      )
    
    df1 <- reactive({
      
      if (is.null(input$TextMapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TextMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    # --- Render DataTable ---
    output$TextTable <- DT::renderDT(server = TRUE, {
      datatable(
        df1() %>%
          select("Region", "Division", "Legislative.District", "Municipality", "School.Name") %>%
          rename("School" = "School.Name"),
        extension = 'Buttons',
        rownames = FALSE,
        options = list(
          scrollX = TRUE,
          pageLength = 10,
          columnDefs = list(list(className = 'dt-center', targets = "_all")),
          dom = 'lrtip'
        ),
        filter = "top"
      )
    })
  })
  
  output$deped <- renderImage({
    list(src="deped.png", width= "100%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$A1 <- renderImage({
    list(src="map.png", width= "100%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$A2 <- renderImage({
    list(src="person.png", width= "100%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$A3 <- renderImage({
    list(src="inform.png", width= "100%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B1 <- renderImage({
    list(src="filter.png", width= "80%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B2 <- renderImage({
    list(src="database.png", width= "80%", 
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B3 <- renderImage({
    list(src="sliders.png", width= "110%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B4 <- renderImage({
    list(src="click.png", width= "70%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B5 <- renderImage({
    list(src="dot.png", width= "70%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  output$B6 <- renderImage({
    list(src="six.png", width= "70%",
         filetype = "image/png"
    )}, deleteFile = FALSE)
  
  
  output$ESEx <- renderValueBox({
    valueBox(strong("50,579"), subtitle = strong("Excess"), icon = icon("users"), color = "blue")
  })
  
  output$ESSh <- renderValueBox({
    valueBox(strong("24,634"), subtitle = strong("Shortage"), icon = icon("users"), color = "red")
  })
  
  output$JHSEx <- renderValueBox({
    valueBox(strong("108,342"), subtitle = strong("Excess"), icon = icon("users"), color = "blue")
  })
  
  output$JHSSh <- renderValueBox({
    valueBox(strong("10,108"), subtitle = strong("Shortage"), icon = icon("users"), color = "red")
  })
  
  output$SHSEx <- renderValueBox({
    valueBox(strong("4,383"), subtitle = strong("Excess"), icon = icon("users"), color = "blue")
  })
  
  output$SHSSh <- renderValueBox({
    valueBox(strong("24,581"), subtitle = strong("Shortage"), icon = icon("users"), color = "red")
  })
  
  output$AO2 <- renderValueBox({
    valueBox(strong("21,262"), subtitle = strong("AOII Items Created"), icon = icon("users"), color = "blue")
  })
  
  output$clustered <- renderValueBox({
    valueBox("9,627", subtitle = "Clustered Schools", icon = icon("school"), color = "green")
  })
  
  output$cos <- renderValueBox({
    valueBox("7,062", subtitle = "Outlier Schools", icon = icon("school"), color = "purple")
  })
  
  output$otherdataselection <- renderUI({
    otherdata2 <- input$OtherData
    data_column <- uni[[otherdata2]]
    selectInput("otherdataselect",strong("Select a Category:"), c(unique(data_column[!is.na(data_column) & data_column != "#N/A" & data_column != "For Verification"])))
  })
  
  output$SDOSelectionGMIS <- renderUI({
    dfGMISRegDiv <- read.csv("GMIS-Apr2025-RegDiv.csv")
    # Get the list of divisions based on the selected region
    divisions <- dfGMISRegDiv[dfGMISRegDiv$Region %in% input$RegionGMIS, "Division"]
    
    # Render the pickerInput
    pickerInput(
      inputId = "SDOGMIS",
      label = "Select a Division:",
      choices = divisions,
      selected = divisions,
      multiple = TRUE,
      options = pickerOptions(
        actionsBox = TRUE, # Changed to TRUE
        liveSearch = TRUE,
        header = "Select one or more Divisions", # Changed header text
        title = "No Divisions Selected", # Changed title text
        selectedTextFormat = "count > 3",
        dropupAuto = FALSE, # This tells it NOT to automatically switch direction
        dropup = FALSE # Added this option
      ),
      choicesOpt = list()
    )
  })
  
  output$PosSelectionGMIS <- renderUI({
    dfGMISPosCat <- read.csv("GMIS-Apr2025-PosCat.csv")
    # Filter the data frame to get positions based on the selected position category
    positions <- sort(unique(dfGMISPosCat$Position))
    
    # Render the pickerInput
    pickerInput(
      inputId = "PosSelGMIS",
      label = "Select a Position:",
      choices = positions,
      selected = c("Teacher I","Teacher II","Teacher III"),
      multiple = TRUE,
      options = pickerOptions(
        actionsBox = TRUE, # Changed to TRUE
        liveSearch = TRUE,
        header = "Select Positions", # Changed header text
        title = "No Positions Selected", # Changed title text
        selectedTextFormat = "count > 3",
        dropupAuto = FALSE, # This tells it NOT to automatically switch direction
        dropup = FALSE # Added this option
      ),
      choicesOpt = list()
    )
  })
  
  ### GMIS Count
  
  observe({
    PosCatGMISRCT <- input$PosCatGMIS
    req(PosCatGMISRCT)
    PosSelGMISRCT <- input$PosSelGMIS
    req(PosSelGMISRCT)
    
    output$itemcount <- renderPlot({
      dfGMIS <- read.csv("GMIS-FillingUpPerPosition-2025.csv")
      mainreact1g <- dfGMIS %>% filter(Position == PosSelGMISRCT) %>% group_by(Region) %>% summarise(Filled = sum(Total.Filled, na.rm = TRUE), Unfilled = sum(Total.Unfilled, na.rm = TRUE)) |>  pivot_longer(cols = c(Filled,Unfilled), names_to = "Category", values_to = "Count")
      ggplot(mainreact1g, aes(x=reorder(Region,-Count), y=Count, fill = factor(Category, levels = c("Unfilled","Filled")))) +
        geom_bar(stat = "identity",position = "stack", color = "black") +
        geom_text(data = subset(mainreact1g, Count != 0), aes(label = Count),vjust =-1,position = position_stack(vjust = 0.5), check_overlap = TRUE)+
        scale_fill_manual(values = c("Filled" = "green","Unfilled" = "grey")) +
        guides(fill = guide_legend(nrow = 1)) + 
        labs(x ="", y="",fill="Inventory")+
        theme(axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
              legend.position = "top")})
    
    output$itemcount2 <- renderPlot({
      dfGMIS <- read.csv("GMIS-FillingUpPerPosition-2025.csv")
      mainreact1g <- dfGMIS %>% filter(Position == PosSelGMISRCT) %>% filter(Region == input$RegionCountItem) %>% group_by(Division) %>% summarise(Filled = sum(Total.Filled, na.rm = TRUE), Unfilled = sum(Total.Unfilled, na.rm = TRUE))  %>%  pivot_longer(cols = c(Filled,Unfilled), names_to = "Category", values_to = "Count")
      ggplot(mainreact1g, aes(x=reorder(Division,-Count), y=Count, fill = factor(Category, levels = c("Unfilled","Filled")))) +
        geom_bar(stat = "identity",position = "stack", color = "black") +
        geom_text(data = subset(mainreact1g, Count != 0), aes(label = Count),vjust =-1, position = position_stack(vjust = 0.5), check_overlap = TRUE)+
        scale_fill_manual(values = c("Filled" = "green","Unfilled" = "grey")) +
        guides(fill = guide_legend(nrow = 1)) + 
        labs(x ="", y="",fill="Inventory")+
        theme(axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
              legend.position = "top")})
  })
  
  observeEvent(input$TextRun, {
    
    Text <- input$text
    
    mainreact1 <- uni %>% arrange(Region) %>% arrange(Division) %>% filter(grepl(Text, as.character(School.Name), ignore.case = TRUE))  #arrange first by Division before filtering & make sure this is the same in row_selected
    
    values.comp <- paste(strong("SCHOOL INFORMATION"),"<br>School Name",mainreact1$School.Name,"<br>School ID:",mainreact1$SchoolID) %>% lapply(htmltools::HTML)
    
    values.df <- paste(mainreact1$School.Name %>% lapply(htmltools::HTML))
    
    leafletProxy("TextMapping") %>% clearMarkers() %>% clearMarkerClusters() %>% setView(lng = mainreact1$Longitude[1], lat = mainreact1$Latitude[1], zoom = 4.5) %>% 
      addAwesomeMarkers(lng = mainreact1$Longitude, lat = mainreact1$Latitude,  icon = makeAwesomeIcon(icon = "education",library = "glyphicon",markerColor = "blue"), label = values.comp, labelOptions = labelOptions(noHide = F, textsize = "12px", direction = "top", fill = TRUE, style = list("border-color" = "rgba(0,0,0,0.5)")))
    
    df1 <- reactive({
      
      if (is.null(input$TextMapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TextMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
  })
  
  observeEvent(input$Facilities_Refresh, {
    
    # Ensure all necessary inputs are ready before proceeding
    req(input$resource_map_region, input$Resource_SDO, input$EFD_Type)
    
    # Filter the data based on user inputs
    mainreactEFD <- EFDMP %>% 
      filter(!is.na(Old.Region), Old.Region != "") %>% 
      filter(!is.na(Latitude), !is.na(Longitude)) %>% 
      mutate(Latitude = as.numeric(Latitude),
             Allocation = dollar(Allocation, prefix = "â‚±")) %>%  # Use 'dollar' to format Allocation) %>% 
      distinct(SchoolID, FundingYear, Allocation, Category, .keep_all = TRUE) %>%
      filter(Region == input$resource_map_region) %>%
      filter(Division == input$Resource_SDO) %>%
      filter(Category %in% input$EFD_Type) %>% 
      mutate(FundingCategory = factor(
        case_when(
          FundingYear < 2025 ~ "Before 2025",
          (FundingYear >= 2025 & FundingYear <= 2030) ~ "2025-2030",
          FundingYear > 2030 ~ "After 2030"
        ),
        levels = c("Before 2025", "2025-2030", "After 2030")
      ))
    
    # This req() is crucial: it stops the code if the filter returns no rows, preventing the crash.
    req(mainreactEFD)
    
    # Now that you have a non-empty data frame, you can use leafletProxy
    
    values.efdmasterlist <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactEFD$School.Name,"<br>School ID:",mainreactEFD$SchoolID,"<br>Category:",mainreactEFD$Category,"<br>Funding Year:",mainreactEFD$FundingYear,"<br>Allocation:",mainreactEFD$Allocation) %>% lapply(htmltools::HTML)
    
    color_palette <- colorFactor(
      palette = c("red", "green", "blue"),
      domain = mainreactEFD$FundingCategory,
      levels = levels(mainreactEFD$FundingCategory) # Ensure the order is respected
    )
    
    # 3. Use the new factor variable and color palette in your leaflet code
    leafletProxy("FacMapping", data = mainreactEFD) %>%
      clearMarkers() %>%
      clearControls() %>%
      setView(lng = mainreactEFD$Longitude[1], lat = mainreactEFD$Latitude[1], zoom = 7) %>%
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
        lng = ~Longitude,
        lat = ~Latitude,
        popup = values.efdmasterlist,
        icon = makeAwesomeIcon(
          icon = "education",
          library = "glyphicon",
          markerColor = case_when(mainreactEFD$FundingCategory == "Before 2025" ~ "red", mainreactEFD$FundingCategory == "2025-2030" ~ "green", mainreactEFD$FundingCategory == "After 2030" ~ "blue") # Use the new factor variable
        )
      ) %>%
      addLegend(
        "bottomright",
        pal = color_palette,
        values = ~FundingCategory, # Use the new factor variable
        title = "Funding Year",
        opacity = 1
      )
    
    dfreact_fac <- reactive({
      if (is.null(input$FacMapping_bounds)) {
        mainreactEFD
      } else {
        bounds <- input$FacMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactEFD,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$FacTable <- DT::renderDT(server = TRUE, {
      datatable(dfreact_fac() %>%
                  arrange(FundingYear) %>% 
                  select("Region","Division","School.Name","FundingYear","Allocation") %>%
                  rename("School" = School.Name, "Funding Year" = FundingYear),
                extension = 'Buttons',
                rownames = FALSE,
                options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))
    })
  })
  
  observeEvent(input$Teaching_Deployment_Refresh, {
    
    output$TeacherShortage_Mapping <- renderLeaflet({
      p = colorFactor(palette = c("red","deepskyblue","green"),domain = c("Shortage","Excess","Balanced"), ordered = T)
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom =6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
        addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>% 
        addLegend(position = "bottomright", title = "Legend", pal = p, values = c("Shortage","Excess","Balanced")) %>% 
        addLayersControl(
          baseGroups = c("Satellite","Road Map"))
    })
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    # Lev <- input$resource_map_level
    
    mainreact1 <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% arrange(desc(TeacherShortage))
    
    NetShortage <- df %>% select(Region,Division,Level,TeacherShortage,TeacherExcess) %>%
      pivot_longer(cols = c(TeacherShortage, TeacherExcess), names_to = "Inventory", values_to = "Count") %>% mutate(Count=as.numeric(Count)) %>% na.omit(Count) %>% group_by(Region, Division,Level, Inventory) %>% summarize(Count = sum(Count)) %>% pivot_wider(names_from = "Inventory", values_from = "Count") %>% mutate(NetShortage=TeacherShortage-TeacherExcess) %>% mutate(NetShortage = ifelse(NetShortage < 0, 0, NetShortage))
    
    SDONetShortage <- NetShortage %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) #%>% filter(Level == Lev)
    
    values_teacher_shortage <- paste(mainreact1$School.Name,"<br>Teacher Excess:", mainreact1$TeacherExcess,"<br>Teacher Shortage:", mainreact1$TeacherShortage) %>% lapply(htmltools::HTML)
    
    values_teacher_shortage_popup <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreact1$School.Name,"<br>School ID:",mainreact1$SchoolID,"<br>Enrolment Size:",mainreact1$TotalEnrolment,"<br>","<br>",strong("TEACHING PERSONNEL DATA"),"<br>Teacher Inventory:", mainreact1$TotalTeachers,"<br>Teacher Excess:", mainreact1$TeacherExcess,"<br>Teacher Shortage:", mainreact1$TeacherShortage,"<br>","<br>",strong("SPECIALIZATION DATA"),"<br>English:", mainreact1$English,"<br>Mathematics:", mainreact1$Mathematics,"<br>Science:", mainreact1$Science,"<br>Biological Science:", mainreact1$Biological.Sciences,"<br>Physical Sciences:", mainreact1$Physical.Sciences,"<br>General Education:", mainreact1$General.Ed,"<br>Araling Panlipunan:", mainreact1$Araling.Panlipunan,"<br>TLE:", mainreact1$TLE,"<br>MAPEH:", mainreact1$MAPEH,"<br>Filipino:", mainreact1$Filipino,"<br>ESP:", mainreact1$ESP,"<br>Agriculture:", mainreact1$Agriculture,"<br>ECE:", mainreact1$ECE,"<br>SPED:", mainreact1$SPED) %>% lapply(htmltools::HTML)
    
    leafletProxy("TeacherShortage_Mapping") %>% clearMarkers() %>% clearMarkerClusters() %>% setView(lng = mainreact1$Longitude[1], lat = mainreact1$Latitude[1], zoom = 7) %>% 
      addAwesomeMarkers(clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15), lng = mainreact1$Longitude, lat = mainreact1$Latitude, popup = values_teacher_shortage_popup, options = popupOptions(), label = values_teacher_shortage, labelOptions = labelOptions(noHide = F, textsize = "12px", direction = "top"), icon = makeAwesomeIcon(icon = "education", library = "glyphicon", markerColor = case_when(mainreact1$TeacherShortage > 0 ~ "red", mainreact1$TeacherExcess > 0 ~ "blue", (mainreact1$TeacherExcess == 0 & mainreact1$TeacherShortage == 0) ~ "green", is.na(mainreact1$TeacherShortage) ~ "gray")))
    
    dfreact_TS <- reactive({
      
      if (is.null(input$TeacherShortage_Mapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TeacherShortage_Mapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    
    
    output$a <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Region==RegRCT & SDO$Division==SDORCT1),"FillUpRate"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$b <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Region==RegRCT & SDO$Division==SDORCT1),"Unfilled"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
    output$e <- renderValueBox({
      valueBox(tags$p(strong(SDONetShortage$NetShortage), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
    output$c <- renderValueBox({
      valueBox(tags$p(strong(sum(df1()$TeacherExcess)), style = "font-size: 65%;"), subtitle = NULL)
      
    })
    
    output$d <- renderValueBox({
      valueBox(tags$p(strong("-"), style = "font-size: 65%;"), subtitle = NULL)})
    
    output$f <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Division==RegRCT),"FillUpRate"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$g <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Division==RegRCT),"Unfilled"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
  })
  
  output$TeacherShortage_Mapping <- renderLeaflet({
    p = colorFactor(palette = c("red","deepskyblue","green"),domain = c("Shortage","Excess","Balanced"), ordered = T)
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom =7) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
      addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>% 
      addLegend(position = "bottomright", title = "Legend", pal = p, values = c("Shortage","Excess","Balanced")) %>% 
      addLayersControl(
        baseGroups = c("Satellite","Road Map"))
  })
  
  output$SHSMapping <- renderLeaflet({
    domain <- c("Manufacturing and Engineering",
                "Hospitality and Tourism",
                "Professional/Private Services",
                "Public Administration",
                "Business and Finance",
                "Agriculture and Agri-business")
    
    p <- colorFactor(
      palette = c("red", "orange", "violet", "green", "blue", "magenta"),
      levels = domain
    )
    
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 6) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%  
      addMeasure(
        position = "topright",
        primaryLengthUnit = "kilometers",
        primaryAreaUnit = "sqmeters"
      ) %>% 
      addLegend(
        position = "bottomright",
        title = "Industry Type",
        pal = p,
        values = domain
      ) %>%
      addLayersControl(
        baseGroups = c("Satellite", "Road Map")
      )
  })
  
  
  output$AO2Mapping <- renderLeaflet({
    p = colorFactor(
      palette = c("red","orange","green"),
      domain = c("No AO II and PDO I","With at least 1 AO II or PDO I","With AO II and PDO I"),
      ordered = TRUE
    )
    
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 6) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%  
      addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>% 
      addLegend(
        position = "bottomright",
        title = "Legend",
        pal = p,
        values = c("No AO II and PDO I","With at least 1 AO II or PDO I","With AO II and PDO I")
      ) %>% 
      addLayersControl(baseGroups = c("Satellite","Road Map"))
  })
  
  # --- Base map with static legend ---
  output$CLMapping <- renderLeaflet({
    # Legend domain + palette
    domain <- c(
      "With Classroom Shortage", 
      "Without Classroom Shortage"
    )
    
    pal <- colorFactor(
      palette = c("red","green"),
      domain = domain,
      ordered = TRUE
    )
    
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 6) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%  
      addMeasure(
        position = "topright",
        primaryLengthUnit = "kilometers",
        primaryAreaUnit = "sqmeters"
      ) %>% 
      addLegend(
        position = "bottomright",
        title = "Legend",
        pal = pal,
        values = domain
      ) %>% 
      addLayersControl(
        baseGroups = c("Satellite","Road Map")
      )
  })
  
  
  output$FacMapping <- renderLeaflet({
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom =6) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
      addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>%
      addLayersControl(
        baseGroups = c("Satellite","Road Map")
      )
  })
  
  values.coord <- paste("Region: ", geojson_table$Region, "<br>",
                        "Learner Congestion:",":", geojson_table$Congestion.Index) %>% lapply(htmltools::HTML)
  
  output$CongestMapping <- renderLeaflet({
    
    pal <- colorBin(
      palette = c("green", "orange", "red"),
      domain = geojson_table$Congestion.Index
    )
    
    domain = c("Not Congested","Moderately Congested","Severely Congested")
    p = colorFactor(palette = c("green","orange","red"), levels = as.factor(domain), ordered = F)
    
    leaflet() %>%
      setView(lng = 122, lat = 13, zoom = 6) %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
      addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>%
      addLayersControl(
        baseGroups = c("Satellite", "Road Map")
      ) %>%
      addTiles() %>%
      addPolygons(
        data = geojson_data,
        stroke = FALSE,
        weight = 4,
        fillOpacity = 0.75,
        fillColor = ~pal(geojson_table$Congestion.Index),
        label = values.coord
      ) %>% 
      addLegend(
        position = "bottomright", 
        title = "Legend", 
        pal = p, 
        values = c("Not Congested","Moderately Congested","Severely Congested"))
  })
  
  
  #LMSTABLE 
  # output$LMSTable <- renderDataTable({
  #   req(LMS, uni, buildablecsv)
  #   
  #   lms_data <- LMS %>%
  #     filter(LMS == 1) %>%   # Step 1: LMS only
  #     left_join(uni, by = c("School_ID" = "SchoolID")) %>%   # Step 2: lat/long
  #     left_join(buildablecsv, by = c(`Buildable_Space` = `Avaiability of Buildable Space (Y/N)`)) %>%  # Step 2: buildable remarks
  #     filter(Region == input$resource_map_region) %>%       # Step 3
  #     filter(Division == input$Resource_SDO) %>%            # Step 3
  #     filter(LD == input$leg_district) %>%                  # Step 3
  #     select(                                                # Step 4
  #       `NAME OF SCHOOL`,
  #       `Avaiability of Buildable Space (Y/N)`,
  #       `OTHER REMARKS (Buildable Space)`
  #     )
  #   
  #   datatable(
  #     lms_data,
  #     options = list(pageLength = 10, scrollX = TRUE, fixedColumns = list(leftColumns = 4)),
  #     selection = "single",   #allow single row selection
  #     extensions = c("FixedColumns") ,
  #     callback = JS("window.dispatchEvent(new Event('resize'));")
  #   )
  # })
  
  # --- LMS Map (initialize once) ---
  
  output$LMSMapping <- renderLeaflet({
    # NOTE: We no longer use colorFactor() as the colors are determined 
    # by case_when in the proxy, which handles the logic. 
    # We just need to define the map structure and the legend colors/labels.
    
    leaflet() %>%
      addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
      addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
      setView(lng = 122, lat = 13, zoom = 6) %>%
      addLayersControl(
        baseGroups = c("Satellite", "Road Map"),
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
      addLegend(
        position = "bottomright",
        title = "Last Mile Schools Status",
        
        # 1. Define the colors (must match the case_when output in leafletProxy)
        colors = c("red", "green", "gray"),
        
        # 2. Define the labels (must describe the conditions that result in those colors)
        labels = c(
          "With Shortage + Without Buildable Space", 
          "With Shortage + With Buildable Space", 
          "Without Shortage + No Buildable Space"
        )
      )
  })
  
  # --- 1. Central Storage for Filtered Data ---
  # This object will hold all our data after the "Run" button is clicked.
  data_filtered <- reactiveValues()
  
  # --- 2. The "Run" Button Observer ---
  # This observer's ONLY job is to filter data and update the data_filtered object.
  observeEvent(input$Mapping_Run, {
    
    # ... (All your renderLeaflet outputs are here, that's fine) ...
    # ... (output$TeacherShortage_Mapping, output$SHSMapping, etc.) ...
    
    # --- (Your original renderLeaflet code from line 2 to 109) ---
    
    output$TeacherShortage_Mapping <- renderLeaflet({
      p = colorFactor(palette = c("red","deepskyblue","green"),domain = c("Shortage","Excess","Balanced"), ordered = T)
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom =6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
        addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>% 
        addLegend(position = "bottomright", title = "Legend", pal = p, values = c("Shortage","Excess","Balanced")) %>% 
        addLayersControl(
          baseGroups = c("Satellite","Road Map"))
    })
    
    output$SHSMapping <- renderLeaflet({
      domain <- c("Manufacturing and Engineering",
                  "Hospitality and Tourism",
                  "Professional/Private Services",
                  "Public Administration",
                  "Business and Finance",
                  "Agriculture and Agri-business")
      
      p <- colorFactor(
        palette = c("red", "orange", "violet", "green", "blue", "magenta"),
        levels = domain
      )
      
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom = 6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
        addMeasure(
          position = "topright",
          primaryLengthUnit = "kilometers",
          primaryAreaUnit = "sqmeters"
        ) %>% 
        addLegend(
          position = "bottomright",
          title = "Industry Type",
          pal = p,
          values = domain
        ) %>%
        addLayersControl(
          baseGroups = c("Satellite", "Road Map")
        )
    })
    
    
    output$AO2Mapping <- renderLeaflet({
      p = colorFactor(
        palette = c("red","orange","green"),
        domain = c("No AO II and PDO I","With at least 1 AO II or PDO I","With AO II and PDO I"),
        ordered = TRUE
      )
      
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom = 6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
        addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>% 
        addLegend(
          position = "bottomright",
          title = "Legend",
          pal = p,
          values = c("No AO II and PDO I","With at least 1 AO II or PDO I","With AO II and PDO I")
        ) %>% 
        addLayersControl(baseGroups = c("Satellite","Road Map"))
    })
    
    # --- Base map with static legend ---
    output$CLMapping <- renderLeaflet({
      # Legend domain + palette
      domain <- c(
        "With Classroom Shortage", 
        "Without Classroom Shortage"
      )
      
      pal <- colorFactor(
        palette = c("red","green"),
        domain = domain,
        ordered = TRUE
      )
      
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom = 6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>% 
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>% 
        addMeasure(
          position = "topright",
          primaryLengthUnit = "kilometers",
          primaryAreaUnit = "sqmeters"
        ) %>% 
        addLegend(
          position = "bottomright",
          title = "Legend",
          pal = pal,
          values = domain
        ) %>% 
        addLayersControl(
          baseGroups = c("Satellite","Road Map")
        )
    })
    
    
    output$FacMapping <- renderLeaflet({
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom =6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
        addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>%
        addLayersControl(
          baseGroups = c("Satellite","Road Map")
        )
    })
    
    values.coord <- paste("Region: ", geojson_table$Region, "<br>",
                          "Learner Congestion:",":", geojson_table$Congestion.Index) %>% lapply(htmltools::HTML)
    
    output$CongestMapping <- renderLeaflet({
      
      pal <- colorBin(
        palette = c("green", "orange", "red"),
        domain = geojson_table$Congestion.Index
      )
      
      domain = c("Not Congested","Moderately Congested","Severely Congested")
      p = colorFactor(palette = c("green","orange","red"), levels = as.factor(domain), ordered = F)
      
      leaflet() %>%
        setView(lng = 122, lat = 13, zoom = 6) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
        addMeasure(position = "topright", primaryLengthUnit = "kilometers", primaryAreaUnit = "sqmeters") %>%
        addLayersControl(
          baseGroups = c("Satellite", "Road Map")
        ) %>%
        addTiles() %>%
        addPolygons(
          data = geojson_data,
          stroke = FALSE,
          weight = 4,
          fillOpacity = 0.75,
          fillColor = ~pal(geojson_table$Congestion.Index),
          label = values.coord
        ) %>% 
        addLegend(
          position = "bottomright", 
          title = "Legend", 
          pal = p, 
          values = c("Not Congested","Moderately Congested","Severely Congested"))
    })
    
    
    # ... (Commented-out LMSTable) ...
    
    # --- LMS Map (initialize once) ---
    
    output$LMSMapping <- renderLeaflet({
      # ... (LMSMapping renderLeaflet code) ...
      
      leaflet() %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
        addProviderTiles(providers$CartoDB.Positron, group = "Road Map") %>%
        setView(lng = 122, lat = 13, zoom = 6) %>%
        addLayersControl(
          baseGroups = c("Satellite", "Road Map"),
          options = layersControlOptions(collapsed = FALSE)
        ) %>%
        addLegend(
          position = "bottomright",
          title = "Last Mile Schools Status",
          
          # 1. Define the colors (must match the case_when output in leafletProxy)
          colors = c("red", "green", "gray"),
          
          # 2. Define the labels (must describe the conditions that result in those colors)
          labels = c(
            "With Shortage + Without Buildable Space", 
            "With Shortage + With Buildable Space", 
            "Without Shortage + No Buildable Space"
          )
        )
    })
    
    # ... (Commented-out code blocks) ...
    
    # --- (End of your original renderLeaflet code) ---
    
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    Lev <- input$resource_map_level
    TypeEFD <- input$EFD_Type
    
    # --- DATA PREPARATION ---
    # (Your mainreact... definitions are here)
    mainreact1 <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% arrange(desc(TeacherShortage))
    mainreactreg <- df %>% filter(Region == RegRCT)
    mainreactunireg <- uni %>% filter(Region == RegRCT)
    mainreactunidiv <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    mainreactdiv <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    mainreactNTP <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1)
    mainreactlevreg <- df %>% filter(Region == RegRCT) #%>% filter(Level == Lev)
    mainreactlevdiv <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) #%>% filter(Level == Lev)
    mainreactCR <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% distinct(SchoolID, .keep_all = TRUE) %>% arrange(desc(SBPI))
    mainreactSHS <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% filter(Level == "SHS") %>% distinct(SchoolID, .keep_all = TRUE) #Remove the filter of Pilot 2 CLEA4
    mainreactind <- ind %>% filter(Region == RegRCT)
    mainreactEFD <- EFDMP %>% 
      filter(!is.na(Old.Region), Old.Region != "") %>% 
      filter(!is.na(Latitude), !is.na(Longitude)) %>% 
      mutate(Latitude = as.numeric(Latitude),
             Allocation = dollar(Allocation, prefix = "â‚±")) %>% # Use 'dollar' to format Allocation) %>% 
      distinct(SchoolID, FundingYear, Allocation, Category, .keep_all = TRUE) %>%
      arrange(FundingYear) %>%
      filter(Region == input$resource_map_region) %>%
      filter(Division == input$Resource_SDO) %>%
      filter(Category %in% input$EFD_Type) %>% 
      mutate(FundingCategory = factor(
        case_when(
          FundingYear < 2025 ~ "Before 2025",
          (FundingYear >= 2025 & FundingYear <= 2030) ~ "2025-2030",
          FundingYear > 2030 ~ "After 2030"
        ),
        levels = c("Before 2025", "2025-2030", "After 2030")
      ))
    mainreactLMS <- LMS %>%
      filter(LMS == 1) %>%
      left_join(buildablecsv %>% select(SCHOOL.ID,OTHER.REMARKS..Buildable.Space..), by = c("School_ID" = "SCHOOL.ID")) %>% 
      filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    mainreactLMSreg <- LMS %>%
      filter(LMS == 1) %>%    # Step 1: LMS only
      left_join(buildablecsv %>% select(SCHOOL.ID,OTHER.REMARKS..Buildable.Space..), by = c("School_ID" = "SCHOOL.ID")) %>% 
      filter(Region == RegRCT)
    mainreactLMSdiv <- LMS %>%
      filter(LMS == 1) %>%    # Step 1: LMS only
      left_join(buildablecsv %>% select(SCHOOL.ID,OTHER.REMARKS..Buildable.Space..), by = c("School_ID" = "SCHOOL.ID")) %>% 
      filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    mainreactCRreg <- LMS %>% 
      filter(Region == RegRCT)
    mainreactCRdiv <- LMS %>% 
      filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    
    
    # --- START DEBUGGING BLOCK ---
    # We will print the column names and structure of EVERY data frame
    # used for mapping. Look for "Latitude" and "Longitude".
    
    cat("\n\n=============== MAP DATA DEBUGGER ===============\n")
    
    # --- 1. Check data for LMSMapping ---
    cat("\n--- [1] Data for LMSMapping (mainreactLMS) ---\n")
    if (exists("mainreactLMS") && !is.null(mainreactLMS) && nrow(mainreactLMS) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactLMS))
      cat("\nStructure:\n")
      print(str(mainreactLMS[, c("School_Name", "Latitude", "Longitude")], 
                list.len = 5)) # Only show relevant columns
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 2. Check data for SHSMapping (Schools) ---
    cat("\n--- [2] Data for SHSMapping (Schools: mainreactSHS) ---\n")
    if (exists("mainreactSHS") && !is.null(mainreactSHS) && nrow(mainreactSHS) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactSHS))
      cat("\nStructure:\n")
      print(str(mainreactSHS[, c("School.Name", "Latitude", "Longitude")], 
                list.len = 5))
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 3. Check data for SHSMapping (Industry) ---
    cat("\n--- [3] Data for SHSMapping (Industry: mainreactind) ---\n")
    if (exists("mainreactind") && !is.null(mainreactind) && nrow(mainreactind) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactind))
      cat("\nStructure:\n")
      # Assuming 'Company' is a column, adjust if needed
      print(str(mainreactind[, c("Company", "Latitude", "Longitude")], 
                list.len = 5)) 
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 4. Check data for CLMapping ---
    cat("\n--- [4] Data for CLMapping (mainreactCR) ---\n")
    if (exists("mainreactCR") && !is.null(mainreactCR) && nrow(mainreactCR) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactCR))
      cat("\nStructure:\n")
      print(str(mainreactCR[, c("School.Name", "Latitude", "Longitude")], 
                list.len = 5))
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 5. Check data for AO2Mapping & CongestMapping ---
    cat("\n--- [5] Data for AO2/Congest Maps (mainreactNTP) ---\n")
    if (exists("mainreactNTP") && !is.null(mainreactNTP) && nrow(mainreactNTP) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactNTP))
      cat("\nStructure:\n")
      print(str(mainreactNTP[, c("School.Name", "Latitude", "Longitude")], 
                list.len = 5))
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 6. Check data for TeacherShortage_Mapping ---
    cat("\n--- [6] Data for TeacherShortage_Mapping (mainreact1) ---\n")
    if (exists("mainreact1") && !is.null(mainreact1) && nrow(mainreact1) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreact1))
      cat("\nStructure:\n")
      print(str(mainreact1[, c("School.Name", "Latitude", "Longitude")], 
                list.len = 5))
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    # --- 7. Check data for FacMapping ---
    cat("\n--- [7] Data for FacMapping (mainreactEFD) ---\n")
    if (exists("mainreactEFD") && !is.null(mainreactEFD) && nrow(mainreactEFD) > 0) {
      cat("Column Names:\n")
      print(colnames(mainreactEFD))
      cat("\nStructure:\n")
      print(str(mainreactEFD[, c("School.Name", "Latitude", "Longitude")], 
                list.len = 5))
    } else {
      cat("Data is NULL or has 0 rows!\n")
    }
    
    cat("\n=============== END DEBUGGING ===============\n\n")
    
    # --- END DEBUGGING BLOCK ---
    
    
    
    # --- POPUP AND LABEL CREATION ---
    # (Your original code for values... and leafletProxy calls)
    
    values.LMS <- paste(
      "School Name:",mainreactLMS$School_Name,
      "<br>Division:", mainreactLMS$Division,
      "<br>Leg. District:", mainreactLMS$Legislative_District,
      "<br>Number of Classrooms:", mainreactLMS$Instructional_Rooms,
      "<br>Classroom Requirement:", mainreactLMS$CL_Req,
      "<br>Estimated Classroom Shortage:", mainreactLMS$Estimated_CL_Shortage,
      "<br>Buildable Space:", ifelse(mainreactLMS$Buildable_space == 1, "Yes", "No")) %>% lapply(htmltools::HTML)
    
    
    # This validate() line will STOP execution if the columns are missing
    # This is a safer way to prevent the crash
    validate(
      need(
        "Longitude" %in% colnames(mainreactLMS) && "Latitude" %in% colnames(mainreactLMS),
        "Error: LMSMapping data is missing Latitude or Longitude columns."
      )
    )
    
    leafletProxy("LMSMapping") %>%
      clearMarkers() %>%
      clearMarkerClusters() %>%
      setView(
        lng = mainreactLMS$Longitude[1],
        lat = mainreactLMS$Latitude[1],
        zoom = 7
      ) %>%
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 12),
        lng = mainreactLMS$Longitude,
        lat = mainreactLMS$Latitude,
        icon = makeAwesomeIcon(icon = "education", library = "glyphicon",
                               markerColor = case_when(
                                 (mainreactLMS$Buildable_space == 0 & mainreactLMS$Estimated_CL_Shortage == 0) ~ "gray",
                                 mainreactLMS$Buildable_space == 0 ~ "red", # Corrected to '=='
                                 mainreactLMS$Buildable_space == 1 ~ "green", # Corrected to '=='
                               )),
        label = values.LMS,
        labelOptions = labelOptions(noHide = F, textsize = "12px", direction = "top")
      )
    
    df1 <- reactive({
      
      if (is.null(input$LMSMapping_bounds)) {
        mainreactLMS
      } else {
        bounds <- input$LMSMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactLMS,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    
    output$LMSTable <- renderDT(server = FALSE, {
      
      # ... (LMSTable code) ...
      
      # Final select
      finalLMS <- df1() %>%
        # 1. Convert Buildable_space from 1/0 to "Yes"/"No"
        dplyr::mutate(
          Buildable_space = dplyr::if_else(Buildable_space == 1, "Yes", "No")
        ) %>%
        # 2. Select the desired columns
        dplyr::select(
          School_Name,
          Total_Enrollment,
          Instructional_Rooms,
          Estimated_CL_Shortage,
          Buildable_space
        ) %>%
        # 3. Rename columns for display
        dplyr::rename(
          "School Name" = School_Name,
          "Total Enrolment" = Total_Enrollment,,
          "Classrooms Inventory" = Instructional_Rooms,
          "Classroom Shortage" = Estimated_CL_Shortage,
          "Buildable Space" = Buildable_space
        )
      
      datatable(
        finalLMS,
        options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip',
                       buttons = list('csv', 'excel', 'pdf', 'print'), columnDefs = list(list(className = 'dt-center', targets = "_all"))),
        selection = "single",  # allow single row selection
        extension = 'Buttons',
        rownames = FALSE,
        callback = JS("window.dispatchEvent(new Event('resize'));") # Final closing parenthesis was missing
      )
    })
    
    
    NetShortage <- df %>% select(Region,Division,Level,TeacherShortage,TeacherExcess) %>%
      pivot_longer(cols = c(TeacherShortage, TeacherExcess), names_to = "Inventory", values_to = "Count") %>% mutate(Count=as.numeric(Count)) %>% na.omit(Count) %>% group_by(Region, Division,Level, Inventory) %>% summarize(Count = sum(Count)) %>% pivot_wider(names_from = "Inventory", values_from = "Count") %>% mutate(NetShortage=TeacherShortage-TeacherExcess) %>% mutate(NetShortage = ifelse(NetShortage < 0, 0, NetShortage))
    
    SDONetShortage <- NetShortage %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) #%>% filter(Level == Lev)
    
    values_teacher_shortage <- paste(mainreact1$School.Name,"<br>Teacher Excess:", mainreact1$TeacherExcess,"<br>Teacher Shortage:", mainreact1$TeacherShortage) %>% lapply(htmltools::HTML)
    
    values_teacher_shortage_popup <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreact1$School.Name,"<br>School ID:",mainreact1$SchoolID,"<br>Enrolment Size:",mainreact1$TotalEnrolment,"<br>","<br>",strong("TEACHING PERSONNEL DATA"),"<br>Teacher Inventory:", mainreact1$TotalTeachers,"<br>Teacher Excess:", mainreact1$TeacherExcess,"<br>Teacher Shortage:", mainreact1$TeacherShortage,"<br>","<br>",strong("SPECIALIZATION DATA"),"<br>English:", mainreact1$English,"<br>Mathematics:", mainreact1$Mathematics,"<br>Science:", mainreact1$Science,"<br>Biological Science:", mainreact1$Biological.Sciences,"<br>Physical Sciences:", mainreact1$Physical.Sciences,"<br>General Education:", mainreact1$General.Ed,"<br>Araling Panlipunan:", mainreact1$Araling.Panlipunan,"<br>TLE:", mainreact1$TLE,"<br>MAPEH:", mainreact1$MAPEH,"<br>Filipino:", mainreact1$Filipino,"<br>ESP:", mainreact1$ESP,"<br>Agriculture:", mainreact1$Agriculture,"<br>ECE:", mainreact1$ECE,"<br>SPED:", mainreact1$SPED) %>% lapply(htmltools::HTML)
    
    values.non_teaching <- mainreactNTP$School.Name %>% lapply(htmltools::HTML)
    
    values.non_teaching_popup <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactNTP$School.Name,"<br>School ID:",mainreactNTP$SchoolID,"<br>Enrolment Size:",mainreactNTP$TotalEnrolment,"<br>","<br>",strong("TEACHING PERSONNEL DATA"),"<br>Teacher Inventory:", mainreactNTP$TotalTeachers,"<br>Teacher Excess:", mainreactNTP$TeacherExcess,"<br>Teacher Shortage:", mainreactNTP$TeacherShortage,"<br>","<br>",strong("NON-TEACHING PERSONNEL DATA"),"<br>Plantilla Number of AOII:", mainreactNTP$Plantilla.Number,"<br>Clustering Status:", mainreactNTP$Clustering.Status,"<br>PDO I Deployment:", mainreactNTP$PDOI_Deployment) %>% lapply(htmltools::HTML)
    
    values_classrooom_shortage <- paste(mainreactCR$School.Name,"<br>Total Enrolment:",mainreactCR$Enrolment.2023.2024 ,"<br>Classroom Inventory:", mainreactCR$Instructional.Rooms.2023.2024, "<br>Classroom Shortage:", mainreactCR$Est.CS) %>% lapply(htmltools::HTML)
    
    values_classrooom_shortage_popup <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactCR$School.Name,"<br>School ID:",mainreactCR$SchoolID,"<br>Enrolment Size:",mainreactCR$TotalEnrolment,"<br>","<br>",strong("CLASSROOM DATA"),"<br>Estimate Classroom Shortage:", mainreactCR$Est.CS,"<br>Type of Ownership:", mainreactCR$OwnershipType,"<br>Shifting:", mainreactCR$Shifting,"<br>Electricity Source:", mainreactCR$ElectricitySource,"<br>Water Source:", mainreactCR$WaterSource) %>% lapply(htmltools::HTML)
    
    values.efdmasterlist <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactEFD$School.Name,"<br>School ID:",mainreactEFD$SchoolID,"<br>Category:",mainreactEFD$Category,"<br>Funding Year:",mainreactEFD$FundingYear,"<br>Allocation:",mainreactEFD$Allocation) %>% lapply(htmltools::HTML)
    
    
    values_industry <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactSHS$School.Name,"<br>School ID:",mainreactSHS$SchoolID) %>% lapply(htmltools::HTML)
    
    values.ind <- paste(mainreactind$Company,"<br>Province:",mainreactind$Province) %>% lapply(htmltools::HTML)
    
    # --- More validate() checks ---
    validate(
      need(
        "Longitude" %in% colnames(mainreactSHS) && "Latitude" %in% colnames(mainreactSHS),
        "Error: SHSMapping (Schools) data is missing Latitude or Longitude."
      ),
      need(
        "Longitude" %in% colnames(mainreactind) && "Latitude" %in% colnames(mainreactind),
        "Error: SHSMapping (Industry) data is missing Latitude or Longitude."
      )
    )
    
    leafletProxy("SHSMapping") %>%
      clearMarkers() %>%
      clearMarkerClusters() %>%
      setView(
        lng = mainreactSHS$Longitude[1],
        lat = mainreactSHS$Latitude[1],
        zoom = 7
      ) %>%
      
      # --- SHS Schools (always orange university icons) ---
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
        lng = mainreactSHS$Longitude,
        lat = mainreactSHS$Latitude,
        icon = makeAwesomeIcon(
          icon = "university",
          library = "fa",
          markerColor = "orange"  
        ),
        label = values_industry,
        labelOptions = labelOptions(
          noHide = FALSE,
          textsize = "12px",
          direction = "top",
          fill = TRUE,
          style = list("border-color" = "rgba(0,0,0,0.5)")
        )
      ) %>%
      
      # --- Industry markers (cog icons, colored by sector) ---
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 12),
        lng = mainreactind$Longitude,
        lat = mainreactind$Latitude,
        icon = makeAwesomeIcon(
          icon = "cog",
          library = "fa",
          markerColor = dplyr::case_when(
            mainreactind$Sector == "Manufacturing and Engineering"     ~ "red",
            mainreactind$Sector == "Hospitality and Tourism"           ~ "orange",
            mainreactind$Sector == "Professional/Private Services"     ~ "purple",
            mainreactind$Sector == "Public Administration"             ~ "green",
            mainreactind$Sector == "Business and Finance"              ~ "blue",
            mainreactind$Sector == "Agriculture and Agri-business"     ~ "pink",
            TRUE                                                      ~ "gray"
          )
        ),
        label = values.ind,
        labelOptions = labelOptions(
          noHide = FALSE,
          textsize = "12px",
          direction = "top"
        )
      )
    
    # --- Update markers with leafletProxy ---
    observe({
      req(mainreactCR)
      
      # --- Add validate() here too ---
      validate(
        need(
          "Longitude" %in% colnames(mainreactCR) && "Latitude" %in% colnames(mainreactCR),
          "Error: CLMapping data is missing Latitude or Longitude."
        )
      )
      
      icons <- awesomeIcons(
        icon = "university",
        library = "fa",
        markerColor = case_when(
          suppressWarnings(as.numeric(mainreactCR$Est.CS)) > 0 ~ "red",
          TRUE ~ "green"
        ),
        iconColor = "white"
      )
      
      leafletProxy("CLMapping") %>%
        clearMarkers() %>%
        clearMarkerClusters() %>%
        setView(
          lng = mainreactCR$Longitude[1],
          lat = mainreactCR$Latitude[1],
          zoom = 7
        ) %>%
        addAwesomeMarkers(
          clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
          lng = mainreactCR$Longitude,
          lat = mainreactCR$Latitude,
          popup = values_classrooom_shortage_popup,
          options = popupOptions(),
          label = values_classrooom_shortage,
          labelOptions = labelOptions(
            noHide = FALSE,
            textsize = "12px",
            direction = "top"
          ),
          icon = icons
        )
    })
    
    validate(
      need(
        "Longitude" %in% colnames(mainreactNTP) && "Latitude" %in% colnames(mainreactNTP),
        "Error: AO2Mapping data is missing Latitude or Longitude."
      )
    )
    
    leafletProxy("AO2Mapping") %>%
      clearMarkers() %>%
      clearMarkerClusters() %>%
      setView(lng = mainreactNTP$Longitude[1], lat = mainreactNTP$Latitude[1], zoom = 7) %>%
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
        lng = mainreactNTP$Longitude,
        lat = mainreactNTP$Latitude,
        popup = values.non_teaching_popup,
        options = popupOptions(),
        label = values.non_teaching,
        labelOptions = labelOptions(noHide = FALSE, textsize = "12px", direction = "top"),
        icon = makeAwesomeIcon(
          icon = "user",
          library = "fa",
          markerColor = case_when(
            mainreactNTP$Clustering.Status %in% c("Dedicated","Clustered") & mainreactNTP$PDOI_Deployment == "With PDO I" ~ "green",
            mainreactNTP$Clustering.Status %in% c("Dedicated","Clustered") & mainreactNTP$PDOI_Deployment == "Without PDO I" ~ "orange",
            mainreactNTP$Clustering.Status == "None Deployed" & mainreactNTP$PDOI_Deployment == "With PDO I" ~ "orange",
            mainreactNTP$Clustering.Status == "None Deployed" & mainreactNTP$PDOI_Deployment == "Without PDO I" ~ "red",
            TRUE ~ "lightgray"
          )
        )
      )
    
    validate(
      need(
        "Longitude" %in% colnames(mainreact1) && "Latitude" %in% colnames(mainreact1),
        "Error: TeacherShortage_Mapping data is missing Latitude or Longitude."
      )
    )
    
    leafletProxy("TeacherShortage_Mapping") %>% clearMarkers() %>% clearMarkerClusters() %>% setView(lng = mainreact1$Longitude[1], lat = mainreact1$Latitude[1], zoom = 7) %>% 
      addAwesomeMarkers(clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15), lng = mainreact1$Longitude, lat = mainreact1$Latitude, popup = values_teacher_shortage_popup, options = popupOptions(), label = values_teacher_shortage, labelOptions = labelOptions(noHide = F, textsize = "12px", direction = "top"), icon = makeAwesomeIcon(icon = "education", library = "glyphicon", markerColor = case_when(mainreact1$TeacherShortage > 0 ~ "red", mainreact1$TeacherExcess > 0 ~ "blue", (mainreact1$TeacherExcess == 0 & mainreact1$TeacherShortage == 0) ~ "green", is.na(mainreact1$TeacherShortage) ~ "gray")))
    
    dfreact_TS <- reactive({
      
      if (is.null(input$TeacherShortage_Mapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TeacherShortage_Mapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$TeacherShortage_Table <- DT::renderDT(server = FALSE, {datatable(dfreact_TS() %>% select("School.Name","TeacherShortage","TeacherExcess") %>% rename("School" = School.Name, "Shortage" = TeacherShortage, "Excess" = TeacherExcess), extension = 'Buttons', rownames = FALSE, options = list(scrollX = TRUE, pageLength = 5, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))})
    
    # ... (All your renderValueBox and other outputs) ...
    
    output$a <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Region==RegRCT & SDO$Division==SDORCT1),"FillUpRate"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$b <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Region==RegRCT & SDO$Division==SDORCT1),"Unfilled"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
    output$e <- renderValueBox({
      valueBox(tags$p(strong(SDONetShortage$NetShortage), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
    output$c <- renderValueBox({
      valueBox(tags$p(strong(sum(df1()$TeacherExcess)), style = "font-size: 65%;"), subtitle = NULL)
      
    })
    
    output$d <- renderValueBox({
      valueBox(tags$p(strong("-"), style = "font-size: 65%;"), subtitle = NULL)})
    
    output$f <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Division==RegRCT),"FillUpRate"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$g <- renderValueBox({
      valueBox(tags$p(strong(SDO[which(SDO$Division==RegRCT),"Unfilled"]), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
      
    })
    
    output$Single <- renderValueBox({
      valueBox(strong(sum(mainreactdiv$Clustering.Status == "NOT CLUSTERED")), subtitle = strong("Number of Unclustered Schools (Division)"), icon = icon("users"), color = "green")
    })
    
    output$Cluster <- renderValueBox({
      valueBox(strong(sum(mainreactdiv$Clustering.Status == "CLUSTERED")), subtitle = strong("Number of Clustered Schools (Division)"), icon = icon("school"), color = "green")
    })
    
    output$Outlier <- renderValueBox({
      valueBox(strong(sum(mainreactdiv$Clustering.Status == "Outlier")), subtitle = strong("Number of Outlier Schools (Division)"), icon = icon("school"), color = "green")
    })
    
    output$SingleR <- renderValueBox({
      valueBox(strong(sum(mainreactreg$Clustering.Status == "NOT CLUSTERED")), subtitle = strong("Number of Unclustered Schools (Region)"), icon = icon("users"), color = "navy")
    })
    
    output$ClusterR <- renderValueBox({
      valueBox(strong(sum(mainreactreg$Clustering.Status == "CLUSTERED")), subtitle = strong("Number of Clustered Schools (Region)"), icon = icon("school"), color = "navy")
    })
    
    output$OutlierR <- renderValueBox({
      valueBox(strong(sum(mainreactreg$Clustering.Status == "Outlier")), subtitle = strong("Number of Outlier Schools (Region)"), icon = icon("school"), color = "navy")
    })
    
    Ao21 <- reactive({
      
      if (is.null(input$AO2Mapping_bounds)) {
        mainreactNTP
      } else {
        bounds <- input$AO2Mapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactNTP,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$AO2Table <- DT::renderDT(Ao21() %>% select("School.Name","Clustering.Status","PDOI_Deployment") %>% rename("School" = School.Name, "AO II Deployment" = Clustering.Status, "PDOI Deployment" = PDOI_Deployment), rownames = FALSE, filter = 'top', options = list(scrollX = TRUE, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))
    
    output$f2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactreg$Clustering.Status == "Clustered")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$g2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactreg$Clustering.Status == "Dedicated")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$a2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactdiv$Clustering.Status == "Clustered")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$b2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactdiv$Clustering.Status == "Dedicated")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$e2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactNTP$Clustering.Status == "Clustered")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$h2 <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactNTP$Clustering.Status == "Dedicated")), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$ROCRShort <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactCRreg$Estimated_CL_Shortage, na.rm = TRUE)), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    output$SDOCRShort <- renderValueBox({
      valueBox(tags$p(strong(sum(mainreactCRdiv$Estimated_CL_Shortage, na.rm = TRUE)), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    })
    
    #output$DistCRShort <- renderValueBox({
    #valueBox(tags$p(strong(sum(mainreactNTP$Est.CS, na.rm = TRUE)), style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"), subtitle = NULL)
    #})
    
    # --- Total Last Mile Schools by Region ---
    output$LMS_Total_Region <- renderValueBox({
      total_region_lms <- nrow(mainreactLMSreg)  # <-- adjust dataset/column name if needed
      
      valueBox(
        tags$p(
          strong(scales::comma(total_region_lms)),
          style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"),
        subtitle = NULL
      )
    })
    
    
    # --- Total Last Mile Schools by Division ---
    output$LMS_Total_Division <- renderValueBox({
      total_division_lms <-    nrow(mainreactLMSdiv)  # <-- adjust dataset/column name if needed
      
      valueBox(
        tags$p(
          strong(scales::comma(total_division_lms)),
          style = "font-family: Poppins; font-size: 20px; color: #111111; text-align: center;"),
        subtitle = NULL
      )
    })
    
    
    dfreact_CL <- reactive({
      
      if (is.null(input$CLMapping_bounds)) {
        mainreactCR
      } else {
        bounds <- input$CLMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactCR,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$CLTable <- DT::renderDT(server = FALSE, {datatable(dfreact_CL() %>% select("School.Name","Enrolment.2023.2024","Instructional.Rooms.2023.2024","Est.CS","Buidable_space") %>% rename("School" = School.Name, "Total Enrolment" = Enrolment.2023.2024, "Classroom Inventory" = Instructional.Rooms.2023.2024, "Estimate Classroom Shortage" = Est.CS, "Buildable Space" = Buidable_space), filter = 'top', options = list(scrollX = TRUE,scrollY= "300px", columnDefs = list(list(className = 'dt-center', targets ="_all")), rownames = FALSE, dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))})
    
    dfreact_SHS <- reactive({
      
      if (is.null(input$SHSMapping_bounds)) {
        mainreactSHS
      } else {
        bounds <- input$SHSMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactSHS,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$SHSListTable <- DT::renderDT(server = FALSE, {datatable(dfreact_SHS() %>% select("School.Name", "TotalEnrolment") %>% rename("School" = School.Name, "Total Enrolment" = TotalEnrolment), extension = 'Buttons', rownames = FALSE, options = list(scrollX = TRUE, pageLength = 5, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))})
    
    output$SHSCount <- renderValueBox({
      valueBox(tags$p(strong(nrow(mainreactSHS)), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    SHS_count_reactive <- eventReactive(input$Mapping_Run, {
      
      mainvalue <- df %>% 
        filter(Region == input$resource_map_region) %>% 
        filter(Level == "SHS")
      
      # This returns the COUNT (a single number)
      return(nrow(mainvalue))
    })
    
    output$SHSCountUniv <- renderValueBox({
      valueBox(tags$p(strong(SHS_count_reactive()), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$IndCount <- renderValueBox({
      valueBox(tags$p(strong(nrow(mainreactind)), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$assessmentSHS <- renderUI({
      p(HTML(paste(strong(RegRCT),"has",strong(nrow(mainreactSHS)),"senior high schools and a total of ",strong(nrow(mainreactind)),"industries composed of",strong(sum(mainreactind$Sector == "Food Establishments")),"industries on Food Establishments, ",strong(sum(mainreactind$Sector == "Professional/Private Services")),"industries on Professional/Private Services, ",strong(sum(mainreactind$Sector == "Transportation")),"industries on Transportation, ",strong(sum(mainreactind$Sector == "Utilities")),"industries on Utilities",", and",strong(sum(mainreactind$Sector == "Retail")),"industries on Retail")), style = "font-family: Century Gothic; font-size: 15px; color: #111111;")
    })
    
    color_palette <- colorFactor(
      palette = c("red", "green", "blue"),
      domain = mainreactEFD$FundingCategory,
      levels = levels(mainreactEFD$FundingCategory) # Ensure the order is respected
    )
    
    validate(
      need(
        "Longitude" %in% colnames(mainreactEFD) && "Latitude" %in% colnames(mainreactEFD),
        "Error: FacMapping data is missing Latitude or Longitude."
      )
    )
    
    # 3. Use the new factor variable and color palette in your leaflet code
    leafletProxy("FacMapping", data = mainreactEFD) %>%
      clearMarkers() %>%
      clearControls() %>%
      setView(lng = mainreactEFD$Longitude[1], lat = mainreactEFD$Latitude[1], zoom = 7) %>%
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
        lng = ~Longitude,
        lat = ~Latitude,
        popup = values.efdmasterlist,
        icon = makeAwesomeIcon(
          icon = "education",
          library = "glyphicon",
          markerColor = case_when(mainreactEFD$FundingCategory == "Before 2025" ~ "red", mainreactEFD$FundingCategory == "2025-2030" ~ "green", mainreactEFD$FundingCategory == "After 2030" ~ "blue") # Use the new factor variable
        )
      ) %>%
      addLegend(
        "bottomright",
        pal = color_palette,
        values = ~FundingCategory, # Use the new factor variable
        title = "Funding Year",
        opacity = 1
      )
    
    dfreact_fac <- reactive({
      if (is.null(input$FacMapping_bounds)) {
        mainreactEFD
      } else {
        bounds <- input$FacMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactEFD,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$FacTable <- DT::renderDT(server = FALSE, {
      datatable(dfreact_fac() %>% 
                  select("Region","Division","School.Name","FundingYear","Allocation") %>%
                  rename("School" = School.Name, "Funding Year" = FundingYear),
                extension = 'Buttons',
                rownames = FALSE,
                options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))
    })
    
    color_palette_cong <- colorFactor(
      palette = c("red", "green", "blue"),
      domain = mainreactNTP$Congestion.Index,
      levels = levels(mainreactNTP$Congestion.Index) # Ensure the order is respected
    )
    
    values.congest <- paste(strong("SCHOOL INFORMATION"),"<br>School Name:",mainreactNTP$School.Name,"<br>School ID:",mainreactNTP$SchoolID,"<br>Instructional Rooms (2023-2024):",mainreactNTP$Instructional.Rooms.2023.2024,"<br>Enrolment (2023-2024):",mainreactNTP$Enrolment.2023.2024,"<br>Congestion Index:",mainreactNTP$Congestion.Index) %>% lapply(htmltools::HTML)
    
    validate(
      need(
        "Longitude" %in% colnames(mainreactNTP) && "Latitude" %in% colnames(mainreactNTP),
        "Error: CongestMapping data is missing Latitude or Longitude."
      )
    )
    
    # 3. Use the new factor variable and color palette in your leaflet code
    leafletProxy("CongestMapping", data = mainreactNTP) %>%
      clearMarkers() %>%
      clearControls() %>%
      setView(lng = mainreactNTP$Longitude[1], lat = mainreactNTP$Latitude[1], zoom = 7) %>%
      addAwesomeMarkers(
        clusterOptions = markerClusterOptions(disableClusteringAtZoom = 15),
        lng = ~Longitude,
        lat = ~Latitude,
        label = values.congest,
        icon = makeAwesomeIcon(
          icon = "education",
          library = "glyphicon",
          markerColor = case_when(mainreactNTP$Congestion.Index >= 0 & mainreactNTP$Congestion.Index < 0.25 ~ "green", mainreactNTP$Congestion.Index >= 0.25 & mainreactNTP$Congestion.Index < 0.5 ~ "green", mainreactNTP$Congestion.Index >= 0.5 & mainreactNTP$Congestion.Index < 0.75 ~ "orange",mainreactNTP$Congestion.Index >= 0.75 ~ "red")))
    
    dfreact_cong <- reactive({
      if (is.null(input$CongestMapping_bounds)) {
        mainreactNTP %>% arrange(desc(Congestion.Index))
      } else {
        bounds <- input$CongestMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactNTP,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    output$CongestTable <- DT::renderDT(server = FALSE, {
      datatable(dfreact_cong() %>% 
                  select("Region","Division","School.Name","Instructional.Rooms.2023.2024","Enrolment.2023.2024","Congestion.Index") %>%
                  rename("School" = School.Name, "Instructional Rooms" = Instructional.Rooms.2023.2024, "Total Enrolment" = Enrolment.2023.2024, "Congestion Index" = Congestion.Index),
                extension = 'Buttons',
                rownames = FALSE,
                options = list(scrollX = TRUE, pageLength = 10, columnDefs = list(list(className = 'dt-center', targets ="_all")), dom = 'Bfrtip', buttons = list('csv','excel','pdf','print')))
    })
    
  })
  
  observeEvent(input$LMSTable_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    
    mainreactLMS <- LMS %>%
      filter(LMS == 1) %>%
      left_join(buildablecsv %>% select(SCHOOL.ID,OTHER.REMARKS..Buildable.Space..), by = c("School_ID" = "SCHOOL.ID")) %>% 
      filter(Region == RegRCT) %>% filter(Division == SDORCT1)
    
    df1 <- reactive({
      
      if (is.null(input$LMSMapping_bounds)) {
        mainreactLMS
      } else {
        bounds <- input$LMSMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactLMS,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = df1()[input$LMSTable_rows_selected,]
    leafletProxy("LMSMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)
    
  })
  
  observeEvent(input$TextTable_rows_selected, {
    
    Text <- input$text
    
    mainreact1 <- uni %>%
      arrange(Region, Division) %>%
      filter(grepl(Text, as.character(School.Name), ignore.case = TRUE))
    
    df1 <- reactive({
      
      if (is.null(input$TextMapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TextMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = df1()[input$TextTable_rows_selected,]
    leafletProxy("TextMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)
    
    rowselected_table1 <- row_selected %>% select(Region,Province,Municipality,Division,District,Barangay,Street.Address,SchoolID,School.Name,School.Head.Name,SH.Position,Implementing.Unit,Modified.COC,Latitude,Longitude) %>% rename("Modified Curricular Offering" = Modified.COC, "School ID" = SchoolID, "School Name" = School.Name, "Street Address" = Street.Address, "Implementing Unit" = Implementing.Unit, "School Head" = School.Head.Name,"School Head Position" = SH.Position) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Basic Info",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table2 <- row_selected %>% select(ES.Excess,ES.Shortage,JHS.Excess,JHS.Shortage,SHS.Excess,SHS.Shortage,ES.Teachers,JHS.Teachers,SHS.Teachers,ES.Enrolment,JHS.Enrolment,SHS.Enrolment,School.Size.Typology,Clustering.Status,Outlier.Status) %>% rename("ES Teachers"=ES.Teachers,"JHS Teachers"=JHS.Teachers,"SHS Teachers"=SHS.Teachers, "ES Enrolment" = ES.Enrolment, "JHS Enrolment" = JHS.Enrolment, "SHS Enrolment" = SHS.Enrolment, "School Size Typology" = School.Size.Typology, "AO II Deployment" = Clustering.Status,"COS Deployment" = Outlier.Status, "ES Shortage" = ES.Shortage,"ES Excess" = ES.Excess,"JHS Shortage" = JHS.Shortage,"JHS Excess" = JHS.Excess,"SHS Shortage" = SHS.Shortage,"SHS Excess" = SHS.Excess) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "HR Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table3 <- row_selected %>% select(Buildings,Instructional.Rooms.2023.2024,Classroom.Requirement,Est.CS,Buidable_space,Major.Repair.2023.2024,SBPI,Shifting,OwnershipType,ElectricitySource,WaterSource,Total.Seats.2023.2024,Total.Seats.Shortage.2023.2024) %>% rename("With Buildable Space" = Buidable_space,"Number of Instructional Rooms" = Instructional.Rooms.2023.2024,"Classroom Requirement" = Classroom.Requirement,"Ownership Type" = OwnershipType,"Source of Electricity" = ElectricitySource,"Source of Water" = WaterSource,"Estimated Classroom Shortage"= Est.CS,"School Building Priority Index" = SBPI,"For Major Repairs"= Major.Repair.2023.2024,"Total Seats"=Total.Seats.2023.2024,"Total Seats Shortage"=Total.Seats.Shortage.2023.2024, "Number of Buildings"=Buildings) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Classroom Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    
    rowselected_table4 <- row_selected %>% select(SHA.2021.Index,Travel..Cost,Travel.Time,No.Piped.Water,No.Grid.Electricity,No.Internet,Conflict,TLS) %>% rename("HI 2021" = SHA.2021.Index,"Travel Cost" = Travel..Cost,"Travel Time" = Travel.Time,"No Access to Piped Water" = No.Piped.Water,"No Access to Grid Electricity"= No.Grid.Electricity,"No Access to Internet" = No.Internet,"Incidence of Conflict" = Conflict,"Existence of Temporary Learning Spaces"= TLS) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Other Data",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_table5 <- row_selected %>%
      select(English, Mathematics, Science, Biological.Sciences, Physical.Sciences,
             General.Ed, Araling.Panlipunan, TLE, MAPEH, Filipino, ESP,
             Agriculture, ECE, SPED) %>%
      rename(
        "Biological Sciences" = Biological.Sciences,
        "Physical Sciences" = Physical.Sciences,
        "General Education" = General.Ed,
        "Araling Panlipunan" = Araling.Panlipunan,
        "Early Childhood Education" = ECE
      ) %>%
      # Convert all to character first
      mutate(across(everything(), as.character)) %>%
      # ðŸª„ Replace all 0s with "-"
      mutate(across(everything(), ~ ifelse(. == "0", "-", .))) %>%
      pivot_longer(
        cols = everything(),
        names_to = "Specialization",
        values_to = "Data"
      )
    
    
    output$schooldetails <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table1
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails2 <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table2
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails3 <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table3
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails4 <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table4
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$schooldetails5 <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_table5
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
  })# Add borders to the table (optional styling)
  
  observeEvent(input$CongestTable_rows_selected, {
    
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    
    mainreactNTP <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1)
    
    dfreact_cong <- reactive({
      if (is.null(input$CongestMapping_bounds)) {
        mainreactNTP
      } else {
        bounds <- input$CongestMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactNTP,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = dfreact_cong()[input$CongestTable_rows_selected,]
    leafletProxy("CongestMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)})
  
  observeEvent(input$CLTable_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT3 <- input$Resource_SDO
    DistRCT3 <- input$Resource_LegDist
    
    mainreact1x <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT3) %>% filter(Legislative.District == DistRCT3) %>% arrange(desc(SBPI))
    
    CL1 <- reactive({
      
      if (is.null(input$CLMapping_bounds)) {
        mainreact1x
      } else {
        bounds <- input$CLMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1x,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = CL1()[input$CLTable_rows_selected,]
    leafletProxy("CLMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)})
  
  observeEvent(input$FacTable_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    # Lev <- input$resource_map_level
    TypeEFD <- input$EFD_Type
    
    mainreactEFD <- EFDMP %>% 
      filter(!is.na(Old.Region), Old.Region != "") %>% 
      filter(!is.na(Latitude), !is.na(Longitude)) %>% 
      mutate(Latitude = as.numeric(Latitude),
             Allocation = dollar(Allocation, prefix = "â‚±")) %>%  # Use 'dollar' to format Allocation) %>% 
      distinct(SchoolID, FundingYear, Allocation, Category, .keep_all = TRUE) %>%
      arrange(FundingYear) %>% 
      filter(Region == input$resource_map_region) %>%
      filter(Division == input$Resource_SDO) %>%
      filter(Category %in% input$EFD_Type) %>% 
      mutate(FundingCategory = factor(
        case_when(
          FundingYear < 2025 ~ "Before 2025",
          (FundingYear >= 2025 & FundingYear <= 2030) ~ "2025-2030",
          FundingYear > 2030 ~ "After 2030"
        ),
        levels = c("Before 2025", "2025-2030", "After 2030")
      ))
    
    dfreact_fac <- reactive({
      if (is.null(input$FacMapping_bounds)) {
        mainreactEFD
      } else {
        bounds <- input$FacMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreactEFD,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = dfreact_fac()[input$FacTable_rows_selected,]
    leafletProxy("FacMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)})
  
  observeEvent(input$AO2Table_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT2 <- input$Resource_SDO
    DistRCT2 <- input$Resource_LegDist
    
    Ao2Filter <- uni %>% filter(Region == RegRCT) %>% filter(Division == SDORCT2) %>% filter(Legislative.District == DistRCT2)
    
    SDOfillup <- SDO[which(SDO$Division==SDORCT2),"FillUpRate"]
    Unfilled <- SDO[which(SDO$Division==SDORCT2),"Unfilled"]
    
    xy1 <- reactive({
      
      if (is.null(input$AO2Mapping_bounds)) {
        Ao2Filter
      } else {
        bounds <- input$AO2Mapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(Ao2Filter,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = xy1()[input$AO2Table_rows_selected,]
    leafletProxy("AO2Mapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)
  })
  
  observeEvent(input$TeacherShortage_Table_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    # Lev <- input$resource_map_level
    
    mainreact1 <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% arrange(desc(TeacherShortage))
    
    SDOfillup <- SDO[which(SDO$Division==SDORCT1),"FillUpRate"]
    Unfilled <- SDO[which(SDO$Division==SDORCT1),"Unfilled"]
    
    NetShortage <- df %>% select(Region,Division,Level,TeacherShortage,TeacherExcess) %>%
      pivot_longer(cols = c(TeacherExcess, TeacherShortage), names_to = "Inventory", values_to = "Count") %>% mutate(Count=as.numeric(Count)) %>% na.omit(Count) %>% group_by(Region, Division,Level, Inventory) %>% summarize(Count = sum(Count)) %>% pivot_wider(names_from = "Inventory", values_from = "Count") %>% mutate(NetShortage=TeacherShortage-TeacherExcess) %>% mutate(NetShortage = ifelse(NetShortage < 0, 0, NetShortage))
    
    SDONetShortage <- NetShortage %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) #%>% filter(Level == Lev)
    
    
    df1 <- reactive({
      
      if (is.null(input$TeacherShortage_Mapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$TeacherShortage_Mapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = df1()[input$TeacherShortage_Table_rows_selected,]
    leafletProxy("TeacherShortage_Mapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)
    
    output$d <- renderValueBox({
      valueBox(tags$p(strong(row_selected$TeacherShortage), style = "font-size: 65%;"), subtitle = tags$p(strong("School Teacher Shortage"), style = "font-size: 60%;"), color = "red")})
    
    output$TeacherShortage_Assessment <- renderUI({
      p(HTML(paste(strong(row_selected$School.Name),"is located in the Division of", strong(row_selected$Division),". According to the PSIPOP data as of December 2024, this SDO has ",strong(SDOfillup)," filling-up rate with ",strong(Unfilled),"unfilled item/s. Moreover, this SDO has a net shortage of ",strong(SDONetShortage$NetShortage),"teacher/s for the selected level based on SY 2024-2025 enrolment data and teaching inventory using the standard planning parameters. The said school has a shortage of ",strong(row_selected$TeacherShortage),"teacher/s and a total excess of",strong(sum(df1()$TeacherExcess, na.rm = TRUE)),"teacher/s captured within the map and table above")), style = "font-family: Century Gothic; font-size: 15px; color: #111111;")
    })
    
    
    EDtable <- row_selected %>% select(School.Name,Kinder,G1,G2,G3,G4,G5,G6,G7,G8,G9,G10,G11,G12)
    Loctable <- row_selected %>% select(School.Name,Province,Municipality,District, Barangay,Street.Address)
    Spectable <- row_selected %>% select(School.Name,English,Mathematics,Science,Biological.Sciences,Physical.Sciences) 
    
    observeEvent(input$SelectSchoolData, {
      selectSD = input$SelectSchoolData
      
      if (selectSD == "Enrolment Data") {
        output$SchoolData <- DT::renderDT(EDtable, rownames = FALSE, options = list(scrollX = TRUE, columnDefs = list(list(className = 'dt-left', targets ="_all"))))}
      else {if (selectSD == "School Location") {
        output$SchoolData <- DT::renderDT(Loctable, rownames = FALSE, options = list(scrollX = TRUE, columnDefs = list(list(className = 'dt-left', targets ="_all"))))}
        else {if  (selectSD == "Specialization") {
          output$SchoolData <- DT::renderDT(Spectable, rownames = FALSE, options = list(scrollX = TRUE, columnDefs = list(list(className = 'dt-left', targets ="_all"))))}
        }}})
    
  }, ignoreNULL = TRUE, ignoreInit = TRUE)
  
  # --- Reactive Filter for GMIS Data (handles CSV + filtering) ---
  filtered_GMIS <- reactive({
    # --- Read CSV ---
    dfGMIS <- read.csv("GMIS-FillingUpPerPosition-2025.csv")
    
    # --- Handle deselect-all / empty pickers ---
    if (is.null(input$RegionGMIS) || length(input$RegionGMIS) == 0 ||
        is.null(input$SDOGMIS)   || length(input$SDOGMIS) == 0 ||
        is.null(input$PosSelGMIS) || length(input$PosSelGMIS) == 0) {
      return(list(
        stacked = tibble::tibble(),
        table = tibble::tibble()
      ))
    }
    
    RegGMISRCT <- input$RegionGMIS
    SDOGMISRCT <- input$SDOGMIS
    PosSelGMISRCT <- input$PosSelGMIS
    
    # --- Summary for stacked bar chart ---
    stacked_data <- dfGMIS %>%
      filter(GMIS.Region %in% RegGMISRCT) %>%
      filter(GMIS.Division %in% SDOGMISRCT) %>%
      filter(Position %in% PosSelGMISRCT) %>%
      group_by(Position) %>%
      summarise(
        Filled = sum(Total.Filled, na.rm = TRUE),
        Unfilled = sum(Total.Unfilled, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      # --- Ensure all selected positions appear, even if missing or zero ---
      right_join(
        tibble(Position = PosSelGMISRCT),
        by = "Position"
      ) %>%
      mutate(
        Filled = ifelse(is.na(Filled), 0, Filled),
        Unfilled = ifelse(is.na(Unfilled), 0, Unfilled)
      ) %>%
      tidyr::pivot_longer(
        cols = c("Filled", "Unfilled"),
        names_to = "Status",
        values_to = "Count"
      )
    
    # --- Summary for DataTable ---
    table_data <- dfGMIS %>%
      filter(GMIS.Region %in% RegGMISRCT) %>%
      filter(GMIS.Division %in% SDOGMISRCT) %>%
      filter(Position %in% PosSelGMISRCT) %>%
      group_by(GMIS.Region, GMIS.Division, Position) %>%
      summarise(
        Filled = sum(Total.Filled, na.rm = TRUE),
        Unfilled = sum(Total.Unfilled, na.rm = TRUE),
        Authorized = sum(Total.Authorized, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      # --- Keep even zero positions ---
      right_join(
        tibble(Position = PosSelGMISRCT),
        by = "Position"
      ) %>%
      mutate(
        Region = ifelse(is.na(GMIS.Region), "", GMIS.Region),
        Division = ifelse(is.na(GMIS.Division), "", GMIS.Division),
        Filled = ifelse(is.na(Filled), 0, Filled),
        Unfilled = ifelse(is.na(Unfilled), 0, Unfilled),
        Authorized = ifelse(is.na(Authorized), 0, Authorized),
        `Filling Up Rate (%)` = ifelse(Authorized > 0, round(Filled / Authorized * 100, 2), 0)
      ) %>%
      select(Region, Division, Position, Filled, Unfilled, Authorized, `Filling Up Rate (%)`)
    
    # --- Return both summaries ---
    list(
      stacked = stacked_data,
      table = table_data
    )
  })
  
  
  # --- Render Plotly Chart ---
  output$GMISTable <- renderPlotly({
    plot_data_stacked <- filtered_GMIS()$stacked
    
    # --- Handle no selection ---
    if (is.null(plot_data_stacked) || nrow(plot_data_stacked) == 0) {
      empty_plot <- ggplot() +
        theme_void() +
        annotate(
          "text", x = 0.5, y = 0.5,
          label = "No data selected",
          size = 6, color = "gray50", hjust = 0.5, vjust = 0.5
        )
      return(ggplotly(empty_plot) %>% layout(hoverlabel = list(bgcolor = "white")))
    }
    
    # --- Compute totals for labels ---
    plot_data_totals <- plot_data_stacked %>%
      group_by(Position) %>%
      summarise(TotalCount = sum(Count), .groups = "drop")
    
    # --- Define colors ---
    category_colors <- c("Filled" = "blue", "Unfilled" = "red")
    
    # --- Build the plot ---
    p <- ggplot(plot_data_stacked, aes(
      x = factor(Position),
      y = Count,
      fill = factor(Status, levels = c("Unfilled", "Filled")),
      text = paste(
        "Position: ", Position,
        "<br>Status: ", Status,
        "<br>Count: ", Count
      )
    )) +
      geom_bar(stat = "identity", position = "stack") +
      geom_text(
        data = plot_data_totals,
        aes(x = Position, y = TotalCount * 1.05, label = scales::comma(TotalCount)),
        inherit.aes = FALSE,
        size = 3.5,
        color = "black"
      ) +
      labs(x = "Position", y = "Count") +
      scale_y_continuous(labels = scales::comma) +
      scale_fill_manual(name = "Legend", values = category_colors) +
      theme_minimal() +
      theme(legend.position = "bottom")
    
    ggplotly(p, tooltip = "text", source = "stackedBarPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"))
  })
  
  
  # --- Render DataTable ---
  output$GMISTable1 <- renderDataTable({
    dfGMIS <- read.csv("GMIS-FillingUpPerPosition-2025.csv")
    table_data <- filtered_GMIS()$table
    
    # --- When deselect-all or no data, keep headers and show "No data available in table" ---
    if (is.null(table_data) || nrow(table_data) == 0) {
      empty_df <- dfGMIS %>%
        transmute(
          Region = GMIS.Region,
          Division = GMIS.Division,
          Position,
          Filled = Total.Filled,
          Unfilled = Total.Unfilled,
          Authorized = Total.Authorized,
          `Filling Up Rate (%)` = round(Total.Filled / Total.Authorized * 100, 2)
        ) %>%
        dplyr::slice(0)
      
      return(DT::datatable(
        empty_df,
        filter = "top",
        extensions = "FixedHeader",
        options = list(
          fixedHeader = list(header = TRUE, footer = FALSE),
          scrollY = "300px",
          scrollCollapse = TRUE,
          columnDefs = list(list(className = 'dt-center', targets = '_all')),
          rownames = FALSE,
          language = list(emptyTable = "No data available in table")
        )
      ))
    }
    
    # --- Render normal data table ---
    DT::datatable(
      table_data,
      filter = "top",
      extensions = "FixedHeader",
      options = list(
        fixedHeader = list(header = TRUE, footer = FALSE),
        scrollY = "300px",
        scrollCollapse = TRUE,
        columnDefs = list(list(className = 'dt-center', targets = '_all')),
        rownames = FALSE
      )
    )
  })
  
  
  
  observeEvent(input$SHSListTable_rows_selected, {
    
    RegRCT <- input$resource_map_region
    SDORCT1 <- input$Resource_SDO
    DistRCT1 <- input$Resource_LegDist
    # Lev <- input$resource_map_level
    TypeEFD <- input$EFD_Type
    
    region_selected <- IndALL %>% filter(Region == RegRCT) %>% arrange(Distance)
    
    mainreact1 <- df %>% filter(Region == RegRCT) %>% filter(Division == SDORCT1) %>% filter(Legislative.District == DistRCT1) %>% filter(Level == "SHS") %>% distinct(SchoolID, .keep_all = TRUE)
    
    df1 <- reactive({
      
      if (is.null(input$SHSMapping_bounds)) {
        mainreact1
      } else {
        bounds <- input$SHSMapping_bounds
        latRng <- range(bounds$north, bounds$south)
        lngRng <- range(bounds$east, bounds$west)
        
        subset(mainreact1,
               Latitude >= latRng[1] & Latitude <= latRng[2] & Longitude >= lngRng[1] & Longitude <= lngRng[2])
      }
    })
    
    row_selected = df1()[input$SHSListTable_rows_selected,]
    rowschool = row_selected$School.Name
    leafletProxy("SHSMapping") %>%
      setView(lng = row_selected$Longitude, lat = row_selected$Latitude, zoom = 15)
    
    SHSIndustries <- region_selected %>% filter(School.Name %in% rowschool) %>% select("Company","Sector","Distance") %>% rename("Distance in KM" = Distance)
    
    output$dataTableSHS <- DT::renderDT({
      data_to_display <- SHSIndustries
      
      # Handle empty or missing data
      if (is.null(data_to_display) || nrow(data_to_display) == 0) {
        return(DT::datatable(
          data.frame("Message" = "Select a school to view nearby industries."),
          options = list(dom = 't', scrollX = TRUE),
          rownames = FALSE
        ))
      }
      
      DT::datatable(
        data_to_display,
        extensions = c("Buttons", "FixedHeader", "FixedColumns"),
        options = list(
          scrollX = TRUE,
          autoWidth = TRUE,
          fixedHeader = TRUE,
          fixedColumns = list(leftColumns = 2),
          pageLength = 10,
          dom = 'Bfrtip',
          buttons = list(
            list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
            list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
            list(extend = "pdf", exportOptions = list(modifier = list(page = "all"))),
            list(extend = "print", exportOptions = list(modifier = list(page = "all")))
          ),
          columnDefs = list(list(className = 'dt-center', targets = "_all"))
        ),
        filter = 'top',     
        selection = 'multiple',
        rownames = FALSE
      )
    }, server = FALSE)
    
    output$AccoCount <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Manufacturing and Engineering")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$ProfCount <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Hospitality and Tourism")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$WastCount <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Public Administration")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$TranCount <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Professional/Private Services")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$WholCount <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Business and Finance")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    output$WholCount2 <- renderValueBox({
      valueBox(tags$p(strong(sum(SHSIndustries$Sector == "Agriculture and Agri-business")), style = "font-size: 100%; text-align: center;"), subtitle = NULL)})
    
    rowselected_SHStable <- df %>% filter(SchoolID == row_selected$SchoolID) %>% slice(1) %>% select(Region,Division,Modified.COC,School.Name,SchoolID,SHS.Enrolment,SHS.Packages) %>% rename("School ID" = SchoolID,"Schools Division Office" = Division,"Modified Curricular Offering" = Modified.COC,"School Name" = School.Name,"Delivered Learning Packages (2018-2025)"=SHS.Packages) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Profile Item",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_SHStablespec <- df %>%  filter(SchoolID == row_selected$SchoolID) %>% slice(1) %>% select(English,Mathematics,Science,Biological.Sciences,Physical.Sciences,General.Ed,Araling.Panlipunan,TLE,MAPEH,Filipino,ESP,Agriculture,ECE,SPED) %>% rename("Biological Sciences" = Biological.Sciences,"Physical Sciences" = Physical.Sciences,"General Education" = General.Ed,"Araling Panlipunan" = Araling.Panlipunan,"Early Chilhood Education" = ECE) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Profile Item",     # Name of the new column holding the original column names
      values_to = "Data")     # Name of the new column holding the original values
    
    rowselected_SHStablespec2 <- df %>% select(English,Mathematics,Science,Biological.Sciences,Physical.Sciences,General.Ed,Araling.Panlipunan,TLE,MAPEH,Filipino,ESP,Agriculture,ECE,SPED) %>% rename("Biological Sciences" = Biological.Sciences,"Physical Sciences" = Physical.Sciences,"General Education" = General.Ed,"Araling Panlipunan" = Araling.Panlipunan,"Early Chilhood Education" = ECE) %>% mutate(dplyr::across(tidyr::everything(), as.character)) %>% pivot_longer(
      cols = everything(),    # Pivot all columns selected in details_to_pivot
      names_to = "Profile",     # Name of the new column holding the original column names
      values_to = "Data") %>% mutate(Data = as.numeric(Data)) %>% group_by(Profile) %>% summarise(Data = sum(Data, na.rm = TRUE))
    
    output$SHSTablex <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_SHStable
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
    output$PilotSpec <- renderTable({
      # Pass the pivoted data frame directly
      rowselected_SHStablespec
    },
    rownames = FALSE, # Don't show automatic row names
    colnames = TRUE,  # Show column names (Field, Value)
    hover = TRUE,     # Add hover effect to rows (optional styling)
    bordered = TRUE)
    
  })
  
  
  output$school_count_division_graph <- renderPlotly({
    
    # --- If region or division picker is empty, clear the plot ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)  # Make plot area blank when "Deselect All" is clicked
    }
    
    current_filtered_data <- filtered_school_data_division() # Use the reactive filtered data
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, 
                   label = "No data for selected regions/divisions") +
          theme_void()
      ))
    }
    
    coc_levels <- c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
                    "Purely JHS", "All Offering (K to 12)", "Purely SHS")
    
    plot_data <- current_filtered_data %>%
      group_by(Division, Modified.COC) %>%
      summarise(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Modified.COC) %>%
      summarise(TotalCount = sum(Count))
    
    division_total_counts <- plot_data %>%
      group_by(Division) %>%
      summarise(Total_Division_Count = sum(Count), .groups = 'drop')
    
    plot_data <- plot_data %>%
      left_join(division_total_counts, by = "Division") %>%
      mutate(Division_reordered = reorder(Division, Total_Division_Count))
    
    p <- ggplot(plot_data,
                aes(x = factor(Modified.COC, levels = coc_levels),
                    y = Count,
                    fill = Division_reordered,
                    key = paste(Division, Modified.COC),
                    text = paste("Division: ", Division,
                                 "<br>School Type: ", Modified.COC,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Modified.COC, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(  title = "Division Distribution of Schools by Curricular Offering", x = "Region",
             y = "Number of Schools",
             fill = "School Type") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "schoolcountplot_division") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  output$school_count_district_graph <- renderPlotly({
    
    # --- If region or division picker is empty, clear the plot ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, 
                   label = "No data for selected regions/Legislative Districts") +
          theme_void()
      ))
    }
    
    coc_levels <- c("Purely ES", "JHS with SHS", "ES and JHS (K to 10)",
                    "Purely JHS", "All Offering (K to 12)", "Purely SHS")
    
    plot_data <- current_filtered_data %>%
      group_by(Division, Legislative.District, Modified.COC) %>%
      summarise(Count = n(), .groups = 'drop') %>%
      mutate(
        Division = as.character(Division),
        Legislative.District = as.character(Legislative.District),
        Modified.COC = as.character(Modified.COC)
      )
    
    plot_data_totals <- plot_data %>%
      group_by(Modified.COC) %>%
      summarise(TotalCount = sum(Count))
    
    plot_data <- plot_data %>%
      mutate(Division_LegDist = paste0(Division, "- ", Legislative.District))
    
    p <- ggplot(plot_data,
                aes(x = factor(Modified.COC, levels = coc_levels),
                    y = Count,
                    fill = Division_LegDist,
                    text = paste("Legislative District:", Division_LegDist,
                                 "<br>Modified.COC:", Modified.COC,
                                 "<br>Count:", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Modified.COC, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs( title = "District Distribution of Schools by Curricular Offering", x = "Modified COC",
            y = "Count",
            fill = "Legislative District") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  
  # In your server.R file, ensure 'rv' is initialized once, e.g., at the top of the server function:
  # rv <- reactiveValues(latest_sosss_click_key = NULL) # Only if not already initialized
  
  # Observer for SOSSS_Region_Typology clicks
  # This should be placed in your server.R file, outside of any output$... block,
  # but within the main server function.
  observeEvent(event_data("plotly_click", source = "sosssRegionPlot"), {
    click_data <- event_data("plotly_click", source = "sosssRegionPlot")
    if (!is.null(click_data)) {
      # Store the combined key (e.g., "Region I Very Small")
      rv$latest_sosss_click_key <- click_data$key
    } else {
      # If a click somehow clears, reset the key
      rv$latest_sosss_click_key <- NULL
    }
  })
  
  output$SOSSS_Division_Typology <- renderPlotly({
    
    # --- Hide plot if Region or Division picker is empty ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Handle no data case ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected divisions") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Division, School.Size.Typology) %>%
      summarise(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(School.Size.Typology) %>%
      summarise(TotalCount = sum(Count))
    
    region_totals <- plot_data %>%
      group_by(Division) %>%
      summarise(TotalCount = sum(Count), .groups = 'drop')
    
    plot_data <- plot_data %>%
      left_join(region_totals, by = "Division") %>%
      mutate(Division_reordered = reorder(Division, -TotalCount))
    
    sosss_levels <- c("Very Small", "Small", "Medium", "Large", 
                      "Very Large", "Extremely Large", "Mega")
    
    p <- ggplot(plot_data,
                aes(x = factor(School.Size.Typology, levels = sosss_levels),
                    y = Count,
                    fill = Division_reordered,
                    key = paste(Division, School.Size.Typology),
                    text = paste("Division: ", Division,
                                 "<br>School Size: ", School.Size.Typology,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = School.Size.Typology, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs( title = "Division-Level Distribution of Schools by Size Typology", x = "School Size Typology",
            y = "Number of Schools",
            fill = "Division") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "sosssDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  output$SOSSS_District_Typology <- renderPlotly({
    
    # --- Hide plot if Region or Division picker is empty ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Handle no data case ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected legislative districts") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Division, Legislative.District, School.Size.Typology) %>%
      summarise(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(School.Size.Typology) %>%
      summarise(TotalCount = sum(Count))
    
    region_totals <- plot_data %>%
      group_by(Legislative.District) %>%
      summarise(TotalCount = sum(Count), .groups = 'drop')
    
    plot_data <- plot_data %>%
      left_join(region_totals, by = "Legislative.District") %>%
      mutate(Legislative.District_reordered = reorder(Legislative.District, -TotalCount)) %>%
      mutate(Division_LegDist = paste0(Division, "- ", Legislative.District))
    
    sosss_levels <- c("Very Small", "Small", "Medium", "Large", 
                      "Very Large", "Extremely Large", "Mega")
    
    p <- ggplot(plot_data,
                aes(x = factor(School.Size.Typology, levels = sosss_levels),
                    y = Count,
                    fill = Division_LegDist,
                    text = paste("Legislative District: ", Division_LegDist,
                                 "<br>School Size: ", School.Size.Typology,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = School.Size.Typology, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs(title = "District Distribution of Schools by Size Typology", x = "School Size Typology",
           y = "Number of Schools",
           fill = "Legislative District") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "sosssDistrictPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  # Reactive expression for filtering the SOSSS table data based on dashboard filters and plot clicks
  filtered_sosss_table_data <- reactive({
    # Ensure uni data is available.
    req(uni)
    
    # Start with the full dataset for filtering based on dashboard inputs
    data <- uni
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      data <- data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    if (!is.null(input$dashboard_division_filter) && length(input$dashboard_division_filter) > 0) {
      data <- data %>%
        filter(Division %in% input$dashboard_division_filter)
    }
    
    # Now, filter based on the latest plot click for SOSSS graph
    clicked_region <- NULL
    clicked_sosss_typology <- NULL
    
    if (!is.null(rv$latest_sosss_click_key)) {
      # Define the levels for School.Size.Typology for consistent mapping and parsing
      sosss_levels_for_parsing <- c("Very Small", "Small", "Medium", "Large", "Very Large", "Extremely Large", "Mega")
      # Sort by length descending to match multi-word typologies first
      sosss_levels_ordered_by_length <- sosss_levels_for_parsing[order(nchar(sosss_levels_for_parsing), decreasing = TRUE)]
      
      found_typology <- FALSE
      for (typology_val in sosss_levels_ordered_by_length) {
        # Check if the typology is at the end of the key string
        if (grepl(paste0(typology_val, "$"), rv$latest_sosss_click_key)) {
          clicked_sosss_typology <- typology_val
          # The region is everything before this typology
          clicked_region <- sub(paste0(" ", typology_val, "$"), "", rv$latest_sosss_click_key)
          found_typology <- TRUE
          break
        }
      }
      
      if (!found_typology) {
        # Fallback if parsing fails, return data filtered only by dashboard inputs
        clicked_region <- NULL
        clicked_sosss_typology <- NULL
        warning("Could not parse clicked SOSSS key for Region and Typology: ", rv$latest_sosss_click_key)
      }
    }
    
    if (!is.null(clicked_region) && !is.null(clicked_sosss_typology)) {
      # Apply filter based on click data if both are valid
      data <- data %>%
        filter(Region == clicked_region,
               School.Size.Typology == clicked_sosss_typology)
    }
    
    return(data)
  })
  
  
  # Your Teacher_Shortage_Regional_Graph renderPlotly
  output$Teacher_Shortage_Regional_Graph <- renderPlotly({
    
    # --- Hide plot when Region filter is empty ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_teacher_shortage_data_region()
    
    # --- Empty data handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, 
                   label = "No data for selected regions/divisions") +
          theme_void()
      ))
    }
    
    # --- Prepare data ---
    plot_data <- current_filtered_data %>%
      pivot_longer(cols = c(ES_Shortage, JHS_Shortage, SHS_Shortage),
                   names_to = "Inventory", values_to = "Count") %>%
      mutate(Count = as.numeric(Count)) %>%
      na.omit() %>%
      group_by(Region, Inventory) %>%
      summarise(Total_Count = sum(Count, na.rm = TRUE), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Inventory) %>%
      summarise(TotalCount = sum(Total_Count))
    
    inventory_levels <- c("ES_Shortage", "JHS_Shortage", "SHS_Shortage")
    
    p <- ggplot(plot_data,
                aes(x = factor(Inventory, levels = inventory_levels),
                    y = Total_Count,
                    fill = Region,
                    text = paste("Region: ", Region,
                                 "<br>School Type: ", gsub("_Shortage", "", Inventory),
                                 "<br>Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Inventory, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "School Type",
           y = "Total Shortage Count",
           title = "Regional Teacher Shortage by School Type",
           fill = "Region") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "teacherShortageRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  output$Teacher_Shortage_Division_Graph <- renderPlotly({
    
    # --- Hide plot when region or division filter is empty ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_teacher_shortage_data_division()
    
    # --- Empty data handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected divisions") +
          theme_void()
      ))
    }
    
    # --- Prepare data ---
    plot_data <- current_filtered_data %>%
      pivot_longer(cols = c(ES_Shortage, JHS_Shortage, SHS_Shortage),
                   names_to = "Inventory", values_to = "Count") %>%
      mutate(Count = as.numeric(Count)) %>%
      na.omit() %>%
      group_by(Division, Inventory) %>%
      summarise(Total_Count = sum(Count, na.rm = TRUE), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Inventory) %>%
      summarise(TotalCount = sum(Total_Count))
    
    inventory_levels <- c("ES_Shortage", "JHS_Shortage", "SHS_Shortage")
    
    p <- ggplot(plot_data,
                aes(x = factor(Inventory, levels = inventory_levels),
                    y = Total_Count,
                    fill = Division,
                    text = paste("Division: ", Division,
                                 "<br>School Type: ", gsub("_Shortage", "", Inventory),
                                 "<br>Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Inventory, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "School Type",
           y = "Total Shortage Count",
           title = "Division Teacher Shortage by School Type",
           fill = "Division") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "teacherShortageDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  # In your server.R file, ensure 'rv' is initialized with the new reactive value:
  # rv <- reactiveValues(
  #   latest_click_key = NULL,           # For school_count graph
  #   latest_sosss_click_key = NULL,     # For SOSSS graph
  #   latest_classroom_click_key = NULL, # For Classroom Shortage graph
  #   latest_teacher_shortage_click_key = NULL, # For Teacher Shortage graph
  #   latest_principal_click_key = NULL # New: For School Principal graph
  # )
  # Make sure to include all rv initializations from previous steps if you are creating it from scratch.
  
  # Observer for School_Principal_Regional_Graph clicks
  # This should be placed in your server.R file, outside of any output$... block,
  # but within the main server function.
  observeEvent(event_data("plotly_click", source = "schoolPrincipalRegionPlot"), {
    click_data <- event_data("plotly_click", source = "schoolPrincipalRegionPlot")
    if (!is.null(click_data)) {
      # Store the combined key (e.g., "Region I School Principal")
      rv$latest_principal_click_key <- click_data$key
    } else {
      # If a click somehow clears, reset the key
      rv$latest_principal_click_key <- NULL
    }
  })
  
  output$School_Principal_Division_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      select(Division, Designation) %>%
      group_by(Division, Designation) %>%
      summarize(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Designation) %>%
      summarise(TotalCount = sum(Count))
    
    designation_levels <- c("School Principal", "Teacher-in-Charge", "Officer-in-Charge")
    
    p <- ggplot(plot_data,
                aes(x = factor(Designation, levels = designation_levels),
                    y = Count,
                    fill = Division,
                    key = paste(Division, Designation),
                    text = paste("Division: ", Division,
                                 "<br>Designation: ", Designation,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Designation, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Designation", y = "Count of Individuals",
           title = "Division School Principal Shortage by Designation") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "schoolPrincipalDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  output$School_Principal_District_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected Legislative Districts") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      select(Division, Legislative.District, Designation) %>%
      group_by(Division, Legislative.District, Designation) %>%
      summarize(Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Designation) %>%
      summarise(TotalCount = sum(Count))
    
    plot_data <- plot_data %>%
      mutate(Division_LegDist = paste0(Division, " - ", Legislative.District))
    
    designation_levels <- c("School Principal", "Teacher-in-Charge", "Officer-in-Charge")
    
    p <- ggplot(plot_data,
                aes(x = factor(Designation, levels = designation_levels),
                    y = Count,
                    fill = Division_LegDist,
                    key = paste(Division_LegDist, Designation),
                    text = paste("Legislative District: ", Legislative.District,
                                 "<br>Designation: ", Designation,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Designation, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Designation", y = "Count of Individuals",
           title = "Legislative District School Principal Shortage by Designation") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "schoolPrincipalDistrictPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  # Reactive expression for filtering the School Principal table data
  # based on dashboard filters and plot clicks
  # This assumes 'filtered_school_principal_data()' provides the base data.
  filtered_principal_table_data <- reactive({
    # Ensure base data is available.
    req(filtered_school_data_division())
    
    # Start with the data filtered by dashboard inputs
    data <- filtered_school_data_division()
    
    # Now, filter based on the latest plot click for School Principal graph
    clicked_region <- NULL
    clicked_designation <- NULL
    
    if (!is.null(rv$latest_principal_click_key)) {
      clicked_key <- as.character(rv$latest_principal_click_key)
      
      # Define the possible designation levels for parsing (order matters for accurate matching)
      designation_levels_for_parsing <- c("School Principal", "Teacher-in-Charge", "Officer-in-Charge")
      # Sort by length descending to match longer names first
      designation_levels_ordered_by_length <- designation_levels_for_parsing[order(nchar(designation_levels_for_parsing), decreasing = TRUE)]
      
      found_designation <- FALSE
      for (desig_val in designation_levels_ordered_by_length) {
        # Check if the designation type is at the end of the key string
        if (grepl(paste0(" ", desig_val, "$"), clicked_key)) { # Prepend space to ensure full word match
          clicked_designation <- desig_val
          # The region is everything before this designation type
          clicked_region <- sub(paste0(" ", desig_val, "$"), "", clicked_key)
          found_designation <- TRUE
          break
        }
      }
      
      if (!found_designation) {
        # Fallback if parsing fails, return data filtered only by dashboard inputs
        clicked_region <- NULL
        clicked_designation <- NULL
        warning("Could not parse clicked Principal key for Region and Designation: ", clicked_key)
      }
    }
    
    if (!is.null(clicked_region) && !is.null(clicked_designation)) {
      # Apply filter based on click data if both are valid
      data <- data %>%
        filter(Region == clicked_region,
               Designation == clicked_designation) %>%
        select(SchoolID, Region, Division, Designation) # Adjust columns as needed for your table
    } else {
      # If no specific bar is clicked, or parsing failed,
      # show all schools from the dashboard filters with any of these designations
      data <- data %>%
        filter(Designation %in% designation_levels) %>% # Ensure only valid designations are included
        select(SchoolID, Region, Division, Designation) # Adjust columns as needed for your table
    }
    
    return(data)
  })
  
  # Your DT::renderDT for School_Principal_All_List
  output$School_Principal_All_List <- DT::renderDT({
    table_to_display <- filtered_school_data_division() %>% select(Region, Division, Legislative.District, SchoolID, School.Name, Designation) %>% rename("School Head Designation" = Designation)
    
    if (nrow(table_to_display) == 0) {
      return(DT::datatable(data.frame(Message = "No principal data available for this selection."), options = list(dom = 't')))
    }
    
    DT::datatable(table_to_display %>% slice(1:100),
                  options = list(pageLength = 10, scrollX = TRUE, filter = "top"),
                  rownames = FALSE)
  })
  
  # In your server.R file, ensure 'rv' is initialized with the new reactive value:
  # rv <- reactiveValues(
  #   latest_click_key = NULL,           # For school_count graph
  #   latest_sosss_click_key = NULL,     # For SOSSS graph
  #   latest_classroom_click_key = NULL, # For Classroom Shortage graph
  #   latest_teacher_shortage_click_key = NULL, # For Teacher Shortage graph
  #   latest_principal_click_key = NULL, # For School Principal graph
  #   latest_aoii_click_key = NULL       # New: For AOII Deployment graph
  # )
  # Make sure to include all rv initializations from previous steps if you are creating it from scratch.
  
  # Observer for AOII_Regional_Graph clicks
  # This should be placed in your server.R file, outside of any output$... block,
  # but within the main server function.
  observeEvent(event_data("plotly_click", source = "aoiiRegionPlot"), {
    click_data <- event_data("plotly_click", source = "aoiiRegionPlot")
    if (!is.null(click_data)) {
      # Store the combined key (e.g., "Region I None Deployed")
      rv$latest_aoii_click_key <- click_data$key
    } else {
      # If a click somehow clears, reset the key
      rv$latest_aoii_click_key <- NULL
    }
  })
  
  output$AOII_Division_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected divisions") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Division, Clustering.Status) %>%
      summarise(Total_Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(Clustering.Status) %>%
      summarise(TotalCount = sum(Total_Count))
    
    clustering_levels <- c("None Deployed", "Clustered", "Dedicated")
    
    p <- ggplot(plot_data,
                aes(x = factor(Clustering.Status, levels = clustering_levels),
                    y = Total_Count,
                    fill = Division,
                    text = paste("Division: ", Division,
                                 "<br>Clustering Status: ", Clustering.Status,
                                 "<br>Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Clustering.Status, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Clustering Status",
           y = "Total Count of Schools",
           title = "Division AO II Deployment by Clustering Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "aoiiDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  output$AOII_District_Graph <- renderPlotly({
    
    # --- Hide plot when no region/division is selected ---
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (is.null(current_filtered_data) || nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, 
                                 label = "No data for selected legislative districts") +
                        theme_void()))
    }
    
    plot_data <- current_filtered_data %>%
      group_by(Division, Legislative.District, Clustering.Status) %>%
      summarise(Total_Count = n(), .groups = 'drop') %>%
      mutate(Division_LegDist = paste0(Division, " - ", Legislative.District))
    
    plot_data_totals <- plot_data %>%
      group_by(Clustering.Status) %>%
      summarise(TotalCount = sum(Total_Count))
    
    clustering_levels <- c("None Deployed", "Clustered", "Dedicated")
    
    p <- ggplot(plot_data,
                aes(x = factor(Clustering.Status, levels = clustering_levels),
                    y = Total_Count,
                    fill = Division_LegDist,
                    text = paste("Legislative District: ", Legislative.District,
                                 "<br>Clustering Status: ", Clustering.Status,
                                 "<br>Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) +
      geom_text(data = plot_data_totals,
                aes(x = Clustering.Status, y = TotalCount * 1.05, 
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE,
                size = 3.5, color = "black") +
      labs(x = "Clustering Status",
           y = "Total Count of Schools",
           title = "Legislative District AO II Deployment by Clustering Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "aoiiDistrictPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  # Reactive expression for filtering the AOII table data
  # based on dashboard filters and plot clicks
  # This assumes 'filtered_school_data_region()' provides the base data.
  filtered_aoii_table_data <- reactive({
    # Ensure base data is available.
    req(filtered_school_data_region())
    
    # Start with the data filtered by dashboard inputs
    data <- filtered_school_data_region()
    
    # Now, filter based on the latest plot click for AOII graph
    clicked_region <- NULL
    clicked_clustering_status <- NULL
    
    if (!is.null(rv$latest_aoii_click_key)) {
      clicked_key <- as.character(rv$latest_aoii_click_key)
      
      # Define the possible clustering status levels for parsing (order matters for accurate matching)
      clustering_levels_for_parsing <- c("None Deployed", "Clustered", "Dedicated")
      # Sort by length descending to match longer names first
      clustering_levels_ordered_by_length <- clustering_levels_for_parsing[order(nchar(clustering_levels_for_parsing), decreasing = TRUE)]
      
      found_status <- FALSE
      for (status_val in clustering_levels_ordered_by_length) {
        # Check if the status type is at the end of the key string
        if (grepl(paste0(" ", status_val, "$"), clicked_key)) { # Prepend space to ensure full word match
          clicked_clustering_status <- status_val
          # The region is everything before this status type
          clicked_region <- sub(paste0(" ", status_val, "$"), "", clicked_key)
          found_status <- TRUE
          break
        }
      }
      
      if (!found_status) {
        # Fallback if parsing fails, return data filtered only by dashboard inputs
        clicked_region <- NULL
        clicked_clustering_status <- NULL
        warning("Could not parse clicked AOII key for Region and Clustering Status: ", clicked_key)
      }
    }
    
    if (!is.null(clicked_region) && !is.null(clicked_clustering_status)) {
      # Apply filter based on click data if both are valid
      data <- data %>%
        filter(Region == clicked_region,
               Clustering.Status == clicked_clustering_status) %>%
        # Select relevant columns for display in the table
        select(SchoolID, Region, Division, Clustering.Status) # Adjust columns as needed
    } else {
      # If no specific bar segment is clicked, or parsing failed,
      # show all schools from the dashboard filters that have any of these clustering statuses
      data <- data %>%
        filter(Clustering.Status %in% clustering_levels) %>% # Ensure only valid statuses are included
        select(SchoolID, Region, Division, Clustering.Status) # Adjust columns as needed
    }
    
    return(data)
  })
  
  # Your DT::renderDT for AOII_Data_Table
  output$AOII_Data_Table <- DT::renderDT({
    table_to_display <- filtered_school_data_division() %>% select(Region, Division, Legislative.District, SchoolID, School.Name, Clustering.Status, Outlier.Status,PDOI_Deployment)
    
    if (nrow(table_to_display) == 0) {
      return(DT::datatable(data.frame(Message = "No AO II deployment data available for this selection."), options = list(dom = 't')))
    }
    
    DT::datatable(table_to_display %>% slice(1:100),
                  options = list(pageLength = 10, scrollX = TRUE, filter = "top"),
                  rownames = FALSE)
  })
  
  # In your server.R file, ensure 'rv' is initialized with the new reactive value:
  # rv <- reactiveValues(
  #   latest_click_key = NULL,           # For school_count graph
  #   latest_sosss_click_key = NULL,     # For SOSSS graph
  #   latest_classroom_click_key = NULL, # For Classroom Shortage graph
  #   latest_teacher_shortage_click_key = NULL, # For Teacher Shortage graph
  #   latest_principal_click_key = NULL, # For School Principal graph
  #   latest_aoii_click_key = NULL,      # For AOII Deployment graph
  #   latest_pdoi_click_key = NULL       # New: For PDOI Deployment graph
  # )
  # Make sure to include all rv initializations from previous steps if you are creating it from scratch.
  
  # Observer for PDOI_Regional_Graph clicks
  # This should be placed in your server.R file, outside of any output$... block,
  # but within the main server function.
  observeEvent(event_data("plotly_click", source = "pdoiRegionPlot"), {
    click_data <- event_data("plotly_click", source = "pdoiRegionPlot")
    if (!is.null(click_data)) {
      # Store the combined key (e.g., "Region I With PDO I")
      rv$latest_pdoi_click_key <- click_data$key
    } else {
      # If a click somehow clears, reset the key
      rv$latest_pdoi_click_key <- NULL
    }
  })
  
  
  output$PDOI_Division_Graph <- renderPlotly({
    # Hide plot when region or division is unselected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected divisions") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      select(Division, PDOI_Deployment) %>%
      group_by(Division, PDOI_Deployment) %>%
      summarize(Total_Count = n(), .groups = 'drop')
    
    plot_data_totals <- plot_data %>%
      group_by(PDOI_Deployment) %>%
      summarise(TotalCount = sum(Total_Count))
    
    pdoi_levels <- c("Without PDO I", "With PDO I")
    
    p <- ggplot(plot_data,
                aes(x = factor(PDOI_Deployment, levels = pdoi_levels),
                    y = Total_Count,
                    fill = Division,
                    text = paste("Division: ", Division,
                                 "<br>PDO I Deployment: ", PDOI_Deployment,
                                 "<br>Total Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black") +
      geom_text(data = plot_data_totals,
                aes(x = PDOI_Deployment, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs(x = "PDO I Deployment", y = "Total Count of Schools",
           title = "Division PDO I Deployment by Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "pdoiDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  output$PDOI_District_Graph <- renderPlotly({
    # Hide plot when region or division is unselected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_school_data_division()
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5, label = "No data for selected Legislative Districts") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      select(Division, Legislative.District, PDOI_Deployment) %>%
      group_by(Division, Legislative.District, PDOI_Deployment) %>%
      summarize(Total_Count = n(), .groups = 'drop') %>%
      mutate(Division_LegDist = paste0(Division, " - ", Legislative.District))
    
    plot_data_totals <- plot_data %>%
      group_by(PDOI_Deployment) %>%
      summarise(TotalCount = sum(Total_Count))
    
    pdoi_levels <- c("Without PDO I", "With PDO I")
    
    p <- ggplot(plot_data,
                aes(x = factor(PDOI_Deployment, levels = pdoi_levels),
                    y = Total_Count,
                    fill = Division_LegDist,
                    text = paste("Legislative District: ", Legislative.District,
                                 "<br>PDO I Deployment: ", PDOI_Deployment,
                                 "<br>Total Count: ", scales::comma(Total_Count)))) +
      geom_bar(stat = "identity", position = "stack", color = "black") +
      geom_text(data = plot_data_totals,
                aes(x = PDOI_Deployment, y = TotalCount * 1.05,
                    label = scales::comma(TotalCount)),
                inherit.aes = FALSE, size = 3.5, color = "black") +
      labs(x = "PDO I Deployment", y = "Total Count of Schools",
           title = "Legislative District PDO I Deployment by Status") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "pdoiDistrictPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  # Reactive expression for filtering the PDOI table data
  # based on dashboard filters and plot clicks
  # This assumes 'filtered_school_data_region()' provides the base data as per the graph's usage.
  filtered_pdoi_table_data <- reactive({
    # Ensure base data is available.
    req(filtered_school_data_region()) # Using filtered_school_data_region() as per the graph's source
    
    # Start with the data filtered by dashboard inputs
    data <- filtered_school_data_region() # Using filtered_school_data_region() as per the graph's source
    
    # Now, filter based on the latest plot click for PDOI graph
    clicked_region <- NULL
    clicked_pdoi_deployment <- NULL
    
    if (!is.null(rv$latest_pdoi_click_key)) {
      clicked_key <- as.character(rv$latest_pdoi_click_key)
      
      # Define the possible PDOI Deployment levels for parsing (order matters if some are substrings of others)
      pdoi_levels_for_parsing <- c("Without PDO I", "With PDO I")
      # Sort by length descending to match longer names first
      pdoi_levels_ordered_by_length <- pdoi_levels_for_parsing[order(nchar(pdoi_levels_for_parsing), decreasing = TRUE)]
      
      found_deployment <- FALSE
      for (deployment_val in pdoi_levels_ordered_by_length) {
        # Check if the deployment type is at the end of the key string
        if (grepl(paste0(" ", deployment_val, "$"), clicked_key)) { # Prepend space to ensure full word match
          clicked_pdoi_deployment <- deployment_val
          # The region is everything before this deployment type
          clicked_region <- sub(paste0(" ", deployment_val, "$"), "", clicked_key)
          found_deployment <- TRUE
          break
        }
      }
      
      if (!found_deployment) {
        # Fallback if parsing fails, return data filtered only by dashboard inputs
        clicked_region <- NULL
        clicked_pdoi_deployment <- NULL
        warning("Could not parse clicked PDOI key for Region and PDOI Deployment: ", clicked_key)
      }
    }
    
    if (!is.null(clicked_region) && !is.null(clicked_pdoi_deployment)) {
      # Apply filter based on click data if both are valid
      data <- data %>%
        filter(Region == clicked_region,
               PDOI_Deployment == clicked_pdoi_deployment) %>%
        # Select relevant columns for display in the table (adjust as needed)
        select(SchoolID, Region, Division, PDOI_Deployment)
    } else {
      # If no specific bar segment is clicked, or parsing failed,
      # show all schools from the dashboard filters that have any of these PDOI statuses
      data <- data %>%
        filter(PDOI_Deployment %in% pdoi_levels) %>% # Ensure only valid statuses are included
        select(SchoolID, Region, Division, PDOI_Deployment) # Adjust columns as needed
    }
    
    return(data)
  })
  
  # Your DT::renderDT for PDOI_Data_Table
  output$PDOI_Data_Table <- DT::renderDT({
    table_to_display <- filtered_school_data_division() %>% select(Region, Division, Legislative.District, SchoolID, School.Name, Clustering.Status, Outlier.Status,PDOI_Deployment)
    
    if (nrow(table_to_display) == 0) {
      return(DT::datatable(data.frame(Message = "No PDO I deployment data available for this selection."), options = list(dom = 't')))
    }
    
    DT::datatable(table_to_display %>% slice(1:100),
                  options = list(pageLength = 10, scrollX = TRUE, filter = "top"),
                  rownames = FALSE)
  })
  
  # In your server.R file, ensure 'rv' is initialized with the new reactive value:
  # rv <- reactiveValues(
  #   latest_click_key = NULL,           # For school_count graph
  #   latest_sosss_click_key = NULL,     # For SOSSS graph
  #   latest_classroom_click_key = NULL, # For Classroom Shortage graph
  #   latest_teacher_shortage_click_key = NULL, # For Teacher Shortage graph
  #   latest_principal_click_key = NULL, # For School Principal graph
  #   latest_aoii_click_key = NULL,      # For AOII Deployment graph
  #   latest_pdoi_click_key = NULL,      # For PDOI Deployment graph
  #   latest_sufficiency_click_key = NULL # New: For Sufficiency graph
  # )
  # Make sure to include all rv initializations from previous steps if you are creating it from scratch.
  
  # In your server.R file, ensure 'rv' is initialized with the new reactive value:
  # rv <- reactiveValues(
  #   latest_click_key = NULL,           # For school_count graph
  #   latest_sosss_click_key = NULL,     # For SOSSS graph
  #   latest_classroom_click_key = NULL, # For Classroom Shortage graph
  #   latest_teacher_shortage_click_key = NULL, # For Teacher Shortage graph
  #   latest_principal_click_key = NULL, # For School Principal graph
  #   latest_aoii_click_key = NULL,      # For AOII Deployment graph
  #   latest_pdoi_click_key = NULL,      # For PDOI Deployment graph
  #   latest_sufficiency_click_key = NULL # New: For Sufficiency graph
  # )
  # Make sure to include all rv initializations from previous steps if you are creating it from scratch.
  
  # Observer for Sufficiency_Regional_Graph clicks
  # This should be placed in your server.R file, outside of any output$... block,
  # but within the main server function.
  observeEvent(event_data("plotly_click", source = "sufficiencyRegionPlot"), {
    click_data <- event_data("plotly_click", source = "sufficiencyRegionPlot")
    if (!is.null(click_data)) {
      # Store the combined key (e.g., "Region I Critically Under-Resourced")
      rv$latest_sufficiency_click_key <- click_data$key
    } else {
      # If a click somehow clears, reset the key
      rv$latest_sufficiency_click_key <- NULL
    }
  })
  
  # Reactive for the raw data filtered by dashboard inputs and with sufficiency categories calculated
  # This will be the base for both the graph's aggregated data and the table's detailed data.
  filtered_sufficiency_raw_data_region <- reactive({
    # Ensure uni data is available.
    req(uni)
    
    # Start with the full dataset
    data <- uni
    
    # Filter by selected region(s) if any are chosen
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      data <- data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    # Data transformation to calculate sufficiency categories for each school
    data %>%
      select(SchoolID, Region, Division, Teacher, Classroom, School.Head, AO) %>%
      mutate(
        Teacher = as.numeric(Teacher),
        Classroom = as.numeric(Classroom),
        School.Head = as.numeric(School.Head),
        AO = as.numeric(AO) # Ensure AO is also numeric
      ) %>%
      mutate(
        Teacher.Sufficiency = case_when(
          (Teacher >= 0 & Teacher <= 0.25) ~ "Critically Under-Resourced",
          (Teacher > 0.25 & Teacher <= 0.5) ~ "Under-Resourced",
          (Teacher > 0.5 & Teacher <= 0.75) ~ "Resource-Deficient",
          (Teacher > 0.75 & Teacher <= 0.9) ~ "Adequately Resourced",
          (Teacher > 0.9 & Teacher <= 1) ~ "Generously Resourced",
          Teacher > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        Classroom.Sufficiency = case_when(
          (Classroom >= 0 & Classroom <= 0.25) ~ "Critically Under-Resourced",
          (Classroom > 0.25 & Classroom <= 0.5) ~ "Under-Resourced",
          (Classroom > 0.5 & Classroom <= 0.75) ~ "Resource-Deficient",
          (Classroom > 0.75 & Classroom <= 0.9) ~ "Adequately Resourced",
          (Classroom > 0.9 & Classroom <= 1) ~ "Generously Resourced",
          Classroom > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        SH.Sufficiency = case_when(
          (School.Head >= 0 & School.Head <= 0.25) ~ "Critically Under-Resourced",
          (School.Head > 0.25 & School.Head <= 0.5) ~ "Under-Resourced",
          (School.Head > 0.5 & School.Head <= 0.75) ~ "Resource-Deficient",
          (School.Head > 0.75 & School.Head <= 0.9) ~ "Adequately Resourced",
          (School.Head > 0.9 & School.Head <= 1) ~ "Generously Resourced",
          School.Head > 1 ~ "For Validation",
          TRUE ~ NA_character_
        ),
        AO.Sufficiency = case_when(
          (AO >= 0 & AO <= 0.25) ~ "Critically Under-Resourced",
          (AO > 0.25 & AO <= 0.5) ~ "Under-Resourced",
          (AO > 0.5 & AO <= 0.75) ~ "Resource-Deficient",
          (AO > 0.75 & AO <= 0.9) ~ "Adequately Resourced",
          (AO > 0.9 & AO <= 1) ~ "Generously Resourced",
          AO > 1 ~ "For Validation",
          TRUE ~ NA_character_
        )
      )
  })
  
  filtered_sufficiency_data_division <- reactive({
    req(filtered_sufficiency_raw_data_region())
    
    filtered_sufficiency_raw_data_region() %>%
      pivot_longer(
        cols = c(Teacher.Sufficiency, Classroom.Sufficiency, SH.Sufficiency, AO.Sufficiency),
        names_to = "Criteria",
        values_to = "Sufficiency"
      ) %>%
      filter(!is.na(Sufficiency)) %>% # Filter NA sufficiency before grouping
      group_by(Region, Division, Criteria, Sufficiency) %>%
      summarise(SufficiencyTotal = n(), .groups = 'drop_last') %>%
      # Calculate the total for each Division and Criteria for percentage calculation
      mutate(RegionCriteriaTotal = sum(SufficiencyTotal)) %>%
      mutate(Percentage = (SufficiencyTotal / RegionCriteriaTotal)) %>%
      ungroup() %>%
      mutate(Sufficiency = factor(Sufficiency, levels = c(
        "Critically Under-Resourced",
        "Under-Resourced",
        "Resource-Deficient",
        "Adequately Resourced",
        "Generously Resourced",
        "For Validation"))) # Ensure consistent order for plotting
  })
  
  
  output$Sufficiency_Division_Graph <- renderPlotly({
    # Use the reactive filtered data
    current_filtered_data_for_plot <- filtered_sufficiency_data_division()
    
    # Filter by the selected category from input$SuffOpt
    plot_data <- current_filtered_data_for_plot %>%
      filter(Criteria == input$SuffOpt)
    
    # --- Empty Data Handling ---
    if (nrow(plot_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = paste("No data for selected regions/divisions and category:", input$SuffOpt)) +
                        theme_void()))
    }
    
    # Determine the title based on the selected input$SuffOpt
    plot_title <- switch(input$SuffOpt,
                         "Teacher.Sufficiency" = "Regional Teacher Sufficiency by Category",
                         "Classroom.Sufficiency" = "Regional Classroom Sufficiency by Category",
                         "SH.Sufficiency" = "Regional School Principal Sufficiency by Category",
                         "AO.Sufficiency" = "Regional AO Sufficiency by Category",
                         "Regional Sufficiency Overview")
    
    # Calculate total percentages per region for the overall labels on top of stacked bars
    # This needs to be done *after* filtering by Criteria
    total_labels_data <- plot_data %>%
      group_by(Division) %>%
      summarise(Grand_Total_Percentage = sum(Percentage), .groups = 'drop') # Sum percentages for labeling
    
    # Define specific colors for Sufficiency (adjust as per your actual categories and desired colors)
    sufficiency_colors <- c(
      "Critically Under-Resourced" = "#E41A1C", # Red
      "Under-Resourced" = "#FF7F00",        # Orange
      "Resource-Deficient" = "#FFFF33",     # Yellow
      "Adequately Resourced" = "#A6CEE3",   # Light Blue
      "Generously Resourced" = "#33A02C",   # Green
      "For Validation" = "#BEBADA"          # Grey/Purple for validation
    )
    # Define the levels for Sufficiency for consistent stacking order in the legend and on the bars
    sufficiency_levels_ordered <- c(
      "Critically Under-Resourced",
      "Under-Resourced",
      "Resource-Deficient",
      "Adequately Resourced",
      "Generously Resourced",
      "For Validation"
    )
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = reorder(Division, -Percentage), # Reorder regions based on the percentage of the current 'Criteria' and 'Sufficiency'
                    y = Percentage,
                    fill = factor(Sufficiency, levels = sufficiency_levels_ordered), # Fill by Sufficiency for stacking and consistent order
                    # IMPORTANT: Add 'key' aesthetic here to store combined info for click events
                    key = paste(Division, Sufficiency),
                    text = paste("Region: ", Division,
                                 "<br>Sufficiency: ", Sufficiency,
                                 "<br>Percentage: ", scales::percent(Percentage, accuracy = 0.1),
                                 "<br>Total Schools (Category): ", scales::comma(SufficiencyTotal)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "stack", color = "black", size = 0.25) + # Changed to position="stack" for stacked bars
      scale_fill_manual(values = sufficiency_colors, name = "Sufficiency Category") + # Apply custom colors
      labs(x = "Region",
           y = "Percentage",
           fill = "Sufficiency Category",
           title = plot_title) +
      scale_y_continuous(labels = scales::percent, limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Format y-axis as percentage
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "sufficiencyRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest", # Changed to "closest" for individual segment tooltips
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  # Reactive expression for filtering the Sufficiency table data
  # based on dashboard filters, input$SuffOpt, and plot clicks
  filtered_sufficiency_table_data <- reactive({
    # Ensure raw data with calculated sufficiency is available.
    req(filtered_sufficiency_raw_data_region())
    
    # Start with the data already filtered by dashboard inputs and with sufficiency calculated
    data <- filtered_sufficiency_raw_data_region()
    
    # Apply filter by input$SuffOpt immediately
    req(input$SuffOpt) # Ensure input$SuffOpt is not NULL
    data <- data %>%
      filter(get(input$SuffOpt) %in% c(
        "Critically Under-Resourced",
        "Under-Resourced",
        "Resource-Deficient",
        "Adequately Resourced",
        "Generously Resourced",
        "For Validation"
      )) # Filter out NA or unexpected values in the selected sufficiency column
    
    # Select only the relevant sufficiency column to simplify subsequent filtering
    data_filtered_by_suffopt <- data %>%
      select(SchoolID, Region, Division, Teacher, Classroom, School.Head, AO, !!sym(input$SuffOpt)) %>%
      rename(SelectedSufficiency = !!sym(input$SuffOpt)) # Rename for easier generic filtering below
    
    # Now, filter based on the latest plot click for Sufficiency graph
    clicked_region <- NULL
    clicked_sufficiency_status <- NULL
    
    if (!is.null(rv$latest_sufficiency_click_key)) {
      clicked_key <- as.character(rv$latest_sufficiency_click_key)
      
      # Define the possible Sufficiency levels for parsing (order matters: longest first)
      sufficiency_levels_for_parsing <- c(
        "Critically Under-Resourced",
        "Under-Resourced",
        "Resource-Deficient",
        "Adequately Resourced",
        "Generously Resourced",
        "For Validation"
      )
      # Sort by length descending to match longer names first
      sufficiency_levels_ordered_by_length <- sufficiency_levels_for_parsing[order(nchar(sufficiency_levels_for_parsing), decreasing = TRUE)]
      
      found_status <- FALSE
      for (status_val in sufficiency_levels_ordered_by_length) {
        # Check if the status type is at the end of the key string with a preceding space
        if (grepl(paste0(" ", status_val, "$"), clicked_key)) {
          clicked_sufficiency_status <- status_val
          # The region is everything before this status type
          clicked_region <- sub(paste0(" ", status_val, "$"), "", clicked_key)
          found_status <- TRUE
          break
        }
      }
      
      if (!found_status) {
        # Fallback if parsing fails, return data filtered only by dashboard inputs and SuffOpt
        clicked_region <- NULL
        clicked_sufficiency_status <- NULL
        warning("Could not parse clicked Sufficiency key for Region and Sufficiency Status: ", clicked_key)
      }
    }
    
    if (!is.null(clicked_region) && !is.null(clicked_sufficiency_status)) {
      # Apply filter based on click data if both are valid
      final_data <- data_filtered_by_suffopt %>%
        filter(Region == clicked_region,
               SelectedSufficiency == clicked_sufficiency_status)
    } else {
      # If no specific bar segment is clicked, or parsing failed,
      # show all schools from the dashboard filters for the selected SuffOpt
      final_data <- data_filtered_by_suffopt
    }
    
    # Select final columns for the table display. Adjust as needed.
    # Include the original numeric columns if desired, and the specific sufficiency column selected.
    final_data %>%
      select(SchoolID, Region, Division, Teacher, Classroom, School.Head, AO, SelectedSufficiency)
    
  })
  
  # Your DT::renderDT for Sufficiency_All_List
  output$Sufficiency_All_List <- DT::renderDT({
    table_to_display <- filtered_sufficiency_table_data()
    
    if (nrow(table_to_display) == 0) {
      # Display a more informative message including the selected Sufficiency Option
      return(DT::datatable(data.frame(Message = paste0("No school data available for '",
                                                       gsub("\\.", " ", input$SuffOpt), # Clean up SuffOpt for display
                                                       "' with current filters and graph selection.")),
                           options = list(dom = 't', filter = "top")))
    }
    
    # Dynamically format columns if they exist.
    # This section needs to consider which numeric columns are relevant based on input$SuffOpt.
    # You might want to format 'Teacher', 'Classroom', 'School.Head', 'AO' as percentages or numbers.
    # For simplicity, let's just format the "SelectedSufficiency" column as text.
    # For numeric columns like Teacher, Classroom etc., you'd typically apply formatPercentage or formatCurrency.
    # If the table should show all original numeric values, ensure they are selected above in filtered_sufficiency_table_data.
    
    dt_table <- DT::datatable(table_to_display %>% slice(1:100),
                              options = list(pageLength = 10, scrollX = TRUE, filter = "top"),
                              rownames = FALSE)
    
    # Example: Format Teacher, Classroom, SH, AO as percentages if they are in the table
    # You might need to adjust this based on the specific columns you want to display in the final table.
    numeric_sufficiency_cols <- c("Teacher", "Classroom", "School.Head", "AO")
    for (col in numeric_sufficiency_cols) {
      if (col %in% colnames(table_to_display)) {
        dt_table <- dt_table %>% formatPercentage(col, 2) # Format as percentage with 2 decimal places
      }
    }
    
    dt_table
  })
  
  rv <- reactiveValues(
    latest_click_key = NULL,
    latest_sosss_click_key = NULL,
    latest_classroom_click_key = NULL,
    latest_teacher_shortage_click_key = NULL,
    latest_principal_click_key = NULL,
    latest_aoii_click_key = NULL,
    latest_pdoi_click_key = NULL,
    latest_sufficiency_click_key = NULL
  )
  
  observeEvent(
    event_data("plotly_click", source = "classroomShortageRegionPlot"),
    {
      click_data <- event_data("plotly_click", source = "classroomShortageRegionPlot")
      rv$latest_classroom_click_key <- if (!is.null(click_data)) click_data$key else NULL
    }
  )
  
  output$Classroom_Shortage_Division_Graph <- renderPlotly({
    
    # Hide plot when region or division is unselected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_LMS_division()
    
    # Handle empty data
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected divisions") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      mutate(Estimated_CL_Shortage = as.numeric(Estimated_CL_Shortage)) %>%
      group_by(Division) %>%
      summarise(Count = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = "drop")
    
    # Plot
    p <- ggplot(plot_data,
                aes(x = reorder(Division, -Count),
                    y = Count,
                    fill = Division,
                    text = paste0("Division: ", Division,
                                  "<br>Classroom Shortage: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", color = "black") +
      geom_text(aes(y = Count * 1.05, label = scales::comma(Count)),
                size = 3.5, color = "black") +
      labs(  title = "Division Classroom Shortage Distribution", x = "Division", y = "Classroom Shortage") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "none",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "classroomShortage_division") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  
  output$Classroom_Shortage_District_Graph <- renderPlotly({
    
    # Hide plot when region or division is unselected
    if (is.null(input$dashboard_region_filter) || length(input$dashboard_region_filter) == 0 ||
        is.null(input$dashboard_division_filter) || length(input$dashboard_division_filter) == 0) {
      return(NULL)
    }
    
    current_filtered_data <- filtered_LMS_division()
    
    # Handle empty data
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(
        ggplot() +
          annotate("text", x = 0.5, y = 0.5,
                   label = "No data for selected legislative districts") +
          theme_void()
      ))
    }
    
    # Prepare data
    plot_data <- current_filtered_data %>%
      mutate(Estimated_CL_Shortage = as.numeric(Estimated_CL_Shortage)) %>%
      group_by(Division, Legislative_District) %>%
      summarise(Count = sum(Estimated_CL_Shortage, na.rm = TRUE), .groups = "drop") %>%
      mutate(Division_LegDist = paste0(Division, " - ", Legislative_District))
    
    # Plot
    p <- ggplot(plot_data,
                aes(x = reorder(Division_LegDist, -Count),
                    y = Count,
                    fill = Division_LegDist,
                    text = paste0("Legislative District: ", Division_LegDist,
                                  "<br>Classroom Shortage: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", color = "black") +
      geom_text(aes(y = Count * 1.05, label = scales::comma(Count)),
                size = 3.5, color = "black") +
      labs(title = "District Classroom Shortage Distribution",x = "Legislative District", y = "Classroom Shortage") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "none",
            plot.title = element_text(hjust = 0.5))
    
    ggplotly(p, tooltip = "text", source = "classroomShortage_district") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             hovermode = "closest",
             margin = list(b = 100))
  })
  
  
  filtered_classroom_shortage_table_data <- reactive({
    req(filtered_school_data_region())
    
    data <- filtered_school_data_region() |>
      mutate(Est.CS = as.numeric(Est.CS)) |>
      filter(Est.CS > 0)
    
    if (!is.null(rv$latest_classroom_click_key)) {
      data <- data |> filter(Region == rv$latest_classroom_click_key)
    }
    
    data |>
      select(SchoolID, Region, Division, Est.CS) |>
      rename(`Classroom Shortage` = Est.CS)
  })
  
  clicked_info <- reactiveVal(NULL)
  
  observeEvent(plotly::event_data("plotly_click", source = "teacherShortageRegionPlot"), {
    click <- plotly::event_data("plotly_click", source = "teacherShortageRegionPlot")
    
    if (!is.null(click)) {
      region_clicked <- click$x
      
      # Print for debugging
      print(paste("Clicked Region:", region_clicked))
      
      clicked_info(region_clicked)
    }
  })
  
  
  
  output$Teacher_Shortage_Data_Table <- DT::renderDT({
    data <- DBMProp
    
    # Clean Region column to remove any whitespace
    data <- data %>%
      mutate(Region = stringr::str_trim(as.character(Region)))
    
    # Apply region filter if user has clicked
    region <- clicked_info()
    
    if (!is.null(region)) {
      region <- stringr::str_trim(as.character(region))  # trim click data too
      data <- data %>%
        filter(Region == region)
    }
    
    datatable(
      data,
      rownames = FALSE,
      options = list(
        scrollX = TRUE,
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
  })
  
  # New reactive expression for the Teacher Shortage Regional Summary Table
  # New reactive expression for the Teacher Shortage Regional Summary Table (now by Division within a clicked Region)
  filtered_teacher_shortage_regional_summary_data <- reactive({
    req(filtered_teacher_shortage_data_region())
    data <- filtered_teacher_shortage_data_region()
    
    # Ensure shortage columns are numeric
    data <- data %>%
      mutate(
        ES_Shortage = as.numeric(ES_Shortage),
        JHS_Shortage = as.numeric(JHS_Shortage),
        SHS_Shortage = as.numeric(SHS_Shortage)
      )
    
    clicked_region <- NULL
    # We only care about the region here, not the specific inventory type clicked for this summary
    if (!is.null(rv$latest_teacher_shortage_click_key)) {
      clicked_key <- as.character(rv$latest_teacher_shortage_click_key)
      split_key <- strsplit(clicked_key, "::")[[1]]
      if (length(split_key) >= 1) { # Only need the first part for Region
        clicked_region <- split_key[1]
      }
    }
    
    if (!is.null(clicked_region)) {
      # If a specific region was clicked: summarize by Division within that region
      summary_data <- data %>%
        filter(Region == clicked_region) %>%
        group_by(Region, Division) %>%
        summarize(
          `Total ES Shortage` = sum(ES_Shortage, na.rm = TRUE),
          `Total JHS Shortage` = sum(JHS_Shortage, na.rm = TRUE),
          `Total SHS Shortage` = sum(SHS_Shortage, na.rm = TRUE),
          `Overall Shortage` = sum(ES_Shortage, JHS_Shortage, SHS_Shortage, na.rm = TRUE),
          .groups = 'drop'
        ) %>%
        select(Region, Division, `Total ES Shortage`, `Total JHS Shortage`, `Total SHS Shortage`, `Overall Shortage`)
    } else {
      # If no specific region is clicked (initial state or click reset):
      # Summarize by Division across all currently dashboard-filtered regions
      summary_data <- data %>%
        group_by(Region, Division) %>%
        summarize(
          `Total ES Shortage` = sum(ES_Shortage, na.rm = TRUE),
          `Total JHS Shortage` = sum(JHS_Shortage, na.rm = TRUE),
          `Total SHS Shortage` = sum(SHS_Shortage, na.rm = TRUE),
          `Overall Shortage` = sum(ES_Shortage, JHS_Shortage, SHS_Shortage, na.rm = TRUE),
          .groups = 'drop'
        ) %>%
        select(Region, Division, `Total ES Shortage`, `Total JHS Shortage`, `Total SHS Shortage`, `Overall Shortage`)
    }
    
    return(summary_data)
  })
  # Make sure to include the 'filtered_teacher_shortage_regional_summary_data' reactive
  # that I provided in the previous step, before this DT::renderDT.
  
  # DT::renderDT for the new Teacher Shortage Regional Summary Table
  # This will display the aggregated regional data, filtered by graph clicks or dashboard inputs.
  # DT::renderDT for the new Teacher Shortage Regional Summary Table
  # This will display the aggregated regional data by division, filtered by graph clicks or dashboard inputs.
  output$Teacher_Shortage_Regional_Table <- DT::renderDT({
    table_to_display <- filtered_teacher_shortage_regional_summary_data()
    
    # Handle case where no data is available based on filters/clicks
    if (nrow(table_to_display) == 0) {
      return(DT::datatable(data.frame(Message = "No regional teacher shortage data available for this selection."), options = list(dom = 't')))
    }
    
    # Render the data table
    DT::datatable(table_to_display %>% slice(1:100),
                  options = list(pageLength = 10, scrollX = TRUE, filter = "top"),
                  rownames = FALSE) %>%
      # Format the shortage columns as integers with commas
      formatCurrency(c("Total ES Shortage", "Total JHS Shortage", "Total SHS Shortage", "Overall Shortage"), currency = '', digits = 0)
  })
  
  observeEvent(event_data("plotly_click", source = "teacherShortageRegionPlot"), {
    click_data <- event_data("plotly_click", source = "teacherShortageRegionPlot")
    if (!is.null(click_data)) {
      rv$latest_teacher_shortage_click_key <- click_data$key
      # Add a print statement here to see if the click is registered
      print(paste("Graph Clicked! Key:", click_data$key))
    } else {
      rv$latest_teacher_shortage_click_key <- NULL
    }
  })
  
  filtered_teacher_shortage_table_data <- reactive({
    # Add this print statement
    print(paste("filtered_teacher_shortage_table_data: rv$latest_teacher_shortage_click_key =", rv$latest_teacher_shortage_click_key))
    
    req(filtered_teacher_shortage_data())
    data <- filtered_teacher_shortage_data()
    
    # ... (rest of your reactive code) ...
    
    if (!is.null(clicked_region) && !is.null(clicked_inventory_type)) {
      # Add this print statement
      print(paste("Filtering for Region:", clicked_region, "Type:", clicked_inventory_type))
      # ... (rest of filtering logic) ...
    } else {
      # Add this print statement
      print("No specific click, showing all relevant data.")
      # ... (rest of else logic) ...
    }
    
    # Add this print statement before returning
    print(paste("filtered_teacher_shortage_table_data: Rows in final_data =", nrow(final_data)))
    
    return(final_data)
  })
  
  # server.R
  
  # Ensure 'uni' is accessible (e.g., loaded at the top of server.R or globally)
  # For demonstration, let's assume 'uni' is a data.frame already loaded.
  # If 'uni' is a reactive expression, use uni() when accessing it.
  # Example:
  # uni <- read.csv("your_data.csv") # Or whatever your data source is
  
  # --- Reactive Values for Global Filtering (if you have them, not shown here) ---
  # Example:
  # filtered_school_data <- reactive({
  #   # Your global filtering logic here
  #   # e.g., uni %>%
  #   #   filter(Region %in% input$selected_region,
  #   #          Modified.COC %in% input$selected_coc_type)
  #   # For this example, let's assume it's just 'uni' for simplicity
  #   uni
  # })
  
  
  # reactiveVal to store the data for the table based on clicks
  reactive_clicked_school_data <- reactiveVal(
    data.frame(
      SchoolID = character(),
      SchoolName = character(),
      Region = character(),
      Division = character(),
      Legislative.District = character(),
      Modified.COC = character(),
      stringsAsFactors = FALSE
    )
  )
  
  # A reactive value to track if a chart has been clicked (and to show click-filtered data)
  # This helps distinguish between initial load/global filter and click-filtered state
  rv <- reactiveValues(
    chart_clicked = FALSE # TRUE if any chart was clicked, FALSE otherwise
  )
  
  # Observe click events from the regional plot
  observeEvent(event_data("plotly_click", source = "schoolcountplot_region"), {
    click_data <- event_data("plotly_click", source = "schoolcountplot_region")
    print("Regional graph clicked!") # DEBUG
    
    req(click_data, click_data$key, is.character(click_data$key))
    
    clicked_info <- click_data$key
    print(paste0("Regional Clicked Key (raw): '", clicked_info, "'")) # DEBUG
    
    # Use strsplit with fixed = TRUE for literal "|"
    parsed_info <- strsplit(clicked_info, "|", fixed = TRUE)[[1]]
    region_name <- trimws(parsed_info[1]) # Trim whitespace, just in case
    school_type <- trimws(parsed_info[2]) # Trim whitespace
    
    print(paste0("Regional Parsed: Region = '", region_name, "', School Type = '", school_type, "'")) # DEBUG
    
    # Filter the original 'uni' data based on the click
    # IMPORTANT: Make sure 'uni' is the correct dataset and columns match
    filtered_schools <- uni %>%
      filter(Region == region_name, Modified.COC == school_type)
    
    print(paste("Regional Filtered Schools Count:", nrow(filtered_schools))) # DEBUG
    if (nrow(filtered_schools) > 0) {
      print("Head of Regional Filtered Schools:") # DEBUG
      print(head(filtered_schools)) # DEBUG (See first few rows of filtered data)
    } else {
      print("No schools found after filtering for this regional click.")
    }
    
    reactive_clicked_school_data(filtered_schools)
    rv$chart_clicked <- TRUE # Indicate that a chart has been clicked
  })
  
  # Observe click events from the division plot
  observeEvent(event_data("plotly_click", source = "schoolcountplot_division"), {
    click_data <- event_data("plotly_click", source = "schoolcountplot_division")
    print("Division graph clicked!") # DEBUG
    
    req(click_data, click_data$key, is.character(click_data$key))
    
    clicked_info <- click_data$key
    print(paste0("Division Clicked Key (raw): '", clicked_info, "'")) # DEBUG
    
    # Assuming key is now "DivisionName|SchoolTypeWithSpaces"
    parsed_info <- strsplit(clicked_info, "|", fixed = TRUE)[[1]]
    division_name <- trimws(parsed_info[1])
    school_type <- trimws(parsed_info[2])
    
    print(paste0("Division Parsed: Division = '", division_name, "', School Type = '", school_type, "'")) # DEBUG
    
    # Make sure you're filtering the correct base data.
    # If filtered_school_data_region() is meant to be the *source* for division filtering, use it.
    # Otherwise, filter from the main 'uni' dataset, applying prior filters if necessary.
    # For simplicity and correctness, let's filter from 'uni' directly here.
    # If you have an existing chain of filters (e.g., region -> division), ensure that logic.
    # For now, let's assume `uni` is the base.
    filtered_schools <- uni %>%
      filter(Division == division_name, Modified.COC == school_type)
    
    print(paste("Division Filtered Schools Count:", nrow(filtered_schools))) # DEBUG
    
    reactive_clicked_school_data(filtered_schools)
    rv$chart_clicked <- TRUE # Indicate that a chart has been clicked
  })
  
  # Observe click events from the district plot
  observeEvent(event_data("plotly_click", source = "schoolcountplot_district"), {
    click_data <- event_data("plotly_click", source = "schoolcountplot_district")
    print("District graph clicked!") # DEBUG
    
    req(click_data, click_data$key, is.character(click_data$key))
    
    clicked_info <- click_data$key
    print(paste0("District Clicked Key (raw): '", clicked_info, "'")) # DEBUG
    
    # Assuming key is now "DistrictName|SchoolTypeWithSpaces"
    parsed_info <- strsplit(clicked_info, "|", fixed = TRUE)[[1]]
    district_name <- trimws(parsed_info[1])
    school_type <- trimws(parsed_info[2])
    
    print(paste0("District Parsed: District = '", district_name, "', School Type = '", school_type, "'")) # DEBUG
    
    # Make sure you're filtering the correct base data.
    # Same as division, filter from 'uni' or your intended pre-filtered reactive.
    filtered_schools <- uni %>%
      filter(Legislative.District == district_name, Modified.COC == school_type)
    
    print(paste("District Filtered Schools Count:", nrow(filtered_schools))) # DEBUG
    
    reactive_clicked_school_data(filtered_schools)
    rv$chart_clicked <- TRUE # Indicate that a chart has been clicked
  })
  
  output$school_count_data_table <- DT::renderDT({
    
    data_to_display <- filtered_school_data_division() %>% select(Region, Division, Legislative.District, SchoolID, School.Name, Modified.COC) %>% rename("Modified Curricular OFfering" = Modified.COC)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$regprof_DT <- DT::renderDT({
    data_to_display <- filtered_school_data_region() %>% 
      select(Region, Division, Legislative.District, SchoolID, School.Name, School.Type, School.Size.Typology, Modified.COC, TotalEnrolment, Clustering.Status, PDOI_Deployment) %>% 
      rename("Modified Curricular Offering" = Modified.COC)
    
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't', scrollX = TRUE, fixedColumns = list(leftColumns = 5)),
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      extensions = c("FixedHeader", "FixedColumns", "Buttons"),
      options = list(
        pageLength = 10, 
        scrollX = TRUE,
        scrollY = 400,
        autoWidth = TRUE,
        fixedHeader = TRUE,
        fixedColumns = list(leftColumns = 5),
        dom = 'Bfrtip',
        buttons = list(
          list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "print", exportOptions = list(modifier = list(page = "all")))
        )
      ),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$regprof_DT_CL <- DT::renderDT({
    data_to_display <- filtered_LMS_region() %>%
      mutate(across(13:17, ~ case_when(
        . == 0 ~ "No",
        TRUE ~ "Yes"
      ))) %>% 
      select(Region, Division, Legislative_District, School_ID, School_Name, Total_Enrollment, Instructional_Rooms, Estimated_CL_Shortage, With_Excess, Without_Shortage, Buildable_space, LMS, GIDCA) %>% 
      rename(
        "Estimated Classroom Shortage" = Estimated_CL_Shortage,
        "Schools with Excess Classrooms" = With_Excess,
        "Schools without Classroom Shortage" = Without_Shortage,
        "Schools with Buildable Space" = Buildable_space
      )
    
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't', scrollX = TRUE, fixedColumns = list(leftColumns = 5)),
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      extensions = c("FixedHeader", "FixedColumns", "Buttons"),
      options = list(
        pageLength = 10, 
        scrollX = TRUE,
        scrollY = 400,
        autoWidth = TRUE,
        fixedHeader = TRUE,
        fixedColumns = list(leftColumns = 5),
        dom = 'Bfrtip',
        buttons = list(
          list(extend = "csv", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "excel", exportOptions = list(modifier = list(page = "all"))),
          list(extend = "print", exportOptions = list(modifier = list(page = "all")))
        )
      ),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  filtered_cloud_region <- reactive({
    req(cloud)
    
    temp_data <- cloud
    
    if (!is.null(input$cloud_region_filter) && length(input$cloud_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.REGION %in% input$cloud_region_filter)
    }
    
    if (!is.null(input$cloud_division_filter) && length(input$cloud_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.DIVISION %in% input$cloud_division_filter)
    }
    
    return(temp_data)
  })
  
  filtered_cloud_region <- reactive({
    req(cloud)
    
    temp_data <- cloud
    
    if (!is.null(input$cloud_region_filter) && length(input$cloud_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.REGION %in% input$cloud_region_filter)
    }
    
    if (!is.null(input$cloud_division_filter) && length(input$cloud_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.DIVISION %in% input$cloud_division_filter)
    }
    
    return(temp_data)
  })
  
  filtered_LMS_region <- reactive({
    req(LMS)
    
    temp_data <- LMS
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    return(temp_data)
  })
  
  filtered_LMS_division <- reactive({
    req(LMS)
    
    temp_data <- LMS
    
    if (!is.null(input$dashboard_region_filter) && length(input$dashboard_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Region %in% input$dashboard_region_filter)
    }
    
    if (!is.null(input$dashboard_division_filter) && length(input$dashboard_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(Division %in% input$dashboard_division_filter)
    }
    
    return(temp_data)
  })
  
  filtered_cloud_region_v2 <- reactive({
    req(cloud_v2)
    
    temp_data <- cloud_v2
    
    if (!is.null(input$cloud_region_filter) && length(input$cloud_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.REGION %in% input$cloud_region_filter)
    }
    
    if (!is.null(input$cloud_division_filter) && length(input$cloud_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.DIVISION %in% input$cloud_division_filter)
    }
    
    return(temp_data)
  })
  
  filtered_cloud_region_v3 <- reactive({
    req(cloud_v3)
    
    temp_data <- cloud_v3
    
    if (!is.null(input$cloud_region_filter) && length(input$cloud_region_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.REGION %in% input$cloud_region_filter)
    }
    
    if (!is.null(input$cloud_division_filter) && length(input$cloud_division_filter) > 0) {
      temp_data <- temp_data %>%
        filter(BASIC.DIVISION %in% input$cloud_division_filter)
    }
    
    return(temp_data)
  })
  
  # Add a mechanism to reset the table when global filters change (optional but recommended)
  # This will make the table revert to globally filtered data if user changes region/division
  # after clicking on a chart.
  observeEvent(list(input$selected_region, input$selected_division), {
    rv$chart_clicked <- FALSE # Reset the click state
    print("Global filters changed, resetting chart_clicked state.") # DEBUG
  })
  
  # For Classroom_Shortage_Division_Graph
  observeEvent(plotly::event_data("plotly_click", source = "classroomShortage_division"), {
    click_data <- plotly::event_data("plotly_click", source = "classroomShortage_division")
    if (!is.null(click_data)) {
      rv$latest_classroom_click_key <- click_data$x
      rv$latest_classroom_click_type <- "classroom_division"
      print(paste("DEBUG: Classroom Division Clicked:", rv$latest_classroom_click_key))
      print(paste("DEBUG: Classroom Click Type:", rv$latest_classroom_click_type))
    }
  })
  
  # For Classroom_Shortage_District_Graph
  observeEvent(plotly::event_data("plotly_click", source = "classroomShortage_district"), {
    click_data <- plotly::event_data("plotly_click", source = "classroomShortage_district")
    if (!is.null(click_data)) {
      rv$latest_classroom_click_key <- click_data$x
      rv$latest_classroom_click_type <- "classroom_district"
      print(paste("DEBUG: Classroom District Clicked:", rv$latest_classroom_click_key))
      print(paste("DEBUG: Classroom Click Type:", rv$latest_classroom_click_type))
    }
  })
  
  # Assuming 'rv' is a reactiveValues object initialized in your server.R,
  # for example:
  # rv <- reactiveValues(
  #   latest_classroom_click_key = NULL,
  #   latest_classroom_click_type = NULL
  # )
  
  # Assuming Classroom_Shortage_All_List is a data frame available in your server.R
  # Example dummy data for demonstration:
  # Classroom_Shortage_All_List <- data.frame(
  #   Division = c("Division A", "Division B", "Division A", "Division C", "Division B"),
  #   Legislative.District = c("District 1", "District 2", "District 1", "District 3", "District 1"),
  #   Shortage = c(10, 5, 12, 8, 3),
  #   Other_Column = c("X", "Y", "Z", "A", "B")
  # )
  
  # Assuming 'filtered_school_data_division' is a reactive expression defined elsewhere in your server.R,
  # for example:
  # filtered_school_data_division <- reactive({
  #   # Your filtering logic here, e.g.,
  #   # if (!is.null(rv$some_filter_key)) {
  #   #   Classroom_Shortage_All_List[Classroom_Shortage_All_List$Division == rv$some_filter_key, ]
  #   # } else {
  #   #   Classroom_Shortage_All_List
  #   # }
  # })
  
  output$Classroom_Shortage_All_List  <- DT::renderDT({
    # Ensure that filtered_school_data_division() returns a data frame
    # and handle cases where it might be NULL or empty initially.
    data_to_display <- filtered_school_data_division() %>% select(Region, Division, Legislative.District, SchoolID, School.Name, Est.CS) %>% rename("Estimated Classroom Shortage" = Est.CS)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display, # Use the output of your reactive expression
      options = list(
        pageLength = 10, # Number of rows to display per page
        lengthMenu = c(5, 10, 15, 20), # Options for number of rows per page
        searching = TRUE, # Enable search box
        filter = "top",
        paging = TRUE, # Enable pagination
        info = TRUE, # Display table information (e.g., "Showing 1 to 10 of 50 entries")
        ordering = TRUE # Enable column sorting
      ),
      rownames = FALSE # Do not display row names
    )
  })
  
  output$enrolment_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION,ENROLLMENT.G1,ENROLLMENT.G2,ENROLLMENT.G3,ENROLLMENT.G4,ENROLLMENT.G5,ENROLLMENT.G6,ENROLLMENT.G7,ENROLLMENT.G8,ENROLLMENT.G9,ENROLLMENT.G10,ENROLMENT.G11,ENROLMENT.G12) %>%
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>% 
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      rename("REGION" = BASIC.REGION,
             "DIVISION" = BASIC.DIVISION,
             "GRADE 1" = ENROLLMENT.G1,
             "GRADE 2" = ENROLLMENT.G2,
             "GRADE 3" = ENROLLMENT.G3,
             "GRADE 4" = ENROLLMENT.G4,
             "GRADE 5" = ENROLLMENT.G5,
             "GRADE 6" = ENROLLMENT.G6,
             "GRADE 7" = ENROLLMENT.G7,
             "GRADE 8" = ENROLLMENT.G8,
             "GRADE 9" = ENROLLMENT.G9,
             "GRADE 10" = ENROLLMENT.G10,
             "GRADE 11" = ENROLMENT.G11,
             "GRADE 12" = ENROLMENT.G12)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$enrolment_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION,ENROLLMENT.G1,ENROLLMENT.G2,ENROLLMENT.G3,ENROLLMENT.G4,ENROLLMENT.G5,ENROLLMENT.G6,ENROLLMENT.G7,ENROLLMENT.G8,ENROLLMENT.G9,ENROLLMENT.G10,ENROLMENT.G11,ENROLMENT.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      rename("REGION" = BASIC.REGION,
             "GRADE 1" = ENROLLMENT.G1,
             "GRADE 2" = ENROLLMENT.G2,
             "GRADE 3" = ENROLLMENT.G3,
             "GRADE 4" = ENROLLMENT.G4,
             "GRADE 5" = ENROLLMENT.G5,
             "GRADE 6" = ENROLLMENT.G6,
             "GRADE 7" = ENROLLMENT.G7,
             "GRADE 8" = ENROLLMENT.G8,
             "GRADE 9" = ENROLLMENT.G9,
             "GRADE 10" = ENROLLMENT.G10,
             "GRADE 11" = ENROLMENT.G11,
             "GRADE 12" = ENROLMENT.G12) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Enrolment", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(Enrolment = factor(Enrolment, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Enrolment, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Enrolment,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$enrolment_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION,ENROLLMENT.G1,ENROLLMENT.G2,ENROLLMENT.G3,ENROLLMENT.G4,ENROLLMENT.G5,ENROLLMENT.G6,ENROLLMENT.G7,ENROLLMENT.G8,ENROLLMENT.G9,ENROLLMENT.G10,ENROLMENT.G11,ENROLMENT.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      rename("DIVISION" = BASIC.DIVISION,
             "GRADE 1" = ENROLLMENT.G1,
             "GRADE 2" = ENROLLMENT.G2,
             "GRADE 3" = ENROLLMENT.G3,
             "GRADE 4" = ENROLLMENT.G4,
             "GRADE 5" = ENROLLMENT.G5,
             "GRADE 6" = ENROLLMENT.G6,
             "GRADE 7" = ENROLLMENT.G7,
             "GRADE 8" = ENROLLMENT.G8,
             "GRADE 9" = ENROLLMENT.G9,
             "GRADE 10" = ENROLLMENT.G10,
             "GRADE 11" = ENROLMENT.G11,
             "GRADE 12" = ENROLMENT.G12) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Enrolment", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(Enrolment = factor(Enrolment, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Enrolment, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Enrolment, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Division: ", DIVISION,
                                 "<br>Section: ", Enrolment,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sned_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, SPECIAL.NEEDS.G1, SPECIAL.NEEDS.G2, SPECIAL.NEEDS.G3, SPECIAL.NEEDS.G4, SPECIAL.NEEDS.G5, SPECIAL.NEEDS.G6, SPECIAL.NEEDS.G7, SPECIAL.NEEDS.G8, SPECIAL.NEEDS.G9, SPECIAL.NEEDS.G10) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      mutate(SPECIAL.NEEDS.G1 = as.integer(SPECIAL.NEEDS.G1),SPECIAL.NEEDS.G2 = as.integer(SPECIAL.NEEDS.G2)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = SPECIAL.NEEDS.G1,
        "GRADE 2" = SPECIAL.NEEDS.G2,
        "GRADE 3" = SPECIAL.NEEDS.G3,
        "GRADE 4" = SPECIAL.NEEDS.G4,
        "GRADE 5" = SPECIAL.NEEDS.G5,
        "GRADE 6" = SPECIAL.NEEDS.G6,
        "GRADE 7" = SPECIAL.NEEDS.G7,
        "GRADE 8" = SPECIAL.NEEDS.G8,
        "GRADE 9" = SPECIAL.NEEDS.G9,
        "GRADE 10" = SPECIAL.NEEDS.G10
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$sned_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, SPECIAL.NEEDS.G1, SPECIAL.NEEDS.G2, SPECIAL.NEEDS.G3, SPECIAL.NEEDS.G4, SPECIAL.NEEDS.G5, SPECIAL.NEEDS.G6, SPECIAL.NEEDS.G7, SPECIAL.NEEDS.G8, SPECIAL.NEEDS.G9, SPECIAL.NEEDS.G10) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "GRADE 1" = SPECIAL.NEEDS.G1,
        "GRADE 2" = SPECIAL.NEEDS.G2,
        "GRADE 3" = SPECIAL.NEEDS.G3,
        "GRADE 4" = SPECIAL.NEEDS.G4,
        "GRADE 5" = SPECIAL.NEEDS.G5,
        "GRADE 6" = SPECIAL.NEEDS.G6,
        "GRADE 7" = SPECIAL.NEEDS.G7,
        "GRADE 8" = SPECIAL.NEEDS.G8,
        "GRADE 9" = SPECIAL.NEEDS.G9,
        "GRADE 10" = SPECIAL.NEEDS.G10
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "SNED_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(SNED_Learners = factor(SNED_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10")))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = SNED_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", SNED_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sned_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, SPECIAL.NEEDS.G1, SPECIAL.NEEDS.G2, SPECIAL.NEEDS.G3, SPECIAL.NEEDS.G4, SPECIAL.NEEDS.G5, SPECIAL.NEEDS.G6, SPECIAL.NEEDS.G7, SPECIAL.NEEDS.G8, SPECIAL.NEEDS.G9, SPECIAL.NEEDS.G10) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = SPECIAL.NEEDS.G1,
        "GRADE 2" = SPECIAL.NEEDS.G2,
        "GRADE 3" = SPECIAL.NEEDS.G3,
        "GRADE 4" = SPECIAL.NEEDS.G4,
        "GRADE 5" = SPECIAL.NEEDS.G5,
        "GRADE 6" = SPECIAL.NEEDS.G6,
        "GRADE 7" = SPECIAL.NEEDS.G7,
        "GRADE 8" = SPECIAL.NEEDS.G8,
        "GRADE 9" = SPECIAL.NEEDS.G9,
        "GRADE 10" = SPECIAL.NEEDS.G10
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "SNED_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(SNED_Learners = factor(SNED_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10")))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = SNED_Learners, y = Count,
                    fill = SNED_Learners,
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", SNED_Learners,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "dodge", color = "black") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    
    
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ip_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, IP.G1.IP, IP.G2.IP, IP.G3.IP, IP.G4.IP, IP.G5.IP, IP.G6.IP, IP.G7.IP, IP.G8.IP, IP.G9.IP, IP.G10.IP, IP.G11, IP.G12) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = IP.G1.IP,
        "GRADE 2" = IP.G2.IP,
        "GRADE 3" = IP.G3.IP,
        "GRADE 4" = IP.G4.IP,
        "GRADE 5" = IP.G5.IP,
        "GRADE 6" = IP.G6.IP,
        "GRADE 7" = IP.G7.IP,
        "GRADE 8" = IP.G8.IP,
        "GRADE 9" = IP.G9.IP,
        "GRADE 10" = IP.G10.IP,
        "GRADE 11" = IP.G11,
        "GRADE 12" = IP.G12
      ) 
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$ip_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, IP.G1.IP, IP.G2.IP, IP.G3.IP, IP.G4.IP, IP.G5.IP, IP.G6.IP, IP.G7.IP, IP.G8.IP, IP.G9.IP, IP.G10.IP, IP.G11, IP.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "REGION" = BASIC.REGION,
        "GRADE 1" = IP.G1.IP,
        "GRADE 2" = IP.G2.IP,
        "GRADE 3" = IP.G3.IP,
        "GRADE 4" = IP.G4.IP,
        "GRADE 5" = IP.G5.IP,
        "GRADE 6" = IP.G6.IP,
        "GRADE 7" = IP.G7.IP,
        "GRADE 8" = IP.G8.IP,
        "GRADE 9" = IP.G9.IP,
        "GRADE 10" = IP.G10.IP,
        "GRADE 11" = IP.G11,
        "GRADE 12" = IP.G12
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "IP_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(IP_Learners = factor(IP_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = IP_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", IP_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ip_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, IP.G1.IP, IP.G2.IP, IP.G3.IP, IP.G4.IP, IP.G5.IP, IP.G6.IP, IP.G7.IP, IP.G8.IP, IP.G9.IP, IP.G10.IP, IP.G11, IP.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = IP.G1.IP,
        "GRADE 2" = IP.G2.IP,
        "GRADE 3" = IP.G3.IP,
        "GRADE 4" = IP.G4.IP,
        "GRADE 5" = IP.G5.IP,
        "GRADE 6" = IP.G6.IP,
        "GRADE 7" = IP.G7.IP,
        "GRADE 8" = IP.G8.IP,
        "GRADE 9" = IP.G9.IP,
        "GRADE 10" = IP.G10.IP,
        "GRADE 11" = IP.G11,
        "GRADE 12" = IP.G12
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "IP_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(IP_Learners = factor(IP_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = IP_Learners, y = Count,
                    fill = IP_Learners,
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", IP_Learners,
                                 "<br>Count: ", scales::comma(Count)))) +
      geom_bar(stat = "identity", position = "dodge", color = "black") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    
    
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$muslim_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, MUSLIM.G1.MUSLIM, MUSLIM.G2.MUSLIM, MUSLIM.G3.MUSLIM, MUSLIM.G4.MUSLIM, MUSLIM.G5.MUSLIM, MUSLIM.G6.MUSLIM, MUSLIM.G7.MUSLIM, MUSLIM.G8.MUSLIM, MUSLIM.G9.MUSLIM, MUSLIM.G10.MUSLIM, MUSLIM.G11, MUSLIM.G12) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = MUSLIM.G1.MUSLIM,
        "GRADE 2" = MUSLIM.G2.MUSLIM,
        "GRADE 3" = MUSLIM.G3.MUSLIM,
        "GRADE 4" = MUSLIM.G4.MUSLIM,
        "GRADE 5" = MUSLIM.G5.MUSLIM,
        "GRADE 6" = MUSLIM.G6.MUSLIM,
        "GRADE 7" = MUSLIM.G7.MUSLIM,
        "GRADE 8" = MUSLIM.G8.MUSLIM,
        "GRADE 9" = MUSLIM.G9.MUSLIM,
        "GRADE 10" = MUSLIM.G10.MUSLIM,
        "GRADE 11" = MUSLIM.G11,
        "GRADE 12" = MUSLIM.G12
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$muslim_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, MUSLIM.G1.MUSLIM, MUSLIM.G2.MUSLIM, MUSLIM.G3.MUSLIM, MUSLIM.G4.MUSLIM, MUSLIM.G5.MUSLIM, MUSLIM.G6.MUSLIM, MUSLIM.G7.MUSLIM, MUSLIM.G8.MUSLIM, MUSLIM.G9.MUSLIM, MUSLIM.G10.MUSLIM, MUSLIM.G11, MUSLIM.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "GRADE 1" = MUSLIM.G1.MUSLIM,
        "GRADE 2" = MUSLIM.G2.MUSLIM,
        "GRADE 3" = MUSLIM.G3.MUSLIM,
        "GRADE 4" = MUSLIM.G4.MUSLIM,
        "GRADE 5" = MUSLIM.G5.MUSLIM,
        "GRADE 6" = MUSLIM.G6.MUSLIM,
        "GRADE 7" = MUSLIM.G7.MUSLIM,
        "GRADE 8" = MUSLIM.G8.MUSLIM,
        "GRADE 9" = MUSLIM.G9.MUSLIM,
        "GRADE 10" = MUSLIM.G10.MUSLIM,
        "GRADE 11" = MUSLIM.G11,
        "GRADE 12" = MUSLIM.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Muslim_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Muslim_Learners = factor(Muslim_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Muslim_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Muslim_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$muslim_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, MUSLIM.G1.MUSLIM, MUSLIM.G2.MUSLIM, MUSLIM.G3.MUSLIM, MUSLIM.G4.MUSLIM, MUSLIM.G5.MUSLIM, MUSLIM.G6.MUSLIM, MUSLIM.G7.MUSLIM, MUSLIM.G8.MUSLIM, MUSLIM.G9.MUSLIM, MUSLIM.G10.MUSLIM, MUSLIM.G11, MUSLIM.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = MUSLIM.G1.MUSLIM,
        "GRADE 2" = MUSLIM.G2.MUSLIM,
        "GRADE 3" = MUSLIM.G3.MUSLIM,
        "GRADE 4" = MUSLIM.G4.MUSLIM,
        "GRADE 5" = MUSLIM.G5.MUSLIM,
        "GRADE 6" = MUSLIM.G6.MUSLIM,
        "GRADE 7" = MUSLIM.G7.MUSLIM,
        "GRADE 8" = MUSLIM.G8.MUSLIM,
        "GRADE 9" = MUSLIM.G9.MUSLIM,
        "GRADE 10" = MUSLIM.G10.MUSLIM,
        "GRADE 11" = MUSLIM.G11,
        "GRADE 12" = MUSLIM.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Muslim_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(Muslim_Learners = factor(Muslim_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Muslim_Learners, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Muslim_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Muslim_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$displaced_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, DISPLACED.GRADE1.DISPLACED.LEARNER, DISPLACED.GRADE2.DISPLACED.LEARNER, DISPLACED.GRADE3.DISPLACED.LEARNER, DISPLACED.GRADE4.DISPLACED.LEARNER, DISPLACED.GRADE5.DISPLACED.LEARNER, DISPLACED.GRADE6.DISPLACED.LEARNER,DISPLACED.G7.DISPLACED,DISPLACED.G8.DISPLACED,DISPLACED.G9.DISPLACED,DISPLACED.G10.DISPLACED,DISPLACED.G11,DISPLACED.G12) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = DISPLACED.GRADE1.DISPLACED.LEARNER,
        "GRADE 2" = DISPLACED.GRADE2.DISPLACED.LEARNER,
        "GRADE 3" = DISPLACED.GRADE3.DISPLACED.LEARNER,
        "GRADE 4" = DISPLACED.GRADE4.DISPLACED.LEARNER,
        "GRADE 5" = DISPLACED.GRADE5.DISPLACED.LEARNER,
        "GRADE 6" = DISPLACED.GRADE6.DISPLACED.LEARNER,
        "GRADE 7" = DISPLACED.G7.DISPLACED,
        "GRADE 8" = DISPLACED.G8.DISPLACED,
        "GRADE 9" = DISPLACED.G9.DISPLACED,
        "GRADE 10" = DISPLACED.G10.DISPLACED,
        "GRADE 11" = DISPLACED.G11,
        "GRADE 12" = DISPLACED.G12
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$displaced_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, DISPLACED.GRADE1.DISPLACED.LEARNER, DISPLACED.GRADE2.DISPLACED.LEARNER, DISPLACED.GRADE3.DISPLACED.LEARNER, DISPLACED.GRADE4.DISPLACED.LEARNER, DISPLACED.GRADE5.DISPLACED.LEARNER, DISPLACED.GRADE6.DISPLACED.LEARNER,DISPLACED.G7.DISPLACED,DISPLACED.G8.DISPLACED,DISPLACED.G9.DISPLACED,DISPLACED.G10.DISPLACED,DISPLACED.G11,DISPLACED.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "GRADE 1" = DISPLACED.GRADE1.DISPLACED.LEARNER,
        "GRADE 2" = DISPLACED.GRADE2.DISPLACED.LEARNER,
        "GRADE 3" = DISPLACED.GRADE3.DISPLACED.LEARNER,
        "GRADE 4" = DISPLACED.GRADE4.DISPLACED.LEARNER,
        "GRADE 5" = DISPLACED.GRADE5.DISPLACED.LEARNER,
        "GRADE 6" = DISPLACED.GRADE6.DISPLACED.LEARNER,
        "GRADE 7" = DISPLACED.G7.DISPLACED,
        "GRADE 8" = DISPLACED.G8.DISPLACED,
        "GRADE 9" = DISPLACED.G9.DISPLACED,
        "GRADE 10" = DISPLACED.G10.DISPLACED,
        "GRADE 11" = DISPLACED.G11,
        "GRADE 12" = DISPLACED.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Displaced_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Displaced_Learners = factor(Displaced_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Displaced_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Displaced_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "Region",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$displaced_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, DISPLACED.GRADE1.DISPLACED.LEARNER, DISPLACED.GRADE2.DISPLACED.LEARNER, DISPLACED.GRADE3.DISPLACED.LEARNER, DISPLACED.GRADE4.DISPLACED.LEARNER, DISPLACED.GRADE5.DISPLACED.LEARNER, DISPLACED.GRADE6.DISPLACED.LEARNER,DISPLACED.G7.DISPLACED,DISPLACED.G8.DISPLACED,DISPLACED.G9.DISPLACED,DISPLACED.G10.DISPLACED,DISPLACED.G11,DISPLACED.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "GRADE 1" = DISPLACED.GRADE1.DISPLACED.LEARNER,
        "GRADE 2" = DISPLACED.GRADE2.DISPLACED.LEARNER,
        "GRADE 3" = DISPLACED.GRADE3.DISPLACED.LEARNER,
        "GRADE 4" = DISPLACED.GRADE4.DISPLACED.LEARNER,
        "GRADE 5" = DISPLACED.GRADE5.DISPLACED.LEARNER,
        "GRADE 6" = DISPLACED.GRADE6.DISPLACED.LEARNER,
        "GRADE 7" = DISPLACED.G7.DISPLACED,
        "GRADE 8" = DISPLACED.G8.DISPLACED,
        "GRADE 9" = DISPLACED.G9.DISPLACED,
        "GRADE 10" = DISPLACED.G10.DISPLACED,
        "GRADE 11" = DISPLACED.G11,
        "GRADE 12" = DISPLACED.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Displaced_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Displaced_Learners = factor(Displaced_Learners, levels = c(
        "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Displaced_Learners, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Displaced_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Displaced_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$als_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("ENROLLEDALS.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "ES" = ENROLLEDALS.ELEM.ALS,
        "JHS" = ENROLLEDALS.JHS.ALS,
        "SHS" = ENROLLEDALS.SHS.ALS
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$als_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("ENROLLEDALS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = ENROLLEDALS.ELEM.ALS,
        "JHS" = ENROLLEDALS.JHS.ALS,
        "SHS" = ENROLLEDALS.SHS.ALS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "ALS_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = ALS_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", ALS_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$als_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("ENROLLEDALS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "ES" = ENROLLEDALS.ELEM.ALS,
        "JHS" = ENROLLEDALS.JHS.ALS,
        "SHS" = ENROLLEDALS.SHS.ALS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "ALS_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = ALS_Learners, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = ALS_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", ALS_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$dropout_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, DROPOUT.PREVSY) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "NUMBER OF DROPOUTS (PREVIOUS SY)" = DROPOUT.PREVSY)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$dropout_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, DROPOUT.PREVSY) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "NUMBER OF DROPOUTS (PREVIOUS SY)" = DROPOUT.PREVSY) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$dropout_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, DROPOUT.PREVSY) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "NUMBER OF DROPOUTS (PREVIOUS SY)" = DROPOUT.PREVSY)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sosss_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("SOSSS.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$sosss_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("SOSSS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sosss_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("SOSSS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$extension_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("EXTENSION.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$extension_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("EXTENSION.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$extension_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("EXTENSION.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$teacherinventory_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, TEACHING.PERSONNEL.ELEM, TEACHING.PERSONNEL.JHS, TEACHING.PERSONNEL.SHS) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "ES" = TEACHING.PERSONNEL.ELEM,
        "JHS" = TEACHING.PERSONNEL.JHS,
        "SHS" = TEACHING.PERSONNEL.SHS
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$teacherinventory_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, TEACHING.PERSONNEL.ELEM, TEACHING.PERSONNEL.JHS, TEACHING.PERSONNEL.SHS) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = TEACHING.PERSONNEL.ELEM,
        "JHS" = TEACHING.PERSONNEL.JHS,
        "SHS" = TEACHING.PERSONNEL.SHS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Teaching_Personnel", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Teaching_Personnel, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Number_of_Teaching_Personnel,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$teacherinventory_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, TEACHING.PERSONNEL.ELEM, TEACHING.PERSONNEL.JHS, TEACHING.PERSONNEL.SHS) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "ES" = TEACHING.PERSONNEL.ELEM,
        "JHS" = TEACHING.PERSONNEL.JHS,
        "SHS" = TEACHING.PERSONNEL.SHS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Teaching_Personnel", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Number_of_Teaching_Personnel, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Teaching_Personnel, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Number_of_Teaching_Personnel,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$classroom_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, NO.CLASSROOM.ELEM, NO.CLASSROOM.SNED.ELEM, NO.CLASSROOM.JHS, NO.CLASSROOM.SNED.JHS, NO.CLASSROOM.SHS) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "ES" = NO.CLASSROOM.ELEM,
        "JHS" = NO.CLASSROOM.JHS,
        "SHS" = NO.CLASSROOM.SHS,
        "SNED-ES" = NO.CLASSROOM.SNED.ELEM,
        "SNED-JHS" = NO.CLASSROOM.SNED.JHS)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$classroom_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, NO.CLASSROOM.ELEM, NO.CLASSROOM.SNED.ELEM, NO.CLASSROOM.JHS, NO.CLASSROOM.SNED.JHS, NO.CLASSROOM.SHS) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = NO.CLASSROOM.ELEM,
        "JHS" = NO.CLASSROOM.JHS,
        "SHS" = NO.CLASSROOM.SHS,
        "SNED-ES" = NO.CLASSROOM.SNED.ELEM,
        "SNED-JHS" = NO.CLASSROOM.SNED.JHS)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Classrooms", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Classrooms, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Number_of_Classrooms,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5))
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$classroom_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("NO.CLASSROOM.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "ES" = NO.CLASSROOM.ELEM,
        "JHS" = NO.CLASSROOM.JHS,
        "SHS" = NO.CLASSROOM.SHS,
        "SNED-ES" = NO.CLASSROOM.SNED.ELEM,
        "SNED-JHS" = NO.CLASSROOM.SNED.JHS)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Classrooms", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Number_of_Classrooms, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Classrooms, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Number_of_Classrooms,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$multigrade_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("MG.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "G1 & G2" = MG.CLASSES.1.2,
        "G3 & G4" = MG.CLASSES.3.4,
        "G5 & G6" = MG.CLASSES.5.6
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$multigrade_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("MG.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "G1 & G2" = MG.CLASSES.1.2,
        "G3 & G4" = MG.CLASSES.3.4,
        "G5 & G6" = MG.CLASSES.5.6
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Multigrade", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Multigrade, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Multigrade,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$multigrade_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("MG.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "G1 & G2" = MG.CLASSES.1.2,
        "G3 & G4" = MG.CLASSES.3.4,
        "G5 & G6" = MG.CLASSES.5.6
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Multigrade", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Multigrade, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Multigrade, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Multigrade,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) +
      coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL) # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$organizedclass_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, CLASS.ORG.BELOW, CLASS.ORG.ABOVE, CLASS.ORG.WITHIN) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "BELOW THE STANDARD" = CLASS.ORG.BELOW,
        "ABOVE THE STANDARD" = CLASS.ORG.ABOVE,
        "WITHIN THE STANDARD" = CLASS.ORG.WITHIN
      )
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$organizedclass_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, CLASS.ORG.BELOW, CLASS.ORG.ABOVE, CLASS.ORG.WITHIN) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "BELOW THE STANDARD" = CLASS.ORG.BELOW,
        "ABOVE THE STANDARD" = CLASS.ORG.ABOVE,
        "WITHIN THE STANDARD" = CLASS.ORG.WITHIN
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Classes_Organized", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      # This is the key change: Convert 'Classes_Organized' to a factor with specific levels
      mutate(Classes_Organized = factor(Classes_Organized, levels = c(
        "BELOW THE STANDARD",
        "WITHIN THE STANDARD",
        "ABOVE THE STANDARD"
      )))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Classes_Organized, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Classes_Organized,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      scale_fill_manual(values = c(
        "BELOW THE STANDARD" = "blue",
        "WITHIN THE STANDARD" = "green", # Optional: you can set a color for this too
        "ABOVE THE STANDARD" = "red"
      )) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$organizedclass_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, CLASS.ORG.BELOW, CLASS.ORG.ABOVE, CLASS.ORG.WITHIN) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "BELOW THE STANDARD" = CLASS.ORG.BELOW,
        "ABOVE THE STANDARD" = CLASS.ORG.ABOVE,
        "WITHIN THE STANDARD" = CLASS.ORG.WITHIN
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Classes_Organized", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      # This is the key change: Convert 'Classes_Organized' to a factor with specific levels
      mutate(Classes_Organized = factor(Classes_Organized, levels = c(
        "BELOW THE STANDARD",
        "WITHIN THE STANDARD",
        "ABOVE THE STANDARD"
      )))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Classes_Organized, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Classes_Organized, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Classes_Organized,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      scale_fill_manual(values = c(
        "BELOW THE STANDARD" = "blue",
        "WITHIN THE STANDARD" = "green", # Optional: you can set a color for this too
        "ABOVE THE STANDARD" = "red"
      )) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$jhsdeployment_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION,Actual.Teacher.AFA,Actual.Teacher.FCS,Actual.Teacher.IA,Actual.Teacher.ICT) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "AFA" = Actual.Teacher.AFA,
        "FCS" = Actual.Teacher.FCS,
        "IA" = Actual.Teacher.IA,
        "ICT" = Actual.Teacher.ICT)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$jhsdeployment_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION,Actual.Teacher.AFA,Actual.Teacher.FCS,Actual.Teacher.IA,Actual.Teacher.ICT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "AFA" = Actual.Teacher.AFA,
        "FCS" = Actual.Teacher.FCS,
        "IA" = Actual.Teacher.IA,
        "ICT" = Actual.Teacher.ICT) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Actual_JHS_Teachers_Deployed", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Actual_JHS_Teachers_Deployed, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Actual_JHS_Teachers_Deployed,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$jhsdeployment_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION,Actual.Teacher.AFA,Actual.Teacher.FCS,Actual.Teacher.IA,Actual.Teacher.ICT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "AFA" = Actual.Teacher.AFA,
        "FCS" = Actual.Teacher.FCS,
        "IA" = Actual.Teacher.IA,
        "ICT" = Actual.Teacher.ICT)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Actual_JHS_Teachers_Deployed", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Actual_JHS_Teachers_Deployed, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Actual_JHS_Teachers_Deployed, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Actual_JHS_Teachers_Deployed,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$lac_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("LAC.OFTEN")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$shifting_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("SHIFTING.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$shifting_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION, contains("SHIFTING.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$shifting_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION, contains("SHIFTING.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL) # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ldm_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("LDM.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$ldm_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION, contains("LDM.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ldm_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION, contains("LDM.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$adm_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$nat_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_sufficiency_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION,COMPRE_YES_NAT,YES_NAT,NOT_ADEQ_NAT,NO_NAT) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$nat_sufficiency_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION, COMPRE_YES_NAT,YES_NAT,NOT_ADEQ_NAT,NO_NAT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_sufficiency_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION,COMPRE_YES_NAT,YES_NAT,NOT_ADEQ_NAT,NO_NAT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$elec_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION,GRID_ELEC,OFFGRID_ELEC,COMBINED_ELEC,NO_ELEC_) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$elec_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION,GRID_ELEC,OFFGRID_ELEC,COMBINED_ELEC,NO_ELEC_) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$elec_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION,GRID_ELEC,OFFGRID_ELEC,COMBINED_ELEC,NO_ELEC_) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$internet_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION,Broadband_MOOE,WiFi_Plan_MOOE,Mobile_Data,No_Internet_Available) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$internet_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION,Broadband_MOOE,WiFi_Plan_MOOE,Mobile_Data,No_Internet_Available) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$internet_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION,Broadband_MOOE,WiFi_Plan_MOOE,Mobile_Data,No_Internet_Available) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$internet_usage_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION,Combination_Internet,Instructional_Internet,Administrative_Internet,None_Internet) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$internet_usage_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION,Combination_Internet,Instructional_Internet,Administrative_Internet,None_Internet) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$internet_usage_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION,Combination_Internet,Instructional_Internet,Administrative_Internet,None_Internet) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$water_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.REGION,BASIC.DIVISION,GROUNDWATER_WATER,BOTTLED_WATER,MWSS_WATER,WELL_WATER,LOCAL_WATER,SURFACE_WATER,PIPEDL3_WATER) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$water_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>%
      select(BASIC.REGION,GROUNDWATER_WATER,BOTTLED_WATER,MWSS_WATER,WELL_WATER,LOCAL_WATER,SURFACE_WATER,PIPEDL3_WATER) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$water_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v3() %>%
      select(BASIC.DIVISION,GROUNDWATER_WATER,BOTTLED_WATER,MWSS_WATER,WELL_WATER,LOCAL_WATER,SURFACE_WATER,PIPEDL3_WATER) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$adm_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$nat_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$adm_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$rf_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("QUALI.READING.PROFICIENCY.CHANGE")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$rf_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("QUALI.READING.PROFICIENCY.CHANGE")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$rf_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("QUALI.READING.PROFICIENCY.CHANGE")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$nat_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$aral_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION,ARAL.MATH,ARAL.READING,ARAL.SCIENCE) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "PROSPECTIVE ARAL LEARNERS (MATH)" = ARAL.MATH,
        "PROSPECTIVE ARAL LEARNERS (READING)" = ARAL.READING,
        "PROSPECTIVE ARAL LEARNERS (SCIENCE)" = ARAL.SCIENCE)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$aral_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION,ARAL.MATH,ARAL.READING,ARAL.SCIENCE) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "PROSPECTIVE ARAL LEARNERS (MATH)" = ARAL.MATH,
        "PROSPECTIVE ARAL LEARNERS (READING)" = ARAL.READING,
        "PROSPECTIVE ARAL LEARNERS (SCIENCE)" = ARAL.SCIENCE)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$aral_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION,ARAL.MATH,ARAL.READING,ARAL.SCIENCE) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "PROSPECTIVE ARAL LEARNERS (MATH)" = ARAL.MATH,
        "PROSPECTIVE ARAL LEARNERS (READING)" = ARAL.READING,
        "PROSPECTIVE ARAL LEARNERS (SCIENCE)" = ARAL.SCIENCE)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$bully_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION,MENTAL.BULLYING.COUNT,MENTAL.CHILDREN.RIGHT.ORIENTATION) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "INCIDENCE OF BULLYING" = MENTAL.BULLYING.COUNT,
        "ATTENDANCE OF CHILDRENS' RIGHTS ORIENTATION" = MENTAL.CHILDREN.RIGHT.ORIENTATION)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$bully_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION,MENTAL.BULLYING.COUNT,MENTAL.CHILDREN.RIGHT.ORIENTATION) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "INCIDENCE OF BULLYING" = MENTAL.BULLYING.COUNT,
        "ATTENDANCE OF CHILDRENS' RIGHTS ORIENTATION" = MENTAL.CHILDREN.RIGHT.ORIENTATION)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$bully_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION,MENTAL.BULLYING.COUNT,MENTAL.CHILDREN.RIGHT.ORIENTATION) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "INCIDENCE OF BULLYING" = MENTAL.BULLYING.COUNT,
        "ATTENDANCE OF CHILDRENS' RIGHTS ORIENTATION" = MENTAL.CHILDREN.RIGHT.ORIENTATION)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$crla_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, CRLA.DEVELOPING, CRLA.LOW, CRLA.TRANSITIONAL, CRLA.HIGH, CRLA.GRADELEVEL) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "LOW" = CRLA.LOW,
        "DEVELOPING" = CRLA.DEVELOPING,
        "TRANSITIONAL" = CRLA.TRANSITIONAL,
        "HIGH" = CRLA.HIGH,
        "GRADE LEVEL" = CRLA.GRADELEVEL)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$crla_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, CRLA.DEVELOPING, CRLA.LOW, CRLA.TRANSITIONAL, CRLA.HIGH, CRLA.GRADELEVEL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "LOW" = CRLA.LOW,
        "DEVELOPING" = CRLA.DEVELOPING,
        "TRANSITIONAL" = CRLA.TRANSITIONAL,
        "HIGH" = CRLA.HIGH,
        "GRADE LEVEL" = CRLA.GRADELEVEL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$crla_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, CRLA.DEVELOPING, CRLA.LOW, CRLA.TRANSITIONAL, CRLA.HIGH, CRLA.GRADELEVEL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "LOW" = CRLA.LOW,
        "DEVELOPING" = CRLA.DEVELOPING,
        "TRANSITIONAL" = CRLA.TRANSITIONAL,
        "HIGH" = CRLA.HIGH,
        "GRADE LEVEL" = CRLA.GRADELEVEL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$philiri_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, PHILIRI.FRUSTRATION, PHILIRI.TRANSITIONAL, PHILIRI.INSTRUCTIONAL) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "FRUSTRATION" = PHILIRI.FRUSTRATION,
        "TRANSITIONAL" = PHILIRI.TRANSITIONAL,
        "INSTRUCTIONAL" = PHILIRI.INSTRUCTIONAL)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$philiri_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, PHILIRI.FRUSTRATION, PHILIRI.TRANSITIONAL, PHILIRI.INSTRUCTIONAL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "FRUSTRATION" = PHILIRI.FRUSTRATION,
        "TRANSITIONAL" = PHILIRI.TRANSITIONAL,
        "INSTRUCTIONAL" = PHILIRI.INSTRUCTIONAL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$philiri_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, PHILIRI.FRUSTRATION, PHILIRI.TRANSITIONAL, PHILIRI.INSTRUCTIONAL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "FRUSTRATION" = PHILIRI.FRUSTRATION,
        "TRANSITIONAL" = PHILIRI.TRANSITIONAL,
        "INSTRUCTIONAL" = PHILIRI.INSTRUCTIONAL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$sha_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("SHA.CATEGORY")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$sha_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("SHA.CATEGORY")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sha_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("SHA.CATEGORY")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL) # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$feeding_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("SBFP.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$feeding_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$feeding_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$years_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("SERVICE.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$years_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("SERVICE.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$years_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("SERVICE.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL) # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$lac_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("LAC.")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$feeding_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$feeding_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$feeding_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$feeding_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$resources_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.REGION, BASIC.DIVISION, contains("RESOURCES.")) %>%
      mutate(across(3:last_col(), as.numeric)) %>%
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>%
      group_by(BASIC.REGION, BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      mutate(RESOURCES.MATH = round((`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` / (`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` + `RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_No`)) * 100, 2)) %>%
      mutate(RESOURCES.HANDWASHING = round((`RESOURCES.REGULAR.HANDWASHING_Yes` / (`RESOURCES.REGULAR.HANDWASHING_Yes` + `RESOURCES.REGULAR.HANDWASHING_No`)) * 100, 2)) %>%
      mutate(RESOURCES.SOAP = round((`RESOURCES.REGULAR.SOAP_Yes` / (`RESOURCES.REGULAR.SOAP_Yes` + `RESOURCES.REGULAR.SOAP_No`)) * 100, 2)) %>%
      mutate(RESOURCES.TVL = round((`RESOURCES.SCHOOL.WITH.TVL_Yes` / (`RESOURCES.SCHOOL.WITH.TVL_Yes` + `RESOURCES.SCHOOL.WITH.TVL_None`)) * 100, 2)) %>% 
      select(1:2,"RESOURCES.MATH","RESOURCES.HANDWASHING","RESOURCES.SOAP","RESOURCES.TVL")
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$resources_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>%
      select(BASIC.REGION, contains("RESOURCES.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      mutate(RESOURCES.MATH = round((`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` / (`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` + `RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_No`)) * 100, 2)) %>%
      mutate(RESOURCES.HANDWASHING = round((`RESOURCES.REGULAR.HANDWASHING_Yes` / (`RESOURCES.REGULAR.HANDWASHING_Yes` + `RESOURCES.REGULAR.HANDWASHING_No`)) * 100, 2)) %>%
      mutate(RESOURCES.SOAP = round((`RESOURCES.REGULAR.SOAP_Yes` / (`RESOURCES.REGULAR.SOAP_Yes` + `RESOURCES.REGULAR.SOAP_No`)) * 100, 2)) %>%
      mutate(RESOURCES.TVL = round((`RESOURCES.SCHOOL.WITH.TVL_Yes` / (`RESOURCES.SCHOOL.WITH.TVL_Yes` + `RESOURCES.SCHOOL.WITH.TVL_None`)) * 100, 2)) %>%
      # mutate(RESOURCES.CHAIR = round((`RESOURCES.CHAIR.FUNCTIONAL` / `RESOURCES.CHAIR.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.DESK = round((`RESOURCES.DESK.FUNCTIONAL` / `RESOURCES.DESK.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.ECART = round((`RESOURCES.ECART.FUNCTIONAL` / `RESOURCES.ECART.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.LAPTOP = round((`RESOURCES.LAPTOP.FUNCTIONAL` / `RESOURCES.LAPTOP.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.TOILET = round((`RESOURCES.FUNCTIONAL.TOILET` / `RESOURCES.NON.FUNCTIONAL.TOILET`) * 100, 2)) %>%
      # mutate(RESOURCES.TV = round((`RESOURCES.TV.FUNCTIONAL` / `RESOURCES.TV.INVENTORY`) * 100, 2))  
      select(1,"RESOURCES.MATH","RESOURCES.HANDWASHING","RESOURCES.SOAP","RESOURCES.TVL") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), mean, na.rm = TRUE)) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$resources_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region_v2() %>%
      select(BASIC.DIVISION, contains("RESOURCES.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      mutate(RESOURCES.MATH = round((`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` / (`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` + `RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_No`)) * 100, 2)) %>%
      mutate(RESOURCES.HANDWASHING = round((`RESOURCES.REGULAR.HANDWASHING_Yes` / (`RESOURCES.REGULAR.HANDWASHING_Yes` + `RESOURCES.REGULAR.HANDWASHING_No`)) * 100, 2)) %>%
      mutate(RESOURCES.SOAP = round((`RESOURCES.REGULAR.SOAP_Yes` / (`RESOURCES.REGULAR.SOAP_Yes` + `RESOURCES.REGULAR.SOAP_No`)) * 100, 2)) %>%
      mutate(RESOURCES.TVL = round((`RESOURCES.SCHOOL.WITH.TVL_Yes` / (`RESOURCES.SCHOOL.WITH.TVL_Yes` + `RESOURCES.SCHOOL.WITH.TVL_None`)) * 100, 2)) %>%
      # mutate(RESOURCES.CHAIR = round((`RESOURCES.CHAIR.FUNCTIONAL` / `RESOURCES.CHAIR.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.DESK = round((`RESOURCES.DESK.FUNCTIONAL` / `RESOURCES.DESK.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.ECART = round((`RESOURCES.ECART.FUNCTIONAL` / `RESOURCES.ECART.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.LAPTOP = round((`RESOURCES.LAPTOP.FUNCTIONAL` / `RESOURCES.LAPTOP.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.TOILET = round((`RESOURCES.FUNCTIONAL.TOILET` / `RESOURCES.NON.FUNCTIONAL.TOILET`) * 100, 2)) %>%
      # mutate(RESOURCES.TV = round((`RESOURCES.TV.FUNCTIONAL` / `RESOURCES.TV.INVENTORY`) * 100, 2))  
      select(1,"RESOURCES.MATH","RESOURCES.HANDWASHING","RESOURCES.SOAP","RESOURCES.TVL") %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~BASIC.DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)# Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$overload_data_table <- DT::renderDT({
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.REGION,BASIC.DIVISION, contains("DO5.OVERLOAD")) %>% 
      mutate(across(3:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.REGION,BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "DIVISION" = BASIC.DIVISION,
        "OVERLOAD PAY RECIPIENTS" = DO5.OVERLOAD.PAY.RECIPIENT)
    
    # You might want to add a check for NULL or empty data if filtered_school_data_division()
    # could return such states and you want to display a message or an empty table.
    if (is.null(data_to_display) || nrow(data_to_display) == 0) {
      return(DT::datatable(
        data.frame("Message" = "No data available based on current selection."),
        options = list(dom = 't'), # 't' hides all controls, showing only the table body
        rownames = FALSE
      ))
    }
    
    DT::datatable(
      data_to_display,
      options = list(pageLength = 10, scrollX = TRUE),
      filter = 'top',
      selection = 'multiple',
      rownames = FALSE
    )
  })
  
  output$overload_regional_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>%
      select(BASIC.REGION, contains("DO5.OVERLOAD")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "OVERLOAD PAY RECIPIENTS" = DO5.OVERLOAD.PAY.RECIPIENT)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$overload_division_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- filtered_cloud_region() %>%
      select(BASIC.DIVISION, contains("DO5.OVERLOAD")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.DIVISION = as.character(BASIC.DIVISION)) %>%
      filter(BASIC.DIVISION != "") %>% 
      group_by(BASIC.DIVISION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "DIVISION" = BASIC.DIVISION,
        "OVERLOAD PAY RECIPIENTS" = DO5.OVERLOAD.PAY.RECIPIENT) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = Sections, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", DIVISION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for stacked bars
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) +
      facet_wrap(~DIVISION) + coord_flip()+
      labs(x = NULL, y = NULL, fill = NULL)
    # Center the plot title # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentDivisionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  ### CLOUD Regional Profile ###
  
  output$enrolment_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,ENROLLMENT.KINDER,ENROLLMENT.G1,ENROLLMENT.G2,ENROLLMENT.G3,ENROLLMENT.G4,ENROLLMENT.G5,ENROLLMENT.G6,ENROLLMENT.G7,ENROLLMENT.G8,ENROLLMENT.G9,ENROLLMENT.G10,ENROLMENT.G11,ENROLMENT.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      rename("REGION" = BASIC.REGION,
             "KINDER" = ENROLLMENT.KINDER,
             "GRADE 1" = ENROLLMENT.G1,
             "GRADE 2" = ENROLLMENT.G2,
             "GRADE 3" = ENROLLMENT.G3,
             "GRADE 4" = ENROLLMENT.G4,
             "GRADE 5" = ENROLLMENT.G5,
             "GRADE 6" = ENROLLMENT.G6,
             "GRADE 7" = ENROLLMENT.G7,
             "GRADE 8" = ENROLLMENT.G8,
             "GRADE 9" = ENROLLMENT.G9,
             "GRADE 10" = ENROLLMENT.G10,
             "GRADE 11" = ENROLMENT.G11,
             "GRADE 12" = ENROLMENT.G12) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Enrolment", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(Enrolment = factor(Enrolment, levels = c(
        "KINDER", "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Enrolment, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Enrolment,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sned_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, ENROLMENT.KINDER.SNED, SPECIAL.NEEDS.G1, SPECIAL.NEEDS.G2, SPECIAL.NEEDS.G3, SPECIAL.NEEDS.G4, SPECIAL.NEEDS.G5, SPECIAL.NEEDS.G6, SPECIAL.NEEDS.G7, SPECIAL.NEEDS.G8, SPECIAL.NEEDS.G9, SPECIAL.NEEDS.G10) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "KINDER" = ENROLMENT.KINDER.SNED,
        "GRADE 1" = SPECIAL.NEEDS.G1,
        "GRADE 2" = SPECIAL.NEEDS.G2,
        "GRADE 3" = SPECIAL.NEEDS.G3,
        "GRADE 4" = SPECIAL.NEEDS.G4,
        "GRADE 5" = SPECIAL.NEEDS.G5,
        "GRADE 6" = SPECIAL.NEEDS.G6,
        "GRADE 7" = SPECIAL.NEEDS.G7,
        "GRADE 8" = SPECIAL.NEEDS.G8,
        "GRADE 9" = SPECIAL.NEEDS.G9,
        "GRADE 10" = SPECIAL.NEEDS.G10
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "SNED_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      mutate(SNED_Learners = factor(SNED_Learners, levels = c(
        "KINDER", "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10")))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = SNED_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", SNED_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ip_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, IP.KINDER.IP, IP.G1.IP, IP.G2.IP, IP.G3.IP, IP.G4.IP, IP.G5.IP, IP.G6.IP, IP.G7.IP, IP.G8.IP, IP.G9.IP, IP.G10.IP, IP.G11, IP.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "REGION" = BASIC.REGION,
        "KINDER" = IP.KINDER.IP,
        "GRADE 1" = IP.G1.IP,
        "GRADE 2" = IP.G2.IP,
        "GRADE 3" = IP.G3.IP,
        "GRADE 4" = IP.G4.IP,
        "GRADE 5" = IP.G5.IP,
        "GRADE 6" = IP.G6.IP,
        "GRADE 7" = IP.G7.IP,
        "GRADE 8" = IP.G8.IP,
        "GRADE 9" = IP.G9.IP,
        "GRADE 10" = IP.G10.IP,
        "GRADE 11" = IP.G11,
        "GRADE 12" = IP.G12
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "IP_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(IP_Learners = factor(IP_Learners, levels = c(
        "KINDER", "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = IP_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", IP_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$muslim_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, MUSLIM.KINDER.MUSLIM, MUSLIM.G1.MUSLIM, MUSLIM.G2.MUSLIM, MUSLIM.G3.MUSLIM, MUSLIM.G4.MUSLIM, MUSLIM.G5.MUSLIM, MUSLIM.G6.MUSLIM, MUSLIM.G7.MUSLIM, MUSLIM.G8.MUSLIM, MUSLIM.G9.MUSLIM, MUSLIM.G10.MUSLIM, MUSLIM.G11, MUSLIM.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        'KINDER' = MUSLIM.KINDER.MUSLIM,
        "GRADE 1" = MUSLIM.G1.MUSLIM,
        "GRADE 2" = MUSLIM.G2.MUSLIM,
        "GRADE 3" = MUSLIM.G3.MUSLIM,
        "GRADE 4" = MUSLIM.G4.MUSLIM,
        "GRADE 5" = MUSLIM.G5.MUSLIM,
        "GRADE 6" = MUSLIM.G6.MUSLIM,
        "GRADE 7" = MUSLIM.G7.MUSLIM,
        "GRADE 8" = MUSLIM.G8.MUSLIM,
        "GRADE 9" = MUSLIM.G9.MUSLIM,
        "GRADE 10" = MUSLIM.G10.MUSLIM,
        "GRADE 11" = MUSLIM.G11,
        "GRADE 12" = MUSLIM.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Muslim_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Muslim_Learners = factor(Muslim_Learners, levels = c(
        "KINDER", "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Muslim_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Muslim_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="stack" for stacked bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$totalenrolment_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    t1 <- cloud  %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%  
      select(BASIC.REGION,ENROLLMENT.KINDER,ENROLLMENT.G1,ENROLLMENT.G2,ENROLLMENT.G3,ENROLLMENT.G4,ENROLLMENT.G5,ENROLLMENT.G6,ENROLLMENT.G7,ENROLLMENT.G8,ENROLLMENT.G9,ENROLLMENT.G10,ENROLMENT.G11,ENROLMENT.G12) %>% mutate(Total.Enrollment = rowSums(select(., 2:ncol(.)))) %>% select(BASIC.REGION,Total.Enrollment)
    
    t2 <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, ENROLMENT.KINDER.SNED, SPECIAL.NEEDS.G1, SPECIAL.NEEDS.G2, SPECIAL.NEEDS.G3, SPECIAL.NEEDS.G4, SPECIAL.NEEDS.G5, SPECIAL.NEEDS.G6, SPECIAL.NEEDS.G7, SPECIAL.NEEDS.G8, SPECIAL.NEEDS.G9, SPECIAL.NEEDS.G10) %>% mutate(Total.SNED = rowSums(select(., 2:ncol(.)))) %>% select(Total.SNED)
    
    t3 <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, IP.KINDER.IP, IP.G1.IP, IP.G2.IP, IP.G3.IP, IP.G4.IP, IP.G5.IP, IP.G6.IP, IP.G7.IP, IP.G8.IP, IP.G9.IP, IP.G10.IP, IP.G11, IP.G12) %>% mutate(Total.IP = rowSums(select(., 2:ncol(.)))) %>% select(Total.IP)
    
    t4 <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, MUSLIM.KINDER.MUSLIM, MUSLIM.G1.MUSLIM, MUSLIM.G2.MUSLIM, MUSLIM.G3.MUSLIM, MUSLIM.G4.MUSLIM, MUSLIM.G5.MUSLIM, MUSLIM.G6.MUSLIM, MUSLIM.G7.MUSLIM, MUSLIM.G8.MUSLIM, MUSLIM.G9.MUSLIM, MUSLIM.G10.MUSLIM, MUSLIM.G11, MUSLIM.G12) %>% mutate(Total.Muslim = rowSums(select(., 2:ncol(.)))) %>% select(Total.Muslim)
    
    t5 <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, DISPLACED.KINDERGARTEN.DISPLACED.LEARNER, DISPLACED.GRADE1.DISPLACED.LEARNER, DISPLACED.GRADE2.DISPLACED.LEARNER, DISPLACED.GRADE3.DISPLACED.LEARNER, DISPLACED.GRADE4.DISPLACED.LEARNER, DISPLACED.GRADE5.DISPLACED.LEARNER, DISPLACED.GRADE6.DISPLACED.LEARNER,DISPLACED.G7.DISPLACED,DISPLACED.G8.DISPLACED,DISPLACED.G9.DISPLACED,DISPLACED.G10.DISPLACED,DISPLACED.G11,DISPLACED.G12) %>% mutate(Total.Displaced = rowSums(select(., 2:ncol(.)))) %>% select(Total.Displaced)
    
    tall <- cbind(t1,t2,t3,t4,t5)
    
    data_to_display <- tall %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "SNED LEARNERS" = Total.SNED,
        "MUSLIM LEARNERS" = Total.Muslim,
        "IP LEARNERS" = Total.IP,
        "DISPLACED LEARNERS" = Total.Displaced,
        "TOTAL LEARNERS" = Total.Enrollment
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Learner_Type", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Learner_Type = factor(Learner_Type, levels = c(
        "SNED LEARNERS", "MUSLIM LEARNERS", "IP LEARNERS",
        "DISPLACED LEARNERS", "TOTAL LEARNERS"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Learner_Type, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Learner_Type,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "Region",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$displaced_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, DISPLACED.KINDERGARTEN.DISPLACED.LEARNER, DISPLACED.GRADE1.DISPLACED.LEARNER, DISPLACED.GRADE2.DISPLACED.LEARNER, DISPLACED.GRADE3.DISPLACED.LEARNER, DISPLACED.GRADE4.DISPLACED.LEARNER, DISPLACED.GRADE5.DISPLACED.LEARNER, DISPLACED.GRADE6.DISPLACED.LEARNER,DISPLACED.G7.DISPLACED,DISPLACED.G8.DISPLACED,DISPLACED.G9.DISPLACED,DISPLACED.G10.DISPLACED,DISPLACED.G11,DISPLACED.G12) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "KINDER" = DISPLACED.KINDERGARTEN.DISPLACED.LEARNER,
        "GRADE 1" = DISPLACED.GRADE1.DISPLACED.LEARNER,
        "GRADE 2" = DISPLACED.GRADE2.DISPLACED.LEARNER,
        "GRADE 3" = DISPLACED.GRADE3.DISPLACED.LEARNER,
        "GRADE 4" = DISPLACED.GRADE4.DISPLACED.LEARNER,
        "GRADE 5" = DISPLACED.GRADE5.DISPLACED.LEARNER,
        "GRADE 6" = DISPLACED.GRADE6.DISPLACED.LEARNER,
        "GRADE 7" = DISPLACED.G7.DISPLACED,
        "GRADE 8" = DISPLACED.G8.DISPLACED,
        "GRADE 9" = DISPLACED.G9.DISPLACED,
        "GRADE 10" = DISPLACED.G10.DISPLACED,
        "GRADE 11" = DISPLACED.G11,
        "GRADE 12" = DISPLACED.G12
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Displaced_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )  %>%
      mutate(Displaced_Learners = factor(Displaced_Learners, levels = c(
        "KINDER", "GRADE 1", "GRADE 2", "GRADE 3",
        "GRADE 4", "GRADE 5", "GRADE 6",
        "GRADE 7", "GRADE 8", "GRADE 9",
        "GRADE 10", "GRADE 11", "GRADE 12"
      ))) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Displaced_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Displaced_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "Region",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$als_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("ENROLLEDALS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = ENROLLEDALS.ELEM.ALS,
        "JHS" = ENROLLEDALS.JHS.ALS,
        "SHS" = ENROLLEDALS.SHS.ALS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "ALS_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = ALS_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", ALS_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$dropout_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, DROPOUT.PREVSY) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "NUMBER OF DROPOUTS (PREVIOUS SY)" = DROPOUT.PREVSY) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$sosss_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("SOSSS.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$extension_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("EXTENSION.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$teacherinventory_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, TEACHING.PERSONNEL.ELEM, TEACHING.PERSONNEL.JHS, TEACHING.PERSONNEL.SHS) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = TEACHING.PERSONNEL.ELEM,
        "JHS" = TEACHING.PERSONNEL.JHS,
        "SHS" = TEACHING.PERSONNEL.SHS
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Teaching_Personnel", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Teaching_Personnel, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Number_of_Teaching_Personnel,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$classroom_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, NO.CLASSROOM.ELEM, NO.CLASSROOM.SNED.ELEM, NO.CLASSROOM.JHS, NO.CLASSROOM.SNED.JHS, NO.CLASSROOM.SHS) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "ES" = NO.CLASSROOM.ELEM,
        "JHS" = NO.CLASSROOM.JHS,
        "SHS" = NO.CLASSROOM.SHS,
        "SNED-ES" = NO.CLASSROOM.SNED.ELEM,
        "SNED-JHS" = NO.CLASSROOM.SNED.JHS)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Number_of_Classrooms", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Number_of_Classrooms, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Number_of_Classrooms,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5))
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$multigrade_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("MG.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "G1 & G2" = MG.CLASSES.1.2,
        "G3 & G4" = MG.CLASSES.3.4,
        "G5 & G6" = MG.CLASSES.5.6
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Multigrade", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Multigrade, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Multigrade,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$organizedclass_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, CLASS.ORG.BELOW, CLASS.ORG.ABOVE, CLASS.ORG.WITHIN) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "BELOW THE STANDARD" = CLASS.ORG.BELOW,
        "ABOVE THE STANDARD" = CLASS.ORG.ABOVE,
        "WITHIN THE STANDARD" = CLASS.ORG.WITHIN
      )  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Classes_Organized", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) %>%
      # This is the key change: Convert 'Classes_Organized' to a factor with specific levels
      mutate(Classes_Organized = factor(Classes_Organized, levels = c(
        "BELOW THE STANDARD",
        "WITHIN THE STANDARD",
        "ABOVE THE STANDARD"
      )))
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Classes_Organized, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Classes_Organized,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      scale_fill_manual(values = c(
        "BELOW THE STANDARD" = "blue",
        "WITHIN THE STANDARD" = "green", # Optional: you can set a color for this too
        "ABOVE THE STANDARD" = "red"
      )) +
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$jhsdeployment_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,Actual.Teacher.AFA,Actual.Teacher.FCS,Actual.Teacher.IA,Actual.Teacher.ICT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "AFA" = Actual.Teacher.AFA,
        "FCS" = Actual.Teacher.FCS,
        "IA" = Actual.Teacher.IA,
        "ICT" = Actual.Teacher.ICT) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Actual_JHS_Teachers_Deployed", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Actual_JHS_Teachers_Deployed, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Actual_JHS_Teachers_Deployed,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$shifting_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("LAC.OFTEN")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename("Annually" = LAC.OFTEN.ANNUALLY,
             "As need arises"= LAC.OFTEN.NEED.ARISES,
             "Once a month" = LAC.OFTEN.ONCE.A.MONTH,
             "Quarterly" = LAC.OFTEN.QUARTERLY,
             "Semi-annually" = LAC.OFTEN.SEMIANNUALLY,
             "Twice a month" = LAC.OFTEN.TWICE.A.MONTH
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "LAC_Sessions", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = LAC_Sessions, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", LAC_Sessions,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$ldm_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("LDM.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$nat_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("NAT.K12.CURRICULUM.ALIGN"), -"NAT.K12.CURRICULUM.ALIGN_") %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "Moderately Aligned" = NAT.K12.CURRICULUM.ALIGN_Moderately_aligned ,
        "Not at all aligned" = NAT.K12.CURRICULUM.ALIGN_Not_at_all_aligned,
        "Slightly Aligned" = NAT.K12.CURRICULUM.ALIGN_Slightly_aligned,
        "Very well Aligned" = NAT.K12.CURRICULUM.ALIGN_Very_well_aligned,
        "Well Aligned" = NAT.K12.CURRICULUM.ALIGN_Well_aligned
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "NAT_alignment_to_Curriculum", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = NAT_alignment_to_Curriculum, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", NAT_alignment_to_Curriculum,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$nat_sufficiency_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, COMPRE_YES_NAT,YES_NAT,NOT_ADEQ_NAT,NO_NAT) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        ""
      )
    pivot_longer(
      cols = 2:last_col(), # Specifies the columns to pivot
      names_to = "Sections", # The new column to hold the original column names
      values_to = "Count" # The new column to hold the values
    )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$elec_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,GRID_ELEC,OFFGRID_ELEC,COMBINED_ELEC,NO_ELEC_) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "GRID" = GRID_ELEC,
        "OFF-GRID" = OFFGRID_ELEC,
        "COMBINED" = COMBINED_ELEC,
        "NO ELECTRICITY" = NO_ELEC_
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Electricity_Source", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Electricity_Source, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Electricity_Source,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$internet_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,Broadband_MOOE,WiFi_Plan_MOOE,Mobile_Data,No_Internet_Available) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "Broadband" = Broadband_MOOE,
        "WiFi Plan" = WiFi_Plan_MOOE,
        "Mobile Data" = Mobile_Data,
        "No Internet Available" = No_Internet_Available 
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Internet_Source", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Internet_Source, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Internet_Source,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$internet_usage_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,Combination_Internet,Instructional_Internet,Administrative_Internet,None_Internet) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "Instructional" = Instructional_Internet,
        "Administrative" = Administrative_Internet,
        "Combination" = Combination_Internet,
        "None" = None_Internet
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Internet_Usage", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Internet_Usage, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Internet_Usage,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  
  output$water_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v3 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,GROUNDWATER_WATER,BOTTLED_WATER,MWSS_WATER,WELL_WATER,LOCAL_WATER,SURFACE_WATER,PIPEDL3_WATER) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "Bottled Water" = BOTTLED_WATER,
        "Groundwater" = GROUNDWATER_WATER,
        "Local Water" = LOCAL_WATER,
        "MWSS" = MWSS_WATER,
        "Piped Water" = PIPEDL3_WATER,
        "Surface Water" = SURFACE_WATER,
        "Well Water" = WELL_WATER
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Water_Source", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Water_Source, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Water_Source,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$adm_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("ALTERNATIVE.ADM")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$rf_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("QUALI.READING.PROFICIENCY.CHANGE")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "Declined" = QUALI.READING.PROFICIENCY.CHANGE_Declined,
        "Improved" = QUALI.READING.PROFICIENCY.CHANGE_Improved,
        "Stagnant" = QUALI.READING.PROFICIENCY.CHANGE_Stagnant
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Reading_Proficiency", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Reading_Proficiency, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Reading_Proficiency,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$aral_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,ARAL.MATH,ARAL.READING,ARAL.SCIENCE) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "MATH" = ARAL.MATH,
        "READING" = ARAL.READING,
        "SCIENCE" = ARAL.SCIENCE)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Prospective_ARAL_Learners", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Prospective_ARAL_Learners, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Prospective_ARAL_Learners,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$bully_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION,MENTAL.BULLYING.COUNT,MENTAL.CHILDREN.RIGHT.ORIENTATION) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "INCIDENCE OF BULLYING" = MENTAL.BULLYING.COUNT,
        "ATTENDANCE TO CHILDRENS' RIGHTS ORIENTATION" = MENTAL.CHILDREN.RIGHT.ORIENTATION)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$crla_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, CRLA.DEVELOPING, CRLA.LOW, CRLA.TRANSITIONAL, CRLA.HIGH, CRLA.GRADELEVEL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "LOW" = CRLA.LOW,
        "DEVELOPING" = CRLA.DEVELOPING,
        "TRANSITIONAL" = CRLA.TRANSITIONAL,
        "HIGH" = CRLA.HIGH,
        "GRADE LEVEL" = CRLA.GRADELEVEL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "CRLA_Levels", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = CRLA_Levels, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", CRLA_Levels,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$philiri_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, PHILIRI.FRUSTRATION, PHILIRI.TRANSITIONAL, PHILIRI.INSTRUCTIONAL) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "FRUSTRATION" = PHILIRI.FRUSTRATION,
        "TRANSITIONAL" = PHILIRI.TRANSITIONAL,
        "INSTRUCTIONAL" = PHILIRI.INSTRUCTIONAL)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "PhilIRI_Levels", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = PhilIRI_Levels, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", PhilIRI_Levels,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$sha_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("SHA.CATEGORY")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$feeding_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("SBFP.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>% 
      rename(
        "DepEd Beneficiary" = SBFP.BENEFICIARY,
        "Non-DepEd Beneficiary" = SBFP.NO.OF.BENEFICIARIES.NOT.SBFP
      ) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Feeding_Program_Beneficiaries", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Feeding_Program_Beneficiaries, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Feeding_Program_Beneficiaries,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$years_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("SERVICE.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE))  %>%
      rename("Less than 1 year" = SERVICE.X0.TO.1,
             "2-5 years" = SERVICE.X2.TO.5,
             "6-10 years" = SERVICE.X6.TO.10,
             "11-15 years" = SERVICE.X11.TO.15,
             "16-20 years" = SERVICE.X16.TO.20,
             "21-25 years" = SERVICE.X21.TO.25,
             "26-30 years" = SERVICE.X26.TO.30,
             "31-35 years" = SERVICE.X31.TO.35,
             "36-40 years" = SERVICE.X36.TO.40,
             "41-45 years" = SERVICE.X41.TO.45) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Years_in_Service", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Years_in_Service, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Years_in_Service,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$resources_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud_v2 %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("RESOURCES.")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>%
      mutate(RESOURCES.MATH = round((`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` / (`RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_Yes` + `RESOURCES.RECEIVED.SCIENCE.MATH.EQUIPMENT_No`)) * 100, 2)) %>%
      mutate(RESOURCES.HANDWASHING = round((`RESOURCES.REGULAR.HANDWASHING_Yes` / (`RESOURCES.REGULAR.HANDWASHING_Yes` + `RESOURCES.REGULAR.HANDWASHING_No`)) * 100, 2)) %>%
      mutate(RESOURCES.SOAP = round((`RESOURCES.REGULAR.SOAP_Yes` / (`RESOURCES.REGULAR.SOAP_Yes` + `RESOURCES.REGULAR.SOAP_No`)) * 100, 2)) %>%
      mutate(RESOURCES.TVL = round((`RESOURCES.SCHOOL.WITH.TVL_Yes` / (`RESOURCES.SCHOOL.WITH.TVL_Yes` + `RESOURCES.SCHOOL.WITH.TVL_None`)) * 100, 2)) %>%
      # mutate(RESOURCES.CHAIR = round((`RESOURCES.CHAIR.FUNCTIONAL` / `RESOURCES.CHAIR.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.DESK = round((`RESOURCES.DESK.FUNCTIONAL` / `RESOURCES.DESK.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.ECART = round((`RESOURCES.ECART.FUNCTIONAL` / `RESOURCES.ECART.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.LAPTOP = round((`RESOURCES.LAPTOP.FUNCTIONAL` / `RESOURCES.LAPTOP.INVENTORY`) * 100, 2)) %>%
      # mutate(RESOURCES.TOILET = round((`RESOURCES.FUNCTIONAL.TOILET` / `RESOURCES.NON.FUNCTIONAL.TOILET`) * 100, 2)) %>%
      # mutate(RESOURCES.TV = round((`RESOURCES.TV.FUNCTIONAL` / `RESOURCES.TV.INVENTORY`) * 100, 2))  
      select(1,"RESOURCES.MATH","RESOURCES.HANDWASHING","RESOURCES.SOAP","RESOURCES.TVL") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), mean, na.rm = TRUE)) %>% 
      rename("Handwashing" = RESOURCES.HANDWASHING,
             "Soap" = RESOURCES.SOAP,
             "Math" = RESOURCES.MATH,
             "TVL" = RESOURCES.TVL) %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Resources_Data", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      ) 
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = BASIC.REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Resources_Data, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", BASIC.REGION,
                                 "<br>Section: ", Resources_Data,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  output$overload_regional_profile_graph <- renderPlotly({
    # Use the reactive filtered data
    
    data_to_display <- cloud %>% filter(BASIC.REGION == input$cloud_region_profile_filter) %>%
      select(BASIC.REGION, contains("DO5.OVERLOAD")) %>% 
      mutate(across(2:last_col(), as.numeric)) %>% 
      mutate(BASIC.REGION = as.character(BASIC.REGION)) %>%
      filter(BASIC.REGION != "") %>% 
      group_by(BASIC.REGION) %>%
      summarise(across(everything(), sum, na.rm = TRUE)) %>% 
      rename(
        "REGION" = BASIC.REGION,
        "OVERLOAD PAY RECIPIENTS" = DO5.OVERLOAD.PAY.RECIPIENT)  %>% 
      pivot_longer(
        cols = 2:last_col(), # Specifies the columns to pivot
        names_to = "Sections", # The new column to hold the original column names
        values_to = "Count" # The new column to hold the values
      )
    
    current_filtered_data <- data_to_display
    
    # --- Empty Data Handling ---
    if (nrow(current_filtered_data) == 0) {
      return(ggplotly(ggplot() +
                        annotate("text", x = 0.5, y = 0.5, label = "No data for selected regions/divisions") +
                        theme_void()))
    }
    
    # Prepare the data for plotting
    plot_data <- data_to_display
    
    # Create the ggplot
    p <- ggplot(plot_data,
                aes(x = REGION, # Reorder regions based on overall total count for the region
                    y = Count,
                    fill = Sections, # Fill by Clustering.Status for coloring and consistent order
                    text = paste("Region: ", REGION,
                                 "<br>Section: ", Sections,
                                 "<br>Count: ", scales::comma(Count)))) + # Custom tooltip text
      geom_bar(stat = "identity", position = "dodge", color = "black") + # Changed to position="dodge" for dodgeed bars
      labs(x = "",
           y = "") +
      scale_y_continuous(labels = scales::comma) + # Format y-axis labels as comma-separated numbers
      theme_minimal() +
      theme(axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
            legend.position = "bottom", # Position legend at the bottom
            plot.title = element_text(hjust = 0.5)) # Center the plot title
    
    # Convert ggplot to plotly, ensuring custom text is used for hover
    ggplotly(p, tooltip = "text", source = "cloudenrolmentRegionPlot") %>%
      layout(hoverlabel = list(bgcolor = "white"),
             margin = list(b = 100)) # Increase bottom margin for x-axis labels
  })
  
  ### ENHANCED LOGIN PAGE ####
  
  # Reactive value to track the user's status: "unauthenticated", "login", "register", "authenticated"
  user_status <- reactiveVal("unauthenticated")
  
  # ðŸ’¡ NEW: Reactive value to store the username after successful authentication
  authenticated_user <- reactiveVal(NULL)
  
  # Reactive value to hold the user's choice: "login" or "register"
  form_choice <- reactiveVal("login")  
  
  # Reactive value to trigger a database refresh
  db_trigger <- reactiveVal(0)  
  
  # Reactive value to hold the user database
  user_database <- reactive({
    # Depend on the trigger. Every time db_trigger changes, this runs.
    db_trigger()  
    
    # Read data from Google Sheet
    users_db <- tryCatch({
      googlesheets4::read_sheet(sheet_url)
    }, error = function(e) {
      showNotification(paste("Error reading database:", e$message,  
                             "Assuming sheet structure is correct."), type = "error")
      # Return an empty dataframe with correct structure on error to prevent crashing
      # Ensure 'Station' column is included
      return(data.frame(Email_Address = character(), Password = character(), Station = character())) 
    })
    
    return(users_db)
  })
  
  observe({
    
    # --- Part A: Check if required fields are filled ---
    
    # List the IDs of all inputs that MUST be filled out.
    # Optional fields are not included here.
    required_inputs <- c(
      "school_id",
      "school_head_contact",
      "school_head_email"
    )
    
    # This checks that each required input is not empty or NULL.
    # It returns TRUE only if all required fields have a value.
    all_filled <- all(sapply(required_inputs, function(id) {
      !is.null(input[[id]]) && input[[id]] != ""
    }))
    
    # --- Part B: Check if the inputs have the correct format ---
    
    # We use `isTRUE()` to safely handle potential errors (like NA) from checks.
    # It treats anything that isn't exactly TRUE as FALSE.
    
    # Validate School ID: must be a number and have the correct length.
    school_id_ok <- isTRUE(
      !is.na(as.numeric(input$school_id)) &&                # Is it a number?
        nchar(as.character(input$school_id)) == 6 # Is it the right length?
    )
    
    # Validate Primary Contact: must be a number and have the correct length.
    contact_ok <- isTRUE(
      !is.na(as.numeric(input$school_head_contact)) &&
        nchar(as.character(input$school_head_contact)) == 11
    )
    
    # Validate Alternate Contact: it's valid if it's empty OR if it meets the format rules.
    contact_alt_ok <- isTRUE(
      input$school_head_contact_alt == "" || # It's okay if empty
        (
          !is.na(as.numeric(input$school_head_contact_alt)) &&
            nchar(as.character(input$school_head_contact_alt)) == 11
        )
    )
    
    # Validate Primary Email: must contain "@deped.gov.ph".
    email_ok <- isTRUE(grepl("@deped.gov.ph", input$school_head_email))
    
    # Validate Alternate Email: it's valid if it's empty OR if it meets the format rules.
    email_alt_ok <- isTRUE(
      input$school_head_email_alt == "" || # It's okay if empty
        grepl("@", input$school_head_email_alt)
    )
    
    # Combine all format checks. This will be TRUE only if every single check above is TRUE.
    all_correct <- school_id_ok && contact_ok && contact_alt_ok && email_ok && email_alt_ok
    
    # --- Part C: Enable or Disable the Submit Button ---
    
    # The button is enabled only if all required fields are filled AND all formats are correct.
    if (all_filled && all_correct) {
      shinyjs::enable("submit")
    } else {
      shinyjs::disable("submit")
    }
  })
  
  # --- UI Rendering Logic ---
  
  # Main dynamic UI switch
  # 1ï¸âƒ£  Define the reusable UI function FIRST
  login_register_UI <- function(id) {
    ns <- NS(id)
    
    tagList(
      # âœ… Animated gradient background (no bubbles)
      div(class = "login-bg gradient-animated"),
      
      # Render the UI produced by the authentication module
      uiOutput(ns("auth_page"))
    )
  }
  
  
  
  # 2ï¸âƒ£  Define the main dynamic page switch
  output$page_ui <- renderUI({
    status <- user_status()
    current_user <- authenticated_user()  # Retrieve logged-in user
    
    # âœ… AUTHENTICATED USERS
    if (status == "authenticated" && !is.null(current_user)) {
      
      # ðŸŸ¡ Step 1: Check if Guest first
      if (current_user == "guest_user@stride") {
        print("ðŸŸ¢ Guest accessing STRIDE2 dashboard")
        
        showNotification("Welcome to STRIDE (Guest Mode: Read-only Access)", type = "message", duration = 5)
        
        shinyjs::show("mgmt_content")
        return(NULL)
      }
      
      
      # ðŸŸ¢ Step 2: Handle authenticated users from Google Sheet
      users_db <- user_database()
      user_row <- users_db[users_db$Email_Address == current_user, ]
      
      if (nrow(user_row) == 1) {
        station <- user_row$Station[1]
        
        if (station == "Central Office") {
          shinyjs::hide("data_input_content")
          shinyjs::show("mgmt_content")
          shinyjs::hide("main_content")
        } else if (station == "School") {
          shinyjs::show("data_input_content")
          shinyjs::hide("main_content")
          shinyjs::hide("mgmt_content")
        } else {
          # Default fallback for other station types
          return(card(
            card_header("Application Dashboard"),
            h2(paste("Welcome,", station, "User!")),
            actionButton("main_app-logout", "Logout", class = "btn-danger")
          ))
        }
        
        return(NULL)
      }
    }
    
    
    # âœ… UNAUTHENTICATED USERS â€” show login/register page
    login_register_UI("auth")
  })
  
  
  # 3ï¸âƒ£  Activate the authentication module
  callModule(authentication_server, "auth", 
             user_status, form_choice, sheet_url, user_database, db_trigger, 
             authenticated_user)
  
  
  # Pass the new reactive
  
  # --- Main App Module ---
  
  # Handle logout from the main app
  observeEvent(input$`main_app-logout`, {
    user_status("unauthenticated")
    authenticated_user(NULL) # ðŸ’¡ NEW: Clear the authenticated user
    form_choice("login")  
    showNotification("Logged out successfully.", type = "message")
  })
  
}

# --- Authentication Server (Handles the logic for login and registration) ---
# ==========================================================
# --- AUTHENTICATION MODULE: LOGIN / REGISTER / GUEST ---
# ==========================================================

authentication_server <- function(input, output, session, user_status, 
                                  form_choice, sheet_url, user_database, db_trigger, 
                                  authenticated_user) {
  ns <- session$ns
  
  # --- 1ï¸âƒ£ SWITCH BETWEEN LOGIN & REGISTER FORMS ---
  observeEvent(input$btn_register, { form_choice("register") })
  observeEvent(input$btn_login, { form_choice("login") })
  
  # --- 2ï¸âƒ£ MAIN AUTH PAGE UI ---
  output$auth_page <- renderUI({
    if (form_choice() == "login") {
      # LOGIN PANEL
      div(
        class = "login-container",
        div(
          class = "login-left",
          div(
            class = "login-text-box text-center",
            div(
              class = "login-left-logos",
              tags$img(src = "logo2.png", class = "left-logo"),
              tags$img(src = "logo3.png", class = "left-logo")
            ),
            h2(
              HTML('
        <span class="stride-str">Str</span>
        <img src="i.png" class="stride-logo-i" alt="I Logo">
        <span class="stride-ide">de</span>
      '),
              class = "stride-logo-text mt-3"
            ),
            p(class = "slogan-mid", "Education in Motion!"),
            div(
              class = "slogan-bottom-row",
              span(class = "slogan-left", "Data Precision."),
              span(class = "slogan-right", "Smart Decision.")
            )
          )
        )
        ,
        div(
          class = "login-right",
          div(
            class = "login-card",
            tags$img(src = "logo1.png", class = "login-logo-top"),
            textInput(ns("login_user"), NULL, placeholder = "DepEd Email"),
            passwordInput(ns("login_pass"), NULL, placeholder = "Password"),
            actionButton(ns("do_login"), "Sign In", class = "btn-login w-100"),
            uiOutput(ns("login_message")),
            br(),
            actionLink(ns("btn_register"), "Create an account", class = "register-link"),
            br(),
            # actionButton(ns("guest_mode"), "Continue as Guest", class = "btn-secondary w-100 mt-2"),
            div(
              class = "login-logos-bottom",
              tags$img(src = "HROD LOGO1.png", class = "bottom-logo")
            )
          )
        )
      )
    } else {
      # REGISTER PANEL
      div(
        class = "login-container",
        
        div(
          class = "login-left",
          div(class = "login-text-box",
              h2("Create a STRIDE Account"),
              p("Register your DepEd account to access STRIDE dashboards.")
          )
        ),
        
        div(
          class = "register-wrapper d-flex gap-4 align-items-start",
          
          # LEFT PANEL: appears when Engineer or HR selected
          conditionalPanel(
            condition = paste0(
              "['Engineer II','Engineer III','Engineer IV','Engineer V','Human Resources Management Officer I']",
              ".includes(input['", ns("position"), "'])"
            ),
            div(
              class = "engineer-panel card p-3",
              h4("Engineer / HR Information"),
              textInput(ns("first_name"), "First Name"),
              textInput(ns("middle_name"), "Middle Name"),
              textInput(ns("last_name"), "Last Name"),
              numericInput(ns("age"), "Age", value = NA, min = 18, max = 100, step = 1),
              dateInput(ns("birthday"), "Birthday", format = "yyyy-mm-dd"),
              textInput(ns("address"), "Address"),
              selectInput(ns("region"), "Region", choices = sort(unique(uni$Region))),
              uiOutput(ns("division_ui")),
              uiOutput(ns("district_ui")),
              uiOutput(ns("school_ui"))
            )
          ),
          
          # RIGHT PANEL: main registration card
          div(
            class = "login-right flex-grow-1",
            div(
              class = "login-card",
              
              selectInput(ns("govlev"), "Select Station:",
                          choices = c("â€” Select an Option â€”" = "",
                                      "Central Office", "Regional Office", 
                                      "Schools Division Office", "School")),
              uiOutput(ns("station_specific_ui")),
              uiOutput(ns("position_ui")),
              
              textInput(ns("reg_user"), NULL, placeholder = "DepEd Email (@deped.gov.ph)"),
              passwordInput(ns("reg_pass"), NULL, placeholder = "Password"),
              passwordInput(ns("reg_pass_confirm"), NULL, placeholder = "Confirm Password"),
              
              actionButton(ns("do_register"), "Register Account", class = "btn-login w-100"),
              uiOutput(ns("register_message")),
              br(),
              actionLink(ns("btn_login"), "Back to Login", class = "register-link"),
              div(class = "login-logos-bottom",
                  tags$img(src = "HROD LOGO1.png", class = "bottom-logo"))
            )
          )
        )
      )
    }
    
    
    
    
  })
  
  # --- 3ï¸âƒ£ STATION-SPECIFIC INPUTS ---
  output$station_specific_ui <- renderUI({
    req(input$govlev)
    if (input$govlev == "School") {
      tagList(
        textInput(ns("school_id"), "School ID:"),
        tags$small("Enter your School ID (6 digits).", class = "text-muted")
      )
    } else if (input$govlev %in% c("Central Office", "Regional Office", "Schools Division Office")) {
      tagList(
        textInput(ns("office_name"), "Office Name:"),
        tags$small("Enter Bureau/Division. Do not abbreviate!", class = "text-muted")
      )
    } else NULL
  })
  
  # --- 4ï¸âƒ£ DYNAMIC POSITION DROPDOWN ---
  output$position_ui <- renderUI({
    dfGMISPosCat <- read.csv("GMIS-Apr2025-PosCat.csv")
    req(input$govlev)
    positions <- sort(unique(dfGMISPosCat$Position))
    selectInput(ns("position"), "Position:", choices = positions)
  })
  
  # observe({
  #   pos <- input[[ns("position")]]
  #   show_list <- c("Engineer II", "Engineer III", "Engineer IV", "Engineer V", 
  #                  "Human Resources Management Officer I")
  #   
  #   if (!is.null(pos) && pos %in% show_list) {
  #     shinyjs::showElement(id = ns("engineer_hr_panel"), anim = TRUE)
  #   } else {
  #     shinyjs::hideElement(id = ns("engineer_hr_panel"), anim = TRUE)
  #   }
  # })
  
  
  
  
  # --- 6ï¸âƒ£ DYNAMIC DROPDOWNS (Region -> Division -> District -> School) ---
  observeEvent(input$region, {
    req(input$region)
    divisions <- sort(unique(uni$Division[uni$Region == input$region]))
    updateSelectInput(session, "division", choices = divisions)
  })
  
  output$division_ui <- renderUI({
    req(input$region)
    selectInput(ns("division"), "Division", choices = sort(unique(uni$Division[uni$Region == input$region])))
  })
  
  output$district_ui <- renderUI({
    req(input$division)
    selectInput(ns("district"), "Legislative District",
                choices = sort(unique(uni$Legislative.District[uni$Division == input$division])))
  })
  
  output$school_ui <- renderUI({
    req(input$district)
    selectInput(ns("school_id"), "School ID (6-digit)",
                choices = sort(unique(uni$SchoolID[uni$Legislative.District == input$district])))
  })
  
  # --- 7ï¸âƒ£ SUBMIT HANDLER FOR ENGINEER / HR INFO ---
  observeEvent(input$submit_engineer_hr, {
    req(input$user_name, input$user_email, input$region, input$division, input$district, input$school_id)
    new_entry <- data.frame(
      Timestamp = Sys.time(),
      Name = input$user_name,
      Email = input$user_email,
      Position = input$position,
      Region = input$region,
      Division = input$division,
      Legislative_District = input$district,
      School_ID = input$school_id,
      stringsAsFactors = FALSE
    )
    tryCatch({
      googlesheets4::sheet_append(sheet_url, data = new_user)
      print("âœ… Successfully appended to Google Sheet")
      
      db_trigger(db_trigger() + 1)
      
      # Mark as registered and authenticated
      register_success(TRUE)
      user_status("authenticated")
      authenticated_user(reg_user)
      
      showNotification("âœ… Registration successful! Redirecting...", type = "message", duration = 4)
      
    }, error = function(e) {
      showNotification(paste("âŒ Error writing to sheet:", e$message), type = "error")
    })
    
    
  })
  
  # --- 8ï¸âƒ£ LOGIN LOGIC ---
  observeEvent(input$do_login, {
    req(input$login_user, input$login_pass)
    users_db <- user_database()
    if (nrow(users_db) == 0) {
      output$login_message <- renderUI({
        tags$p("Database is empty or inaccessible.", class = "text-danger mt-2")
      })
      return()
    }
    user_row <- users_db[users_db$Email_Address == input$login_user, ]
    if (nrow(user_row) == 1 && user_row$Password == input$login_pass) {
      user_status("authenticated")
      authenticated_user(input$login_user)
      session$sendCustomMessage("showLoader", "Welcome to STRIDE...")
      print(">>> Login success â€” showLoader triggered")
      later::later(function() { session$sendCustomMessage("hideLoader", NULL) }, 2)
      updateTextInput(session, "login_user", value = "")
      updateTextInput(session, "login_pass", value = "")
      output$login_message <- renderUI({})
    } else {
      output$login_message <- renderUI({
        tags$p("Invalid username or password.", class = "text-danger mt-2")
      })
    }
  })
  
  # --- 9ï¸âƒ£ GUEST MODE LOGIC ---
  observeEvent(input$guest_mode, {
    print("ðŸŸ¢ Guest mode activated")
    user_status("authenticated")
    authenticated_user("guest_user@stride")
    session$sendCustomMessage("showLoader", "Entering STRIDE2 as Guest...")
    later::later(function() { session$sendCustomMessage("hideLoader", NULL) }, 2)
  })
  
  
  
  # --- ðŸ”Ÿ REGISTRATION LOGIC ---
  observeEvent(input$do_register, {
    print("ðŸ”” Register button clicked")
    
    # Collect inputs
    reg_user <- input$reg_user
    reg_pass <- input$reg_pass
    govlev <- input$govlev
    position <- input$position
    
    # Validation
    if (is.null(reg_user) || reg_user == "") {
      showNotification("âŒ Please enter your DepEd email.", type = "error")
      return()
    }
    if (!endsWith(reg_user, "@deped.gov.ph")) {
      showNotification("âŒ Invalid email domain. Use @deped.gov.ph", type = "error")
      return()
    }
    if (is.null(reg_pass) || reg_pass == "") {
      showNotification("âŒ Please enter a password.", type = "error")
      return()
    }
    if (is.null(govlev) || govlev == "") {
      showNotification("âŒ Please select your station.", type = "error")
      return()
    }
    
    # === Collect all registration data (including Engineer/HR fields) ===
    new_user <- data.frame(
      Registration_Date = as.character(Sys.time()),
      Email_Address = reg_user,
      Password = reg_pass,
      Station = govlev,
      School_ID = ifelse(govlev == "School", input$school_id, NA),
      Office = ifelse(govlev != "School", input$office_name, NA),
      Position = ifelse(!is.null(position) && position != "", position, NA),
      
      # ðŸ‘‡ New columns for Engineer/HR (may be NA for others)
      First_Name = ifelse(!is.null(input$first_name), input$first_name, NA),
      Middle_Name = ifelse(!is.null(input$middle_name), input$middle_name, NA),
      Last_Name = ifelse(!is.null(input$last_name), input$last_name, NA),
      Age = ifelse(!is.null(input$age), input$age, NA),
      Birthday = ifelse(!is.null(input$birthday), as.character(input$birthday), NA),
      Address = ifelse(!is.null(input$address), input$address, NA),
      Region = ifelse(!is.null(input$region), input$region, NA),
      Division = ifelse(!is.null(input$division), input$division, NA),
      Legislative_District = ifelse(!is.null(input$district), input$district, NA),
      School_ID_Selected = ifelse(!is.null(input$school_id), input$school_id, NA),
      
      stringsAsFactors = FALSE
    )
    
    print("ðŸ§© Prepared registration data:")
    print(new_user)
    
    # === Write to Google Sheet ===
    tryCatch({
      googlesheets4::sheet_append(sheet_url, data = new_user)
      showNotification("âœ… Registration successful!", type = "message")
      
      db_trigger(db_trigger() + 1)
      user_status("authenticated")
      authenticated_user(reg_user)
      
    }, error = function(e) {
      showNotification(paste("âŒ Error writing to sheet:", e$message), type = "error")
    })
  })
  
  # --- Disable Register button until required fields are filled ---
  observe({
    req(input$reg_user, input$reg_pass, input$govlev, input$position)
    
    # Basic required fields
    basic_filled <- all(
      nzchar(input$reg_user),
      nzchar(input$reg_pass),
      nzchar(input$govlev),
      nzchar(input$position)
    )
    
    # Check if Engineer/HR panel is visible and collect required inputs
    engineer_positions <- c("Engineer II", "Engineer III", "Engineer IV", "Engineer V", "Human Resources Management Officer I")
    is_engineer <- input$position %in% engineer_positions
    
    if (is_engineer) {
      # Additional required fields for engineer/HR
      extra_filled <- all(
        nzchar(input$first_name),
        nzchar(input$last_name),
        !is.null(input$age) && input$age > 0,
        !is.null(input$birthday) && input$birthday != "",
        nzchar(input$address),
        nzchar(input$region),
        nzchar(input$division),
        nzchar(input$district),
        nzchar(input$school_id)
      )
    } else {
      extra_filled <- TRUE
    }
    
    enable_btn <- basic_filled && extra_filled
    shinyjs::toggleState(ns("do_register"), condition = enable_btn)
  })
  
  
}

# --- END OF AUTHENTICATION MODULE ---
# ==========================================================





# Run only once when the server starts

# ... (Your validate_numeric_input function goes here) ...
validate_numeric_input <- function(inputId, len) {
  
  
  # --- END OF AUTHENTICATION MODULE ---
  # ==========================================================
  
  
  
  
  
  # Reactive function to read the data (run once when server starts)
  observeEvent(TRUE, {
    # This reads the data and stores it in the reactiveVal
    tryCatch({
      # Use read_sheet to read the data, forcing it to character to match inputs
      data <- read_sheet(
        ss = SHEET_ID, 
        sheet = SHEET_NAME, 
        col_types = "c", # Read all columns as character to prevent type mismatch
        trim_ws = TRUE
      )
      school_data(data)
    }, error = function(e) {
      showModal(modalDialog(
        title = "Authentication Error",
        paste("Failed to read Google Sheet. Check Sheet ID, network, and permissions:", e$message),
        footer = modalButton("Close")
      ))
      # Stop execution if data cannot be loaded
      stop("Sheet read failed.")
    })
  }, once = TRUE) # Run only once when the server starts
  
  # ... (Your validate_numeric_input function goes here) ...
  validate_numeric_input <- function(inputId, len) {
    
    observeEvent(input[[inputId]], {
      
      # Get the value from the input. 
      val_str <- input[[inputId]]
      
      # --- FIX: Check for NULL, Empty String, OR NA ---
      # We must explicitly handle NA before nchar or grepl is called.
      if (is.null(val_str) || val_str == "" || is.na(val_str)) {
        shinyjs::removeClass(id = inputId, class = "input-error")
        return()
      }
      
      # 2. Check if the input contains ONLY digits.
      # We use isTRUE() as a safeguard, just in case grepl returns NA (though unlikely here)
      # is_all_digits will be TRUE or FALSE, never NA.
      is_all_digits <- isTRUE(grepl("^\\d+$", val_str))
      
      # 3. Check the exact character length.
      is_correct_length <- nchar(val_str) == len
      
      # The input is valid only if both conditions are TRUE.
      # R's '&&' is safe because is_all_digits is guaranteed TRUE/FALSE.
      is_valid <- is_all_digits && is_correct_length
      
      if (is_valid) {
        shinyjs::removeClass(id = inputId, class = "input-error")
      } else {
        shinyjs::addClass(id = inputId, class = "input-error")
      }
    }, ignoreNULL = FALSE) 
  }
  # ... (Your validation observers go here) ...
  validate_numeric_input(inputId = "school_id", len = 6)
  validate_numeric_input(inputId = "school_head_contact", len = 11)
  validate_numeric_input(inputId = "school_head_contact_alt", len = 11)
  
  # (Your email validation observers go here - they remain unchanged)
  observeEvent(input$school_head_email, {
    id_val <- input$school_head_email
    is_valid <- (id_val == "" || grepl("@deped.gov.ph", id_val))
    if (is_valid) { shinyjs::removeClass(id = "school_head_email", class = "input-error") } 
    else { shinyjs::addClass(id = "school_head_email", class = "input-error") }
  })
  
  observeEvent(input$school_head_email_alt, {
    id_val <- input$school_head_email_alt
    is_valid <- (id_val == "" || grepl("@", id_val))
    if (is_valid) { shinyjs::removeClass(id = "school_head_email_alt", class = "input-error") } 
    else { shinyjs::addClass(id = "school_head_email_alt", class = "input-error") }
  })
  
  # --- [UPDATED] List of all required input IDs for form data collection ---
  required_inputs <- c(
    # ... (Your required_inputs list remains the same) ...
    "school_id", "school_name", "school_head_gn", "school_head_mn", "school_head_ln",
    "school_head_position", "region", "division", "curricular_offering",
    "school_head_contact","school_head_contact_alt","school_head_email","school_head_email_alt",
    "g1", "g2", "g3", "g4", "g5", "g6", "g7", "g8", "g9", "g10", "g11", "g12",
    "org_g1", "org_g2", "org_g3", "org_g4", "org_g5", "org_g6",
    "org_g7", "org_g8", "org_g9", "org_g10", "org_g11", "org_g12",
    "teaching_elem", "teaching_jhs", "teaching_shs",
    "instructional_rooms_es", "instructional_rooms_jhs", "instructional_rooms_shs",
    "instructional_rooms_repair", "buildings", "buildings_repair",
    "laptops", "laptops_repair", "chairs", "chairs_repair", "desk", "desk_repair",
    "ecart", "ecart_repair", "toilet", "toilet_repair", "printer", "printer_repair",
    "tv", "tv_repair", "science_lab", "computer_lab", "tvl_lab",
    "english", "math", "science", "biological_science", "physical_science",
    "general_education", "araling_panlipunan", "tle", "mapeh", "filipino",
    "esp", "agriculture", "ece", "sped"
  )
  
  # --- Observer to enable/disable the submit button (This remains unchanged) ---
  # ... (Your observe({}) block for submit button logic remains the same) ...
  
  # --- Dynamic UI for Division based on Region selection (Requires 'df' to be defined) ---
  # Assuming 'df' is loaded elsewhere, this part remains unchanged.
  # output$division <- renderUI({ ... })
  
  # --- [REVISED] Observer to auto-load existing school records (From Google Sheet) ---
  observe({
    req(school_data()) # Require that the data has been loaded
    req(input$school_id)
    current_school_id <- debounce(reactive(input$school_id), 500)
    
    if (is.null(current_school_id()) || current_school_id() == "") return()
    
    data_df <- school_data()
    
    # 1. Find the matching row
    # Ensure School ID column is read correctly, assume it's "school_id"
    # We use tolower(names(data_df)) just in case the column name has different case
    match_row <- which(data_df[[tolower("school_id")]] == current_school_id())
    
    if (length(match_row) > 0) {
      # --- IF RECORD FOUND: Load the data ---
      showNotification("Existing school record loaded.", type = "message", duration = 3)
      record_details <- data_df[match_row[1], ] # Use the first match
      
      # 2. Update UI elements using the loaded row
      # Text Inputs
      updateTextInput(session, "school_name", value = record_details$school_name)
      updateTextInput(session, "school_head_gn", value = record_details$school_head_gn)
      updateTextInput(session, "school_head_mn", value = record_details$school_head_mn)
      updateTextInput(session, "school_head_ln", value = record_details$school_head_ln)
      updateTextInput(session, "school_head_contact", value = record_details$school_head_contact)
      updateTextInput(session, "school_head_contact_alt", value = record_details$school_head_contact_alt)
      updateTextInput(session, "school_head_email", value = record_details$school_head_email)
      updateTextInput(session, "school_head_email_alt", value = record_details$school_head_email_alt)
      
      # Select Inputs
      updateSelectInput(session, "school_head_position", selected = record_details$school_head_position)
      updateSelectInput(session, "region", selected = record_details$region)
      # Assuming division updates dynamically based on region, but we update it anyway
      updateSelectInput(session, "division", selected = record_details$division)
      updateSelectInput(session, "curricular_offering", selected = record_details$curricular_offering)
      
      # Numeric Inputs (Using lapply to be concise)
      numeric_ids <- c(
        paste0("g", 1:12), paste0("org_g", 1:12), 
        # ... (rest of your numeric IDs) ...
        "teaching_elem", "teaching_jhs", "teaching_shs",
        "instructional_rooms_es", "instructional_rooms_jhs", "instructional_rooms_shs", 
        "instructional_rooms_repair", "buildings", "buildings_repair",
        "laptops", "laptops_repair", "chairs", "chairs_repair", "desk", "desk_repair",
        "ecart", "ecart_repair", "toilet", "toilet_repair", "printer", "printer_repair",
        "tv", "tv_repair", "science_lab", "computer_lab", "tvl_lab",
        "english", "math", "science", "biological_science", "physical_science",
        "general_education", "araling_panlipunan", "tle", "mapeh", "filipino",
        "esp", "agriculture", "ece", "sped"
      )
      
      lapply(numeric_ids, function(id) {
        # Need to convert loaded value to numeric for updateNumericInput
        updateNumericInput(session, id, value = as.numeric(record_details[[tolower(id)]]))
      })
      
    } else {
      # --- IF NO RECORD FOUND: Clear all fields (same as your original logic) ---
      # ... (Your clear fields logic remains the same) ...
      showNotification("No matching record found. Starting new entry.", type = "warning", duration = 3)
      
      # Text Inputs
      updateTextInput(session, "school_name", value = "")
      updateTextInput(session, "school_head_gn", value = "")
      updateTextInput(session, "school_head_mn", value = "")
      updateTextInput(session, "school_head_ln", value = "")
      updateTextInput(session, "school_head_contact", value = "")
      updateTextInput(session, "school_head_contact_alt", value = "")
      updateTextInput(session, "school_head_email", value = "")
      updateTextInput(session, "school_head_email_alt", value = "")
      
      # Select Inputs (Reset to defaults/prompts)
      updateSelectInput(session, "school_head_position", selected = "School Principal I") 
      updateSelectInput(session, "region", selected = "--- Select a Region ---") # Use the prompt value from your UI
      updateSelectInput(session, "division", selected = NULL)
      updateSelectInput(session, "curricular_offering", selected = "--- Select a Curricular Offering ---") # Use the prompt value
      
      # Numeric Inputs: Clear all numeric fields by setting value = NA
      numeric_ids <- c(
        paste0("g", 1:12), paste0("org_g", 1:12), 
        "teaching_elem", "teaching_jhs", "teaching_shs",
        "instructional_rooms_es", "instructional_rooms_jhs", "instructional_rooms_shs", 
        "instructional_rooms_repair", "buildings", "buildings_repair",
        "laptops", "laptops_repair", "chairs", "chairs_repair", "desk", "desk_repair",
        "ecart", "ecart_repair", "toilet", "toilet_repair", "printer", "printer_repair",
        "tv", "tv_repair", "science_lab", "computer_lab", "tvl_lab",
        "english", "math", "science", "biological_science", "physical_science",
        "general_education", "araling_panlipunan", "tle", "mapeh", "filipino",
        "esp", "agriculture", "ece", "sped"
      )
      
      lapply(numeric_ids, function(id) {
        updateNumericInput(session, id, value = NA) 
      })
    }
  })
  
  
  
  # --- Observer to handle the "Start Over" button (remains unchanged) ---
  observeEvent(input$start_over, {
    session$reload()
  })
  
  
  observeEvent(input$submit, {
    
    # --- DEBUGGING STEP 0 (MOVED OUTSIDE TRY/CATCH) ---
    # If this notification shows, the observeEvent is definitely firing.
    showNotification("--- Submission Triggered! ---", duration = 5, type = "warning")
    
    # --- DEBUGGING STEP 1 (BREAKPOINT) ---
    # If the console stops here, the execution is successful up to this point.
    browser() # Press 'c' and Enter in the console to continue execution.
    
    # Use tryCatch to capture and display any errors during submission
    tryCatch({
      
      # Helper function to convert empty text/NA to a unified NA for sheet
      empty_to_na <- function(x) {
        if (is.character(x) && length(x) == 1 && x == "") {
          return(NA_character_)
        } else if (is.null(x) || is.na(x)) {
          return(NA)
        }
        return(x)
      }
      
      # --- CRITICAL PRE-CHECKS (Verify access to globals) ---
      if (!exists("SHEET_ID") || !exists("SHEET_NAME") || !is.function(school_data) || !exists("sheet_write")) {
        # This will now be caught by the tryCatch block if it runs
        stop("Fatal Error: One or more global dependencies (SHEET_ID, SHEET_NAME, school_data(), sheet_write/sheet_append functions) are missing or inaccessible.")
      }
      
      # Check if a record with the given school_id already exists in the local data
      data_df <- school_data()
      school_id_col <- tolower("school_id")
      
      match_row_index <- which(data_df[[school_id_col]] == input$school_id)
      record_exists <- length(match_row_index) > 0
      
      # Collect all form data into a data frame
      form_data_list <- lapply(required_inputs, function(id) {
        empty_to_na(input[[id]])
      })
      
      # Create the single-row data frame for submission
      new_data <- as.data.frame(form_data_list, stringsAsFactors = FALSE)
      names(new_data) <- required_inputs
      
      # Add a timestamp column (ensure column names match sheet headers)
      new_data$submission_timestamp <- as.character(Sys.time())
      
      if (record_exists) {
        # --- UPDATE existing record (Requires full sheet rewrite) ---
        showNotification(paste("Updating entry for", input$school_name), type = "message", duration = NULL)
        
        # 1. Update the local reactive data frame
        # Replace the row in the local data frame with the new data
        data_df[match_row_index[1], names(new_data)] <- new_data
        
        # 2. Write the entire modified data frame back to the sheet
        # Overwrites the existing sheet content entirely
        sheet_write(
          data = data_df, 
          ss = SHEET_ID, 
          sheet = SHEET_NAME
        )
        
      } else {
        # --- INSERT new record (Use sheet_append) ---
        showNotification(paste("New entry for", input$school_name, "submitted"), type = "message", duration = NULL)
        
        # 1. Append the new data to the sheet
        sheet_append(
          ss = SHEET_ID, 
          sheet = SHEET_NAME, 
          data = new_data
        )
        
        # 2. Update the local reactive data frame with the new row
        school_data(rbind(data_df, new_data))
      }
      
      # --- SUCCESS ACTIONS ---
      showNotification("Submission Complete!", type = "success", duration = 5)
      
      # Hide the form and show a thank you message after submission
      hide("form_container")
      show("thank_you_section")
      
    }, error = function(e) {
      # --- ERROR HANDLING ---
      error_message <- paste("Submission Failed! Details:", e$message)
      warning(error_message) # Log to console
      showNotification(error_message, type = "error", duration = NULL) # Show persistent notification
      
      # Re-enable the form if it was hidden
      show("form_container") 
    })
  })
  
  
  # --- Observer to handle the "Start Over" button (remains unchanged) ---
  observeEvent(input$start_over, {
    session$reload()
  })
  
}

shinyApp(ui, server)